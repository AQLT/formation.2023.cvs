[
  {
    "objectID": "quiz.html",
    "href": "quiz.html",
    "title": "{{< var titre.website >}}",
    "section": "",
    "text": "Exercice 1 Une série temporelle est un processus stochastique, dont on n’observe qu’une réalisation.\nA. Vrai\nB. Faux\n\n\nExercice 2 Quel schéma de décomposition est utilisé ?\n\nA. Additif\nB. Multiplicatif\n\n\nExercice 3 Quelle proposition se rapproche le plus de la définition d’un phénomène saisonnier ?\nA. Schéma de fluctuations qui se répète à court terme\nB. Variations infra-annuelles quasi-périodiques de période annuelle\nC. Mouvements qui sont liés aux saisons climatiques\nD. Mouvements qui s’annulent sur une année\n\n\nExercice 4 Pour les séries mensuelles et un schéma additif, quelle relation décrit un modèle de saisonnalité stable ?\nA. La somme des coefficients saisonniers de janvier à décembre est nulle\nB. \\(M_{2\\times 12}(S) = 0\\)\nC. La somme des coefficients saisonniers sur tout douze mois consécutifs est une constante\nD. \\(fréquence(S) = k\\times \\pi/6\\), pour \\(k = 1..5\\)\n\n\nExercice 5 Un spectre est…\nA. un graphique décrivant l’évolution de la série par fréquence\nB. une transformation d’une série en une fonction périodique\nC. un outil efficace pour tester la saisonnalité résiduelle, ainsi que les effets de calendrier résiduels\nD. une décomposition de la variance d’une série par fréquence\n\n\nExercice 6 Quels sont les différents effets du calendrier que l’on corrige ?\nA. Les effets jours ouvrables, année bissextile et graduel de Pâques\nB. Les effets jours ouvrables, année bissextile et jours fériés\nC. Les effets longueur du mois, types de jour et effets graduels des fêtes mobiles\nD. Les effets longueur du mois, types de jour et jours fériés\n\n\nExercice 7 Pourquoi fait-on un pré-ajustement des points atypiques ?\nA. Pour lisser la série pour l’interpréter plus facilement\nB. Pour linéariser la série pour estimer plus facilement la composante saisonnière\n\n\nExercice 8 Les outliers sont visibles sur la série désaisonnalisée :\nA. Non car ils sont corrigés pendant le pré-ajustement\nB. Oui\n\n\nExercice 9 Quel schéma de décomposition est utilisé ?\n\nA. Additif\nB. Multiplicatif\n\n\nExercice 10 À quelle composante est associée un additive outlier ?\nA. Tendance-cycle\nB. Saisonnalité\nC. Calendrier\nD. Irrégulier\nE. Autre\n\n\nExercice 11 À quelle composante est associée un level shift ?\nA. Tendance-cycle\nB. Saisonnalité\nC. Calendrier\nD. Irrégulier\nE. Autre\n\n\nExercice 12 À quelle composante est associée un transitory change ?\nA. Tendance-cycle\nB. Saisonnalité\nC. Calendrier\nD. Irrégulier\nE. Autre\n\n\nExercice 13 À quelle composante est associée un seasonal outlier ?\nA. Tendance-cycle\nB. Saisonnalité\nC. Calendrier\nD. Irrégulier\nE. Autre\n\n\nExercice 14 J’étudie mon salaire et j’ai un suppression de ma prime de décembre 2021 uniquement du fait du covid. Quel type de point atypique je suis susceptible de détecter ?\nA. Additive outlier (AO)\nB. Transitory Change (TC)\nC. Level Shift (LS)\nD. Seasonal Outlier (SO)\nE. Un autre type\n\n\nExercice 15 J’étudie mon salaire et pour des raisons administratives la prime que j’avais habituellement en décembre est maintenant versée en janvier. Quel type de point atypique je suis susceptible de détecter ?\nA. Additive outlier (AO)\nB. Transitory Change (TC)\nC. Level Shift (LS)\nD. Seasonal Outlier (SO)\nE. Un autre type\n\n\nExercice 16 Les composantes Tendance, Cycle et Saisonnalité sont elles stationnaires ?\nA. La tendance n’est pas stationnaire, mais le cycle et la saisonnalité sont stationnaires\nB. Aucune composante n’est stationnaire car leurs espérances d’ensemble dépendent du temps (ou variances)\nC. Seule la saisonnalité est stationnaire\nD. Seul le cycle est stationnaire\n\n\nExercice 17 Quelles sont les propriétés de la moyenne mobile \\(M_{2\\times 12}\\) ?\nA. Elle permet d’extraire la composante tendance-cycle finale\nB. Elle est longue de 12 termes, centrée et symétrique\nC. Elle préserve les tendance-cycles de forme polynomiale, et réduit fortement le bruit\nD. Elle préserve des droites, supprime une saisonnalité constante et réduit la taille du bruit\n\n\nExercice 18 La moyenne composée \\(M_{3\\times 5}\\) appliquée sur chaque mois ou chaque trimestre permet d’extraire une saisonnalité qui évolue linéairement\nA. Vrai\nB. Faux\n\n\nExercice 19 Quels indicateurs relatifs à la qualité de la décomposition doivent être examinés en priorité ?\nA. Les statistiques M7 et Q-M2\nB. La statistique Q qui résume en un seul indicateur l’ensemble des critères permettant d’évaluer la qualité\nC. La statistique M7 qui indique s’il existe une saisonnalité identifiable\nD. Les statistiques M7, M6, M9 puis M11\n\n\nExercice 20 Quelle est la méthode de rafraîchissement recommandée en campagnes mensuelles ou trimestrielles ?\nA. Concurrent last outliers\nB. Current last outliers\nC. Partial-concurrent last outliers\nD. Partial-current last outliers"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Désaisonnaliser une série temporelle",
    "section": "",
    "text": "Supports de cours et exercices de la formation Désaisonnaliser une série temporelle au CEPE les 6, 7, 13, 14 novembre 2023."
  },
  {
    "objectID": "index.html#tp-jdemetra",
    "href": "index.html#tp-jdemetra",
    "title": "Désaisonnaliser une série temporelle",
    "section": "TP JDemetra+",
    "text": "TP JDemetra+\n\nPremière manipulation de JDemetra+\nAnalyse exploratoire\nDésaisonnalisation sans correction des jours ouvrables\nDésaisonnalisation avec correction des jours ouvrables\nPré-ajustement\nDécomposition (X11)\nÉtude de cas"
  },
  {
    "objectID": "index.html#tp",
    "href": "index.html#tp",
    "title": "Désaisonnaliser une série temporelle",
    "section": "TP ",
    "text": "TP \n\nTraitement des séries temporelles sous \nR et JDemetra+\nCorrection des jours ouvrables\nPreajustement\nDécomposition (X11)\nJDemetra+ en production"
  },
  {
    "objectID": "TP/R_5_JD_in_production.html",
    "href": "TP/R_5_JD_in_production.html",
    "title": "5 - JDemetra+ en production",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler des workspaces pour une mise en production.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\"RJDemetra\", \"remotes\", \"rjdqa\", \"ggdemetra\", \"rjdmarkdown\", \"rjwsacruncher\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}\nif (! \"rjdworkspace\" %in% installed.packages()[,\"Package\"])\n    remotes::install_github(\"InseeFrLab/rjdworkspace\",\n                            INSTALL_opts = \"--no-multiarch\")\nLors de la mise en production, le plus simple est de manipuler des workspaces et de mettre à jour les modèles, lors de l’arrivée de nouvelles données à travers le JWSACruncher. Pour faciliter son utilisation depuis R, le package rjwsacruncher peut être utilisé.\nLorsque les workspaces sont créés depuis R, on perd toutes les métadonnées (lien vers les fichiers, commentaires, etc.), une solution pour cela : utiliser rjdworkspace (package non publié sur le CRAN) pour récupérer ces données depuis un autre workspace. Pour la version 3, rjdemetra3 contient toutes les fonctionnalités de rjdworkspace.\nDans ce TP on utilisera les données du package RJDemetra mais n’hésitez pas à utiliser vos propres séries."
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#sec:installation",
    "href": "TP/R_5_JD_in_production.html#sec:installation",
    "title": "5 - JDemetra+ en production",
    "section": "1.1 Configuration du JWSACruncher",
    "text": "1.1 Configuration du JWSACruncher\nLe JWSACruncher est téléchargeable ici : https://github.com/jdemetra/jwsacruncher/releases.\nPour utiliser les dernières versions il faut avoir une version de Java supérieure à la 8, si ce n’est pas le cas, il faut télécharger une version portable de Java et configurer le JWSACruncher en conséquence (voir manuel d’installation). Cette opération n’est pas utile si l’on utilise une version 3.x.y de JDemetra+ (une version portable de Java est “embarquée” avec le JWSACruncher). Ces manipulations peuvent aussi se faire à partir de rjwsacruncher :\n\n# install.packages(\"rjwsacruncher\") # Si pas déjà installé\nlibrary(rjwsacruncher)\n# Télécharge l'archive du JWSACruncher et la met sur le D:/\ndownload_cruncher(\n    \"D:/\",\n    # Par défaut on télécharge la dernière version du cruncher en V2    \n    v3 = FALSE)  \n# Dézipper l'archive configurer avec une version portable de Java :\njwsacruncher_path &lt;- \"D:/jwsacruncher-2.2.4-bin/bin/jwsacruncher.bat\" \n# Lien vers le fichier java.exe de la version portable de Java :\njava_path &lt;- \"D:/Java8/bin/java.exe\" \nconfigure_jwsacruncher(jwsacruncher_path, java_path)\n\nPour indiquer à rjwsacruncher où se trouve le JWSACruncher, le plus simple est de mettre à jour l’option cruncher_bin_directory :\n\n# Chemin vers le dossier bin du JWSACruncher\n# Remplacer \"jwsacruncher-2.2.4/bin\" par votre propre chemin.\noptions(cruncher_bin_directory =\n            \"jwsacruncher-2.2.4/bin\") \ngetOption(\"cruncher_bin_directory\") # Pour afficher la valeur actuelle\n\n[1] \"jwsacruncher-2.2.4/bin\""
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#utilisation-du-jwsacruncher",
    "href": "TP/R_5_JD_in_production.html#utilisation-du-jwsacruncher",
    "title": "5 - JDemetra+ en production",
    "section": "1.2 Utilisation du JWSACruncher",
    "text": "1.2 Utilisation du JWSACruncher\nPour éviter que le package rjwsacruncher soit trop volumineux, il ne contient pas le JWSAcruncher de JDemetra+. Ce dernier peut être téléchargé à l’adresse suivante : https://github.com/jdemetra/jdemetra-app/releases ou en utilisant la fonction rjwsacruncher::download_cruncher(). Pour sa configuration avec une version portable, voir le manuel d’installation.\nPour lancer le JWSACruncher il faut trois fichiers :\n\nun fichier contenant les paramètres sur la méthode de rafraîchissement à utilisée pour mettre à jour le workspace (créé à partir de la fonction create_param_file() ou list2param_file()) ;\n\nun workspace valide de JDemetra+ ;\n\nl’adresse vers le JWSACruncher (option cruncher_bin_directory).\n\nDans le package rjwsacruncher, les principales fonctions associées au lancement du JWSACruncher sont :\n\ncreate_param_file() ou list2param_file() qui permet de créer le fichier de paramètres ;\n\ncruncher() qui permet de lancer le JWSACruncher sur un workspace à partir d’un fichier de paramètres ;\n\ncruncher_and_param() qui permet de lancer le JWSACruncher tout en créant le fichier de paramètres et de personnaliser certaines sorties du JWSACruncher.\n\n\n1.2.1 Création du fichier de paramètres avec create_param_file()\nLes paramètres de la fonction create_param_file() sont les mêmes que ceux décrits dans le wiki du JWSACruncher de JDemetra+ (https://github.com/jdemetra/jwsacruncher/wiki). Les trois paramètres les plus importants de create_param_file() sont :\n\npolicy qui est la méthode de rafraîchissement utilisée (voir tableau ci-dessous).\n\n\n\n\n\nLes différentes politiques de rafraîchissement\n\n\nOption sous JDemetra+\nOption du cruncher\nSignification\n\n\n\n\nPartial concurrent adjustment -&gt; Fixed model\ncurrent\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients\nfixedparameters (ou fixed)\nLe modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients du modèle ARIMA sont fixés et les autres paramètres du modèle de régression sont ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima parameters\nparameters (paramètre par défaut)\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Last outliers\nlastoutliers\nLe modèle ARIMA, les outliers (sauf ceux de la dernière année) et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Les outliers de la dernière année sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + all outliers\noutliers\nLe modèle ARIMA et les paramètres du modèle regARIMA autres que les outliers ne sont pas ré-identifiés mais ré-estimés. Tous les outliers sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima model\nstochastic\nRé-identification de tous les paramètres du modèle regARIMA hormis les variables calendaires. Le schéma de décomposition est inchangé.\n\n\nConcurrent\ncomplete ou concurrent\nRé-identification de tout le modèle regARIMA.\n\n\n\n\n\n\n\n\n\nmatrix_item qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_matrix_item. On peut donc au choix modifier l’option default_matrix_item ou le paramètre matrix_item :\n\n\nlibrary(rjwsacruncher)\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_matrix_item\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple\n# que les critères d'information :\noptions(default_matrix_item = c(\"likelihood.aic\",\n                                \"likelihood.aicc\",\n                                \"likelihood.bic\",\n                                \"likelihood.bicc\"))\n\n\ntsmatrix_series qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_tsmatrix_series. On peut donc au choix modifier l’option default_tsmatrix_series ou le paramètre tsmatrix_series :\n\n\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_tsmatrix_series\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple que\n# la série désaisonnalisée et ses prévisions :\noptions(default_tsmatrix_series = c(\"sa\", \"sa_f\"))\n\nPour voir l’ensemble des paramètres, il suffit d’utiliser sous R la commande ?create_param_file.\nAprès cela, il ne reste plus qu’à créer le fichier de paramètres. Le fichier de paramètre est différent entre la version 3.0.0 de JDemetra+ et les versions antérieures. Les fonctions de création des fichiers de paramètres ont un paramètre v3 qui permet de spécifier si l’on veut que le fichier soit compatible avec la version 3.0.0. Sa valeur par défaut est getOption(\"is_cruncher_v3\") : si l’on utilise la version 3.0.0 ou plus, le plus simple est donc de changer cette option options(is_cruncher_v3 = TRUE). Ci-dessous quelques exemples.\n\n# Un fichier parametres.param sera créé sous D:/ \n# avec la politique de rafraîchissement \"lastoutliers\" \n# et les autres paramètres par défaut\ncreate_param_file(dir_file_param = \"D:/\",\n                  policy = \"lastoutliers\")\n# Si l'on a modifié les options \"default_matrix_item\" et \"default_tsmatrix_series\" pour\n# n'exporter que les critères d'information, la série désaisonnalisée et ses\n# prévisions, la commande précédente est équivalent à : \ncreate_param_file(dir_file_param = \"D:/\",\n                  policy = \"lastoutliers\",\n                  matrix_item = c(\"likelihood.aic\", \"likelihood.aicc\",\n                                \"likelihood.bic\", \"likelihood.bicc\"),\n                  tsmatrix_series = c(\"sa\", \"sa_f\"))\n\n\n\n\n\n\n\nExercice\n\n\n\nUtiliser la fonction create_param_file() pour créé un fichier de paramètres permettant de mettre à jour un workspace :\n\nEn reestimant le modèle ARIMA, les outliers et les autres paramètres du modèle de régression et en re-identifiant les outliers uniquement sur la dernière année.\nEn exportant la statistique M7, la statistique Q-M2 et les tests de jours ouvrables résiduels ;\nEn exportant La série brute, la série désaisonnalisée et la tendance (de manière verticale).\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour voir les noms des paramètres, utiliser la fonction default_param_file() ou bien aller sur la page https://github.com/jdemetra/jwsacruncher/wiki/Output-dictionaries.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndir &lt;- tempdir()\ncreate_param_file(\n    dir_file_param = dir,\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\" \n)\n\n\n\n\nLes fichiers de paramètres peuvent être lus avec read_param_file() qui renvoie une liste qui peut être modifiée et exportée avec list2param_file() :\n\nparam_f &lt;- read_param_file(file.path(dir, \"parameters.param\"))\nstr(param_f)\n\nList of 7\n $ config         :List of 4\n  ..$ bundle       : chr \"10000\"\n  ..$ csv_layout   : chr \"vtable\"\n  ..$ csv_separator: chr \";\"\n  ..$ ndecs        : chr \"6\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"m-statistics.m7\" \"m-statistics.q-m2\" \"diagnostics.residual trading days tests.f-test on sa (td):2\" \"diagnostics.residual trading days tests.f-test on i (td):2\"\n $ tsmatrix_series: chr [1:3] \"y\" \"sa\" \"t\"\n $ paths_path     : NULL\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction default_param_file().\n\n\n1.2.2 Lancement du JWSACruncher\nPour lancer le JWSACruncher avec cruncher() ou cruncher_and_param(), il faut spécifier le chemin d’accès au dossier contenant le JWSACruncher (paramètre cruncher_bin_directory) ainsi que celui du workspace à traiter (paramètre workspace). Si cela a déjà été fait dans la section [-@sec:installation], ne pas prendre en compte le paragraphe suivant\nPar défaut, le chemin d’accès au dossier du JWSACruncher est celui contenu dans le paramètre cruncher_bin_directory : il suffit donc de modifier une seule fois cette option afin qu’elle s’applique à toutes les exécutions du JWSACruncher. Le chemin à indiquer est celui du dossier contenant le fichier jwsacruncher.bat, situé dans le dossier “Bin” du dossier d’installation du JWSACruncher. Ainsi, s’il a été installé sous D:\\jdemetra-cli-2.2.4, le fichier jwsacruncher.bat sera présent sous D:\\jdemetra-cli-2.2.4\\bin. Il faut donc modifier l’option cruncher_bin_directory de la façon suivante :\n\noptions(cruncher_bin_directory = \"D:/jdemetra-cli-2.2.4/bin/\")\n\nSi aucun chemin de workspace n’est renseigné, une fenêtre s’ouvre, invitant à sélectionner le workspace sur lequel on souhaite lancer le JWSACruncher.\n\n# Remplacer ici \"workspace.xml\" par le chemin vers votre workspace\ncruncher(workspace = \"workspace.xml\",\n# Remplacer ici \"parameters.param\" par le chemin vers votre fichier de paramètres\n         param_file_path = \"parameters.param\"\n)\n\nSi vous n’avez pas de workspace vous pouvez utiliser le code suivant pour en générer un :\n\nlibrary(RJDemetra)\nspec_x13 &lt;- x13_spec(spec = \"RSA5c\")\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"sa1\")\n\nfor (nom_series in colnames(ipi_c_eu)){\n    model &lt;- jx13(ipi_c_eu[,nom_series], spec_x13)\n    add_sa_item(jws, \"sa1\", model, nom_series)\n}\n\nsave_workspace(jws, \"workspace.xml\")\n\nSi non spécifié dans le fichier des paramètres, les résultats sont exportés dans le sous dossier \"Output\" du workspace (pour le workspace.xml, les résultats seront donc sous workspace/Output/). On peut aussi créer le fichier des paramètres et lancer le JWSAcruncher avec la fonction cruncher_and_param. Cette fonction permet aussi de renommer les dossiers exportées avec les noms des multi-processings utilisés dans JDemetra+ (évite d’avoir des dossiers du type SAProcessing-1)1.\n\ncruncher_and_param(\n    workspace = \"workspace.xml\",\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\"\n)"
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#ggdemetra",
    "href": "TP/R_5_JD_in_production.html#ggdemetra",
    "title": "5 - JDemetra+ en production",
    "section": "5.1 ggdemetra",
    "text": "5.1 ggdemetra\nggdemetra permet de faire de la désaisonnalisation comme une couche supplémentaire de ggplot2.\n\ngeom_sa() : pour ajouter une série temporelle associée à la désaisonnalisation (tendance, série désaisonnalisée, etc.) ;\ngeom_outlier() : pour ajouter les points atypiques corrigés dans le pre-ajustement ;\ngeom_arima() : pour ajouter le modèle ARIMA ;\ngeom_diagnostics() : pour ajouter un tableau avec des diagnostics.\n\nPar exemple, pour tracer les séries désaisonnalisées d’un ensemble de séries temporelles :\n\nlibrary(ggdemetra)\ndataGraph &lt;- ts2df(na.omit(ipi_c_eu[,c(\"FR\", \"UK\", \"IT\")]))\ndataGraph &lt;- reshape2::melt(dataGraph, id = \"date\")\nggplot(data = dataGraph, aes (x = date, y = value, color = variable)) +\n    geom_sa(component = \"sa\", frequency = 12, spec = x13_spec(\"RSA4c\"))\n\n\n\n\n\n\n\nFigure 1: Désaisonnalisation de plusieurs séries avec ggplot2 grâce à ggdemetra.\n\n\n\n\n\nSi vous avez déjà estimé un modèle avec RJDemetra, vous pouvez directement initialiser votre graphique grâce à la fonction init_ggplot :\n\nmod &lt;- x13(window(ipi_c_eu[,\"FR\"], end = 2019))\ndiagnostics &lt;- c(`Combined test` = \"diagnostics.combined.all.summary\",\n                 `Residual qs-test (p-value)` = \"diagnostics.qs\",\n                 `Residual f-test (p-value)` = \"diagnostics.ftest\")\np_sa &lt;- init_ggplot(mod) +\n    geom_line(color =  \"#F0B400\") +\n    geom_sa(component = \"y_f\", linetype = 2,\n            color =  \"#F0B400\") + \n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2) + \n    geom_outlier(geom = \"label_repel\",\n                 coefficients = TRUE,\n                 ylim = c(NA, 65), \n                 arrow = arrow(length = unit(0.03, \"npc\"),\n                              type = \"closed\", ends = \"last\"),\n                 digits = 2) + \n    geom_arima(geom = \"label\",\n               x_arima = -Inf, y_arima = Inf, \n               vjust = 1.2, hjust = -0.1)\np_sa +   \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 6),\n                     ymin = 115, ymax = 130, xmin = 2010,\n                     message = FALSE)\n\n\n\n\n\n\n\nFigure 2: Exemple des différentes fonctionnalités de ggdemetra.\n\n\n\n\n\nPour combiner plusieurs graphiques on peut également utiliser le package patchwork :\n\nlibrary(patchwork)\np_diag &lt;- init_ggplot(mod)  + \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 8),\n                     message = FALSE) +\n    theme_void()\np_sa / p_diag + \n  plot_layout(heights = unit(c(4, 1.5), \"null\"))\n\n\n\n\n\n\n\nFigure 3: Combinaison de plusieurs graphiques de ggdemetra avec patchwork.\n\n\n\n\n\nLa fonction ggsiratioplot() permet de tracer les SI ratios avec ggplot2 :\n\nggsiratioplot(mod)\n\n\n\n\n\n\n\nFigure 4: S-I ratio avec ggplot2 et ggdemetra::ggsiratioplot().\n\n\n\n\n\nLes différentes composantes du modèle (ainsi que leurs prévisions) peuvent être facilement extraites via les fonctions calendar(), calendaradj(), irregular(), trendcycle(), seasonal(), seasonaladj(), trendcycle() and raw().\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction graph_synthetique() qui prend en paramètre un modèle de RJDemetra et qui fait deux graphiques :\n\nà gauche les séries brutes, désaisonnalisée et tendance sur les 10 dernières années ;\nà droite les SI-Ratio.\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour récupérer les 10 dernières années on pourra récupérer la dernière date connue avec la fonction time() et utiliser la fonction ggplot2::coord_cartesian() (à préférer à la fonction ggplot2::xlim() qui supprime des données et refait donc une désaisonnalisation sur une autre période).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngraph_synthetique &lt;- function (x, titre = NULL) {\n    y &lt;- raw(x)\n    last_date &lt;- time(y)[length(y)]\n    p_sa &lt;- init_ggplot(x) +\n        geom_line(color = \"#F0B400\") +\n        geom_sa(component = \"sa\", color = \"#155692\") +\n        geom_sa(component = \"t\", color = \"#1E6C0B\") +\n        coord_cartesian(xlim = c(last_date - 10, NA)) +\n        # On change l'affichage de l'axe des abscisses\n        scale_x_continuous(labels = zoo::as.yearmon)\n    p_siratio &lt;- ggsiratioplot(x,\n                               # supprime le titre\n                               main = NULL, \n                               start = last_date - 10) \n    ((p_sa + p_siratio) &\n        # on applique la fonction theme_bw à tous les graphiques\n            theme_bw()) +\n        # On ajoute un titre global\n        plot_annotation(\n            title = titre\n        )\n}\ngraph_synthetique(mod)\n\n\n\n\n\n\n\nFigure 5: Exemple de tableau de bord grâce à ggdemetra.\n\n\n\n\n\nCi-dessous un exemple de comparaison entre ggplot2::xlim() et ggplot2::coord_cartesian() :\n\np_cc &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    coord_cartesian(xlim = c(2010, NA), ylim = c(95, 120)) \np_xlim &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    xlim(c(2010, NA)) +\n    coord_cartesian(ylim = c(95, 120)) \np_cc / p_xlim\n\nWarning: Removed 240 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\nFrequency used: 12\n\n\nWarning: Removed 240 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\n\n\n\n\n\n\nFigure 6: Comparaison des fonctions ggplot2::xlim() et ggplot2::coord_cartesian().\n\n\n\n\n\nUn message et deux warnings sont générés : c’est parce que les données avant 2010 sont supprimées avec la fonction xlim() et qu’une nouvelle désaisonnalisation est alors effectuée (avec une spécification par défaut qui peut être différente de celle utilisée pour créer le modèle). Cela explique les différences entre les deux graphiques\n\n\n\nÀ partir de la fonction précédente, on peut par exemple faire une fonction qui va lire un workspace et faire un cahier pdf le graphique précédent pour tous les modèles de chaque multiprocessing :\n\n# Construisons d'abord un workspace exemple :\ny &lt;- ipi_c_eu[, \"FR\"]\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"X-13\")\nnew_multiprocessing(jws, \"TRAMO-SEATS\")\nfor (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n    add_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n}\nfor (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n    add_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n}\ndir &lt;- tempdir()\nsave_workspace(jws, file.path(dir, \"workspace.xml\"))\n\n\njws &lt;- load_workspace(file.path(dir, \"workspace.xml\"))\ncompute(jws)\nall_m &lt;- get_model(jws, progress_bar = FALSE)\nall_m &lt;- lapply(all_m, function(x){\n  # On enlève les espaces à la fin des noms,\n  # cela arrive souvent avec les fichiers Excel\n  names(x) &lt;- gsub(\" *$\", \"\", names(x))\n  x\n})\n# Booléen pour supprimer les fichiers existants\nreplace_existing_file &lt;- TRUE\n# dossier contenant tous les graphiques\ndir_exp &lt;- \"graph\"\nif (!dir.exists(dir_exp))\n  dir.create(dir_exp)\nfor (sap in names(all_m)) {\n  if (!dir.exists(file.path(dir_exp, sap)))\n    dir.create(file.path(dir_exp, sap))\n  for(series in names(all_m[[sap]])) {\n    # Si le fichier existe déjà on ne fait pas l'export\n    file &lt;- file.path(\n        dir_exp, sap, paste0(\n    # on ne prend que les 20 premiers caractères pour les noms des fichiers\n    # (vite trop long si on part de fichiers Excel)\n            substr(series, 1, 20), \n            \".pdf\"))\n\n    if (!replace_existing_file && file.exists(file))\n      next;\n    print(sprintf(\"%s : %s\", sap, series))\n    p_dashboard &lt;- graph_synthetique(x = all_m[[sap]][[series]],\n                                     titre = series)\n    ggsave(filename = file, plot = p_dashboard,\n           # format A4 paysage\n           width = 29.7, height = 21, units = \"cm\")\n  }\n}\n\n# Ensuite on va créer un cahier avec tous les pdfs\nfor (sap in names(all_m)) {\n  qpdf::pdf_combine(input = sprintf(\"%s/%s/%s.pdf\", dir_exp, sap,\n                                  substr(names(all_m[[sap]]), 1, 20)),\n                    output = sprintf(\"%s/%s.pdf\", dir_exp, sap))\n}"
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#rjdqa",
    "href": "TP/R_5_JD_in_production.html#rjdqa",
    "title": "5 - JDemetra+ en production",
    "section": "5.2 rjdqa",
    "text": "5.2 rjdqa\nrjdqa permet de reproduire deux tableaux de bord différents (mais avec base R plutôt que ggplot2 pour des raisons de performance) :\n\nsc_dashboard() qui reproduit le tableau de bord de Statistique Canada : voir notamment chapitre 22 du Handbook sur la désaisonnalisation https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/-/KS-GQ-18-001 ;\nsimple_dashboard() qui reproduit un tableau de bord simplifié.\n\nSi vous avez d’autres idées n’hésitez pas à contribuer au package ou à faire une issue sur github !\n\nlibrary(rjdqa)\nmod &lt;- tramoseats(window(ipi_c_eu[,\"FR\"], end = 2019))\nplot(sc_dashboard(mod))\nplot(simple_dashboard(mod))\n\n\n\n\n\n\n\nFigure 7: Tableau de bord de Statistique Canada avec sc_dashboard().\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Tableau de bord de simplifié avec simple_dashboard()."
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#rjdmarkdown",
    "href": "TP/R_5_JD_in_production.html#rjdmarkdown",
    "title": "5 - JDemetra+ en production",
    "section": "5.3 rjdmarkdown",
    "text": "5.3 rjdmarkdown\nrjdmarkdown fournit différentes fonctions pour améliorer le rendu des modèles avec rmarkdown. Voir :\n\nhttps://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-pdf.pdf pour le rendu en PDF ;\nhttps://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-html.html pour le rendu HTML.\n\nUn document peut également être généré de manière automatique à partir d’un workspace. Par exemple :\n\n# # On peut reprendre le workspace précédent\n# y &lt;- ipi_c_eu[, \"FR\"]\n# jws &lt;- new_workspace()\n# new_multiprocessing(jws, \"X-13\")\n# new_multiprocessing(jws, \"TRAMO-SEATS\")\n# for (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n#   add_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n# }\n# for (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n#   add_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n# }\n# dir &lt;- tempdir()\n# save_workspace(jws, file.path(dir, \"workspace.xml\"))\n\nlibrary(rjdmarkdown)\noutput_file &lt;- tempfile(fileext = \".Rmd\")\ncreate_rmd(jws, output_file, \n           output_format = c(\"html_document\", \"pdf_document\"),\n           output_options = list(toc = TRUE,\n                              number_sections = TRUE))\nbrowseURL(sub(\".Rmd\",\".pdf\", output_file, fixed = TRUE))\nbrowseURL(sub(\".Rmd\",\".html\", output_file, fixed = TRUE))\n\nEn réutilisant la fonction graph_synthetique() précédente :\n\noutput_file &lt;- tempfile(fileext = \".Rmd\")\nout &lt;- create_rmd(jws, output_file, \n           output_format = c(\"pdf_document\"),\n           preprocessing_fun = NULL,\n           decomposition_fun = graph_synthetique,\n           diagnostics_fun = NULL,\n           output_options = list(toc = TRUE,\n                                 number_sections = TRUE),\n           knitr_chunk_opts = list(fig.pos = \"h\", echo = FALSE,\n                                fig.cap = \"Tableau de bord\"))\nbrowseURL(out)"
  },
  {
    "objectID": "TP/R_5_JD_in_production.html#footnotes",
    "href": "TP/R_5_JD_in_production.html#footnotes",
    "title": "5 - JDemetra+ en production",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\n Une autre façon de faire est d’importer le workspace jws &lt;- load_workspace(\"workspace.xml\") et de le sauvegarder sans rien faire save_workspace(\"workspace.xml\"). L’export va renommer les noms des fichiers des multi-processings en utilisant leur nom, ce qui évitera cette opération de renommage.↩︎"
  },
  {
    "objectID": "TP/R_3_Preadjustment.html",
    "href": "TP/R_3_Preadjustment.html",
    "title": "3 - Qualité du préajustement sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à vérifier la qualité du pré-ajustement dans RJDemetra.\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\npackages_to_install &lt;- c(\"RJDemetra\", \"remotes\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}\n\nPrenons une spécification par défaut :\n\nlibrary(RJDemetra)\nipi_fr &lt;- ipi_c_eu[, \"FR\"]\nmysa &lt;- x13(ipi_fr)\n\nComme on l’a vu dans le TP2, les tests de Student peuvent être utilisés pour tester la significativité des coefficients, et on peut également faire des tests de Fisher avec le package car pour voir si l’on peut simplifier les régresseurs jours ouvrables. Voir également le TP2 pour les tests sur la présence de jours ouvrables résiduelle.\n\nsummary(mysa$regarima)\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2020\nLog-transformation: no\nRegression model: no mean, trading days effect(7), leap year effect, Easter effect, outliers(4)\n\nCoefficients:\nARIMA: \n            Estimate Std. Error  T-stat Pr(&gt;|t|)    \nPhi(1)     0.0003269  0.1077296   0.003   0.9976    \nPhi(2)     0.1688192  0.0740996   2.278   0.0233 *  \nTheta(1)  -0.5485606  0.1016550  -5.396 1.24e-07 ***\nBTheta(1) -0.6660849  0.0422242 -15.775  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n              Estimate Std. Error  T-stat Pr(&gt;|t|)    \nMonday         0.55932    0.22801   2.453 0.014638 *  \nTuesday        0.88221    0.22832   3.864 0.000132 ***\nWednesday      1.03996    0.22930   4.535 7.85e-06 ***\nThursday       0.04943    0.22944   0.215 0.829549    \nFriday         0.91132    0.22988   3.964 8.88e-05 ***\nSaturday      -1.57769    0.22775  -6.927 1.99e-11 ***\nLeap year      2.15403    0.70527   3.054 0.002425 ** \nEaster [1]    -2.37950    0.45391  -5.242 2.71e-07 ***\nTC (4-2020)  -35.59245    2.17330 -16.377  &lt; 2e-16 ***\nAO (3-2020)  -20.89026    2.18013  -9.582  &lt; 2e-16 ***\nAO (5-2011)   13.49850    1.85694   7.269 2.28e-12 ***\nLS (11-2008) -12.54901    1.63554  -7.673 1.60e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 2.218 on 342 degrees of freedom\nLog likelihood = -799.1, aic =  1632, aicc =  1634, bic(corrected for length) = 1.855\n\nlibrary(car)\n# On rejette l'hypothèse de nullité globale des coefficients\nlinearHypothesis(mysa,\n                 c(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"),\n                 c(0, 0, 0, 0, 0, 0), test = \"F\")\n\nLinear hypothesis test\n\nHypothesis:\nMonday = 0\nTuesday = 0\nWednesday = 0\nThursday = 0\nFriday = 0\nSaturday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F    Pr(&gt;F)    \n1    348                        \n2    342  6 83.415 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# On pourrait rassembler les jours de la semaine :\nlinearHypothesis(mysa,\n                 c(\"Monday = Tuesday\",\"Tuesday = Wednesday\",\"\n                   Wednesday = Thursday\", \"Thursday = Friday\"), test = \"F\")\n\nLinear hypothesis test\n\nHypothesis:\nMonday - Tuesday = 0\nTuesday - Wednesday = 0\nWednesday - Thursday = 0\nThursday - Friday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F  Pr(&gt;F)  \n1    346                    \n2    342  4 2.1504 0.07429 .\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nConcernant la qualité du modèle RegARIMA, on peut citer trois tests :\n\nLe test d’indépendance des résidus\nLe test d’homoscédasticité des résidus\nLe test de normalité des résidus\n\nCes trois tests, également disponibles par des fonctions spécifiques sous R (la commande residuals(mysa) permet de récupérer les résidus du modèle), sont également disponibles dans le sous objet .$regarima$residuals.stat$tests :\n\nmysa$regarima$residuals.stat$tests\n\n\nNormality\n         Statistic P.value    \nmean       0.12648  0.8994 ***\nskewness  -0.01954  0.8799 ***\nkurtosis   3.54844  0.0339    \n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                               55.08622  0.0000    \nljung box (residuals at seasonal lags)   3.09960  0.2123 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value  \nljung box (squared residuals)  34.36237  0.0238  \n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\n\nL’hétéroscédasticité et la non-normalité proviennent souvent de la présence de points atypiques non corrigés (pour jouer sur le seuil de détection, rajouter dans la spécification outlier.usedefcv = FALSE et prendre une valeur de outlier.cv inférieur à 4, qui est la valeur par défaut). Changer le schéma de décomposition peut aussi aider (transform.function = \"None\" pour un modèle additif ou transform.function = \"Log\" pour un modèle multiplicatif) :\n\nmysa2 &lt;- x13(ipi_fr, x13_spec(mysa, outlier.usedefcv = FALSE,\n                              outlier.cv = 3))\n# Bien plus d'outliers sont détectés !\nsummary(mysa2$regarima)\n\ny = regression model + arima (3, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2020\nLog-transformation: no\nRegression model: no mean, trading days effect(7), leap year effect, Easter effect, outliers(28)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nPhi(1)     0.27920    0.09413  2.966  0.00322 ** \nPhi(2)     0.36429    0.07687  4.739 3.10e-06 ***\nPhi(3)     0.11811    0.07680  1.538  0.12496    \nTheta(1)  -0.63217    0.08106 -7.799 6.84e-14 ***\nBTheta(1) -0.34211    0.05369 -6.372 5.72e-10 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n             Estimate Std. Error  T-stat Pr(&gt;|t|)    \nMonday         0.3870     0.1811   2.137 0.033265 *  \nTuesday        0.9721     0.1818   5.348 1.58e-07 ***\nWednesday      0.8970     0.1830   4.903 1.43e-06 ***\nThursday       0.1836     0.1826   1.006 0.315205    \nFriday         0.9678     0.1846   5.244 2.69e-07 ***\nSaturday      -1.6723     0.1829  -9.145  &lt; 2e-16 ***\nLeap year      1.7207     0.5026   3.423 0.000690 ***\nEaster [1]    -2.3262     0.3536  -6.578 1.68e-10 ***\nTC (4-2020)  -34.9803     1.3450 -26.007  &lt; 2e-16 ***\nAO (3-2020)  -20.5598     1.6847 -12.204  &lt; 2e-16 ***\nAO (5-2011)   11.6856     1.3242   8.825  &lt; 2e-16 ***\nLS (11-2008)  -9.4587     1.0474  -9.030  &lt; 2e-16 ***\nLS (1-2009)   -7.8963     1.0256  -7.699 1.34e-13 ***\nAO (6-2019)   -5.7932     1.4256  -4.064 5.94e-05 ***\nLS (8-2009)    5.7013     0.8196   6.957 1.66e-11 ***\nTC (1-2011)    5.6019     1.0501   5.334 1.70e-07 ***\nAO (5-2018)   -4.5600     1.3401  -3.403 0.000743 ***\nLS (5-2008)   -4.7919     0.7824  -6.125 2.38e-09 ***\nAO (5-2000)    5.2033     1.3250   3.927 0.000103 ***\nAO (6-2003)   -5.4817     1.3322  -4.115 4.81e-05 ***\nAO (5-1991)   -4.5123     1.3544  -3.332 0.000953 ***\nLS (5-1994)    3.2027     0.7772   4.121 4.69e-05 ***\nTC (12-2009)  -4.5311     1.0961  -4.134 4.44e-05 ***\nLS (3-1997)    3.5716     0.7567   4.720 3.38e-06 ***\nLS (1-1993)   -3.4933     0.7611  -4.590 6.15e-06 ***\nAO (8-2020)    6.3136     1.6987   3.717 0.000234 ***\nTC (11-2000)   5.8864     1.0215   5.762 1.79e-08 ***\nTC (8-2015)    3.5207     0.9715   3.624 0.000332 ***\nTC (12-1999)   4.4543     1.0307   4.322 2.01e-05 ***\nLS (10-1997)   2.7159     0.7569   3.588 0.000379 ***\nTC (12-1994)   4.2812     0.9973   4.293 2.27e-05 ***\nTC (10-2017)   3.9944     0.9801   4.076 5.65e-05 ***\nLS (11-2019)  -3.0752     0.9235  -3.330 0.000959 ***\nLS (2-2004)    2.1923     0.7651   2.865 0.004409 ** \nAO (6-2011)   -4.8397     1.3372  -3.619 0.000338 ***\nTC (11-2011)   4.0079     1.0178   3.938 9.88e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 1.627 on 317 degrees of freedom\nLog likelihood = -685.6, aic =  1455, aicc =  1467, bic(corrected for length) = 1.646\n\n\nLa qualité des prévisions peut également être vérifiée à travers plusieurs tests :\n\nEst-ce que la moyenne des erreurs prévisions in sample (i.e. : modèle estimé sur toute la période) et la moyenne des prévisions out of sample (i.e. : modèle estimé de manière dynamique en ajoutant une a à une les nouvelles données) sont nulles ? Ces tests sont sensibles à la non-normalité des résidus\nEst-ce que les variances des erreurs de prévision in sample et out of sample sont les mêmes ? Ce test est sensible à la non-normalité des résidus\nEst-ce qu’il y a “trop” d’outliers ? Dans JDemetra+, on considère par défaut qu’il y a trop d’outliers si la proportion d’outliers par rapport aux nombres d’observations est supérieure à 5 %.\n\nLes trois premiers tests ne sont pas par défaut exportés dans RJDemetra : il faut les rajouter à la main avec le paramètre userdefined. Ils seront alors disponibles dans la sous-liste .$user_defined. Concernant la proportion d’outliers, elle peut être calculée à la main à partir du nombre d’outliers (par exemple disponible dans .$regarima$model$spec_rslt) :\n\nmysa &lt;- x13(ipi_fr, x13_spec(mysa),\n            userdefined = c(\"diagnostics.fcast-insample-mean\",\n                            \"diagnostics.fcast-outsample-mean\",\n                            \"diagnostics.fcast-outsample-variance\"))\nmysa$regarima$model$spec_rslt\n\n           Model                 T.span Log transformation  Mean Trading days\n1 RegARIMA - X13 from 1-1990 to 12-2020              FALSE FALSE            7\n  Leap year Easter Outliers\n1      TRUE   TRUE        4\n\n# Pour éviter outputs trop longs, l'affichage est réduit :\nmysa$user_defined\n\nNames of additional variables (3):\ndiagnostics.fcast-insample-mean, diagnostics.fcast-outsample-mean, diagnostics.fcast-outsample-variance\n\n# Pour supprimer cela, vous pouvez par exemple utiliser le code suivant :\nc(mysa$user_defined)\n\n$`diagnostics.fcast-insample-mean`\n[1] 0.3057321 0.7599958\nattr(,\"description\")\n[1] \"T with 340 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.7781656  0.4370126\nattr(,\"description\")\n[1] \"T with 340 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 1.1383576 0.3128808\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 341 degrees of freedom in the denominator\"\n\n\nVous pouvez bien sûr utiliser votre tests préféré à partir de ceux disponibles sous R (autre test de normalité…).\nPour comparer différents modèles, vous pouvez également utiliser les critères d’information (mais il faut que les modèles ARIMA aient les mêmes ordres de différenciation !). Vous pouvez pour cela utiliser les fonctions de bases de R (AIC(), BIC()…) ou prendre ceux de JDemetra+ (affichés lors du summary(), qu’on peut également retrouver par la commande .$regarima$loglik) :\n\nAIC(mysa)\n\n[1] 1632.169\n\nBIC(mysa)\n\n[1] 1698.185\n\n# Il y a un peu plus de critères que dans base R : AICc et BICc\nmysa$regarima$loglik\n\n                         \nlogvalue      -799.084484\nnp              17.000000\nneffectiveobs  359.000000\naic           1632.168967\naicc          1633.963689\nbic           1698.185448\nbicc             1.855018\n\n\n\n\n\n\n\n\nExercice\n\n\n\nPrenez une série et étudier la qualité du modèle RegARIMA. Essayer de changer quelques paramètres : est-ce que le nouveau modèle vous parait meilleur ou moins bien que l’ancien ?"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html",
    "href": "TP/R_1_R_et_JD.html",
    "title": "1 - R et JDemetra+",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler JDemetra+ sous R à travers le package RJDemetra.\nPour manipuler JDemetra+ sous R il y a actuellement deux façons :\nDans ce TP on utilisera les données du package RJDemetra mais n’hésitez pas à utiliser vos propres séries !\nPour faire de la désaisonnalisation sous R il existe plusieurs packages :\nRJDemetra est sur le CRAN et se base sur les librairies Java de JDemetra+. Pour l’utiliser il faut avoir Java 8 ou plus. En cas de problème d’installation voir la page : https://github.com/jdemetra/rjdemetra/wiki/Installation-manual.\nLe package a aussi un site web (https://jdemetra.github.io/rjdemetra/).\nRJDemetra permet :\nUne nouvelle version de RJDemetra est en cours de développement autour de la version 3.0 de JDemetra+. Elle nécessite toutefois d’avoir une version de Java supérieure à la version 17 et elle n’est pas sur le CRAN. Les fonctionnalités de RJDemetra (et les nouvelles) sont divisées en plusieurs packages disponibles sous https://github.com/rjdemetra. Dans cette formation, nous utiliserons les packages suivants RJDemetra, rjd3toolkit, rjd3tramoseats, rjd3providers, rjdemetra3 :\npackages_to_install &lt;- c(\"RJDemetra\", \"remotes\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}\nlibrary(RJDemetra)"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#sec-spec-jd2",
    "href": "TP/R_1_R_et_JD.html#sec-spec-jd2",
    "title": "1 - R et JDemetra+",
    "section": "1.1 Créer une specification",
    "text": "1.1 Créer une specification\nDans les prochains exercices, la série utilisée sera ipi_c_eu[, \"FR\"] qui est l’IPI français. Vous pouvez bien sûr adapter le code pour utiliser vos propres séries. Les fonctions utilisées seront x13(), x13_spec(), regarima_x13, regarima_x13_spec ou regarima. Le détail des spécifications pré-définies par JDemetra+ sont disponibles ici.\n\n\n\n\n\n\nExercice\n\n\n\nFaire la désaisonnalisation d’une série avec X-13 avec la spécification suivante :\n\ndétection automatique du schéma de décomposition, des outliers et du modèle ARIMA ;\nune correction des jours ouvrables “working days” et un effet graduel de Pâques.\n\nFaire ensuite un graphique avec la série brute et la série désaisonnalisée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nUtiliser la spécification RSA4c pour la désaisonnalisation.\nSi le modèle créé s’appelle mysa, regarder les valeurs de mysa$final, mysa$final$series et mysa$final$forecasts.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(RJDemetra)\nmysa &lt;- x13(ipi_c_eu[, \"FR\"], spec = \"RSA4c\")\nmysa\n\nRegARIMA\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: no\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05291      0.108\nPhi(2)     0.18672      0.074\nTheta(1)  -0.52137      0.103\nBTheta(1) -0.66132      0.042\n\n             Estimate Std. Error\nWeek days      0.6927      0.031\nLeap year      2.0903      0.694\nEaster [1]    -2.5476      0.442\nTC (4-2020)  -35.6481      2.092\nAO (3-2020)  -21.1492      2.122\nAO (5-2011)   13.1869      1.810\nLS (11-2008)  -9.2744      1.758\nLS (1-2009)   -7.2838      1.756\n\n\nResidual standard error: 2.193 on 346 degrees of freedom\nLog likelihood = -795.1, aic =  1616 aicc =  1617, bic(corrected for length) = 1.767\n\n\n\nDecomposition\nMonitoring and Quality Assessment Statistics:\n      M stats\nM(1)    0.127\nM(2)    0.079\nM(3)    1.094\nM(4)    0.558\nM(5)    1.093\nM(6)    0.022\nM(7)    0.085\nM(8)    0.242\nM(9)    0.064\nM(10)   0.261\nM(11)   0.247\nQ       0.355\nQ-M2    0.389\n\nFinal filters: \nSeasonal filter:  3x5\nTrend filter:  13 terms Henderson moving average\n\n\nFinal\nLast observed values\n             y        sa        t           s           i\nJan 2020 101.0 102.87273 103.0457  -1.8727280  -0.1730003\nFeb 2020 100.1 103.69025 103.0626  -3.5902540   0.6276448\nMar 2020  91.8  82.69170 103.2654   9.1083000 -20.5736602\nApr 2020  66.7  66.55184 103.6945   0.1481625 -37.1426277\nMay 2020  73.7  79.28883 104.1379  -5.5888279 -24.8490764\nJun 2020  98.2  87.35362 104.4539  10.8463757 -17.1002284\nJul 2020  97.4  92.26057 104.5518   5.1394323 -12.2912806\nAug 2020  71.7  97.54392 104.3369 -25.8439193  -6.7929846\nSep 2020 104.7  97.75728 103.8361   6.9427184  -6.0788659\nOct 2020 106.7  97.87016 103.1969   8.8298396  -5.3267823\nNov 2020 101.6 100.01475 102.6601   1.5852540  -2.6453446\nDec 2020  96.6  99.61740 102.4081  -3.0173983  -2.7907314\n\nForecasts:\n               y_f     sa_f      t_f         s_f        i_f\nJan 2021  94.29728 101.0937 102.3876  -6.7963909 -1.2939310\nFeb 2021  97.89298 101.6869 102.4525  -3.7939488 -0.7655396\nMar 2021 113.65190 102.1478 102.4593  11.5041248 -0.3115701\nApr 2021 102.34532 102.1806 102.3419   0.1647274 -0.1612727\nMay 2021  96.14552 101.6436 102.1712  -5.4980759 -0.5276194\nJun 2021 112.15785 101.2156 102.0241  10.9422549 -0.8085520\nJul 2021 104.38495 101.5439 101.9635   2.8410057 -0.4195241\nAug 2021  79.02901 102.3820 102.0412 -23.3530134  0.3408366\nSep 2021 109.40288 102.3705 102.1977   7.0323700  0.1728109\nOct 2021 108.22472 101.8558 102.3655   6.3689511 -0.5096780\nNov 2021 106.22014 102.4265 102.5266   3.7936049 -0.1000754\nDec 2021  99.67523 102.9462 102.6812  -3.2709156  0.2649189\n\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.830\n Seasonal     51.089\n Irregular     0.927\n TD & Hol.     2.179\n Others       44.916\n Total       100.941\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.014\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          0.924\n qs test on i                           0.643\n f-test on sa (seasonal dummies)        0.671\n f-test on i (seasonal dummies)         0.453\n Residual seasonality (entire series)   0.415\n Residual seasonality (last 3 years)    0.954\n f-test on sa (td)                      0.091\n f-test on i (td)                       0.333\n\n\nAdditional output variables\n\ny &lt;- mysa$final$series[,\"y\"]\n# De façon équivalente :\ny &lt;- get_ts(mysa)\nsa &lt;- mysa$final$series[,\"sa\"]\nplot(y)\nlines(sa, col = \"red\")\n\n\n\n\n\n\n\n# ou on peut directement utiliser les fonctions de RJDemetra :\nplot(mysa, first_date = 2000, #Pour n'afficher le graphique qu'à partir de 200\n     type_chart = \"sa-trend\" # Pour faire le graphique avec y, sa et tendance\n)\n\n\n\n\n\n\n\n\nPour des graphiques ggplot2, on peut également utiliser le package ggdemetra :\n\nlibrary(ggdemetra)\n# y &lt;- ggdemetra::raw(mysa)\n# sa &lt;- ggdemetra::seasonaladj(mysa)\np_sa &lt;- \n    ggplot(data = ggdemetra::ts2df(y), \n           mapping = aes(x = date, y = y)) +\n    geom_line(color = \"#F0B400\") +\n    labs(title = \"Y, Sa, Trend\",\n         x = NULL, y = NULL) +\n    geom_sa(component = \"y_f\", linetype = 2,\n            spec = x13_spec(mysa), frequency = 12,\n            color = \"#F0B400\") + \n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2)+ \n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    geom_sa(component = \"t_f\", color = \"#1E6C0B\", linetype = 2) + \n    theme_bw()\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nModifier le modèle précédent pour enlever l’effet graduel de Pâques.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspec_sans_easter &lt;- x13_spec(mysa,\n                             easter.enabled = FALSE)\nmysa2 &lt;- x13(ipi_c_eu[, \"FR\"], spec_sans_easter)\nmysa2$regarima\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: yes\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05032      0.118\nPhi(2)     0.09575      0.082\nTheta(1)  -0.55559      0.110\nBTheta(1) -0.73033      0.039\n\n              Estimate Std. Error\nWeek days     0.007179      0.000\nAO (5-2011)   0.124297      0.018\nLS (11-2008) -0.086926      0.017\nLS (1-2009)  -0.071005      0.017\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548 aicc =  1548, bic(corrected for length) = -7.561\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer les p-valeurs associées au modèle Reg-ARIMA de la précédente spécification.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer le modèle Reg-ARIMA et utiliser la fonction summary().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nreg_sum &lt;- summary(mysa2$regarima)\nreg_sum\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2019\nLog-transformation: yes\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(3)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error  T-stat Pr(&gt;|t|)    \nPhi(1)     0.05032    0.11801   0.426    0.670    \nPhi(2)     0.09575    0.08224   1.164    0.245    \nTheta(1)  -0.55559    0.10956  -5.071 6.45e-07 ***\nBTheta(1) -0.73033    0.03938 -18.545  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n               Estimate Std. Error T-stat Pr(&gt;|t|)    \nWeek days     0.0071788  0.0003171 22.637  &lt; 2e-16 ***\nAO (5-2011)   0.1242970  0.0180390  6.890 2.63e-11 ***\nLS (11-2008) -0.0869263  0.0171661 -5.064 6.69e-07 ***\nLS (1-2009)  -0.0710049  0.0171449 -4.141 4.34e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548, aicc =  1548, bic(corrected for length) = -7.561\n\n\nOn peut récupérer ces valeurs en exploitant l’objet reg_sum :\n\nreg_sum$coefficients\n\n$arima\n             Estimate Std. Error     T-stat     Pr(&gt;|t|)\nPhi(1)     0.05031546 0.11801332   0.426354 6.701142e-01\nPhi(2)     0.09575287 0.08224054   1.164303 2.451013e-01\nTheta(1)  -0.55559277 0.10955864  -5.071191 6.449100e-07\nBTheta(1) -0.73033107 0.03938071 -18.545401 0.000000e+00\n\n$regression\n                 Estimate   Std. Error    T-stat     Pr(&gt;|t|)\nWeek days     0.007178836 0.0003171301 22.636876 0.000000e+00\nAO (5-2011)   0.124296961 0.0180390210  6.890449 2.628564e-11\nLS (11-2008) -0.086926347 0.0171661398 -5.063826 6.685537e-07\nLS (1-2009)  -0.071004892 0.0171448840 -4.141462 4.338403e-05\n\n$fixed_out\nNULL\n\n$fixed_var\nNULL"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#créer-un-workspace",
    "href": "TP/R_1_R_et_JD.html#créer-un-workspace",
    "title": "1 - R et JDemetra+",
    "section": "1.2 Créer un workspace",
    "text": "1.2 Créer un workspace\nDans cette partie nous allons créer un workspace depuis R. Pour cela les fonctions qui peuvent être utilisées sont new_workspace(), load_workspace(), new_multiprocessing(), add_sa_item(), save_workspace(), compute(), get_object(), get_name(), get_ts() ou count().\n\n\n\n\n\n\nExercice\n\n\n\nCréer un workspace qui va contenir une série désaisonnalisée selon 3 spécifications différentes.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"MP-1\")\nadd_sa_item(jws, \"MP-1\", mysa, \"X13 avec Pâques\")\nadd_sa_item(jws, \"MP-1\", mysa2, \"X13 sans Pâques\")\nadd_sa_item(jws, \"MP-1\", tramoseats(ipi_c_eu[, \"FR\"]), \"TRAMO-SEATS\")\nsave_workspace(jws, \"mon_premier_workspace.xml\")\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nImporter le workspace précédent et récupérer :\n\nLe nom du premier multi-processing\nLe nombre de modèles dans ce premier multi-processing\nL’ensemble des séries brutes\nLe 2ème modèle\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- load_workspace(\"mon_premier_workspace.xml\")\ncompute(jws)\ncount(jws) # Nombre de multiprocessing\n\n[1] 1\n\njmp1 &lt;- get_object(jws, 1) # Le premier multiprocessing\nget_name(jmp1)\n\n[1] \"MP-1\"\n\ncount(jmp1)\n\n[1] 3\n\nall_y &lt;- get_ts(jmp1) # toutes les séries brutes\nmodel2 &lt;- get_object(jmp1, 2) # On récupère l'objet associé au 2ème modèle\nget_model(model2, jws)\n\nRegARIMA\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: yes\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05032      0.118\nPhi(2)     0.09575      0.082\nTheta(1)  -0.55559      0.110\nBTheta(1) -0.73033      0.039\n\n              Estimate Std. Error\nWeek days     0.007179      0.000\nAO (5-2011)   0.124297      0.018\nLS (11-2008) -0.086926      0.017\nLS (1-2009)  -0.071005      0.017\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548 aicc =  1548, bic(corrected for length) = -7.561\n\n\n\nDecomposition\nMonitoring and Quality Assessment Statistics:\n      M stats\nM(1)    0.080\nM(2)    0.044\nM(3)    0.925\nM(4)    0.324\nM(5)    1.018\nM(6)    0.172\nM(7)    0.075\nM(8)    0.207\nM(9)    0.069\nM(10)   0.229\nM(11)   0.207\nQ       0.311\nQ-M2    0.344\n\nFinal filters: \nSeasonal filter:  3x5\nTrend filter:  13 terms Henderson moving average\n\n\nFinal\nLast observed values\n             y       sa        t         s         i\nJan 2019 103.9 104.9497 104.8872 0.9899977 1.0005966\nFeb 2019 101.9 106.2130 105.1277 0.9593928 1.0103234\nMar 2019 111.0 104.7070 105.2207 1.0601007 0.9951182\nApr 2019 107.4 105.0688 105.1200 1.0221871 0.9995130\nMay 2019 105.5 108.7078 104.9337 0.9704918 1.0359658\nJun 2019 105.8 101.5038 104.6881 1.0423256 0.9695826\nJul 2019 110.1 105.4918 104.3766 1.0436828 1.0106850\nAug 2019  78.7 102.6361 104.0097 0.7667871 0.9867928\nSep 2019 108.5 104.0439 103.5870 1.0428287 1.0044106\nOct 2019 116.8 104.5857 103.1442 1.1167879 1.0139754\nNov 2019 103.8 101.7786 102.7722 1.0198610 0.9903319\nDec 2019  97.7 101.5883 102.5735 0.9617252 0.9903948\n\nForecasts:\n               y_f     sa_f      t_f       s_f       i_f\nJan 2020 101.86190 102.9804 102.5981 0.9891385 1.0037265\nFeb 2020 100.79119 103.1440 102.8002 0.9771887 1.0033443\nMar 2020 111.43956 102.5781 103.0224 1.0863878 0.9956869\nApr 2020 105.54428 103.3790 103.2028 1.0209447 1.0017079\nMay 2020  96.34392 104.3346 103.2155 0.9234131 1.0108422\nJun 2020 112.45079 102.5347 103.0496 1.0967099 0.9950029\nJul 2020 106.92345 102.3231 102.8558 1.0449593 0.9948203\nAug 2020  76.61765 102.5744 102.7208 0.7469472 0.9985747\nSep 2020 110.47115 103.3476 102.6644 1.0689277 1.0066554\nOct 2020 111.53872 102.2010 102.6987 1.0913668 0.9951530\nNov 2020 104.52886 102.5479 102.7719 1.0193176 0.9978206\nDec 2020 101.73775 103.4319 102.9459 0.9836210 1.0047204\n\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.984\n Seasonal     62.978\n Irregular     0.998\n TD & Hol.     2.273\n Others       33.676\n Total       101.909\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.429\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          1.000\n qs test on i                           0.965\n f-test on sa (seasonal dummies)        0.625\n f-test on i (seasonal dummies)         0.474\n Residual seasonality (entire series)   0.779\n Residual seasonality (last 3 years)    0.878\n f-test on sa (td)                      0.076\n f-test on i (td)                       0.385\n\n\nAdditional output variables"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#manipuler-les-objets-java",
    "href": "TP/R_1_R_et_JD.html#manipuler-les-objets-java",
    "title": "1 - R et JDemetra+",
    "section": "1.3 Manipuler les objets Java",
    "text": "1.3 Manipuler les objets Java\nL’objectif de cette partie est de manipuler la fonction jx13() pour gagner en temps de calcul.\n\n\n\n\n\n\nExercice\n\n\n\nCréer un modèle à partir de la fonction jx13() et la spécification sans effet graduel de pâques crée dans la section 1.1.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmyjsa &lt;- jx13(ipi_c_eu[, \"FR\"], spec_sans_easter)\nget_indicators(myjsa, \"sa\")\n\n$sa\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1990  93.27297  96.29529  94.47992  93.73334  93.94507  92.83948  94.28898\n1991  93.61809  93.12145  92.56800  92.23966  88.02740  94.55282  92.48219\n1992  91.62891  91.43164  92.38484  92.19526  91.08704  90.59578  89.51814\n1993  87.30634  87.99736  86.85921  86.97894  86.99296  87.29234  86.76534\n1994  88.69622  87.77278  88.37550  89.30617  91.27332  91.48108  90.65425\n1995  95.09916  94.52731  93.92731  93.90941  92.37904  92.04264  93.77960\n1996  93.06670  91.54362  94.26169  93.30918  91.32878  94.96354  94.26156\n1997  93.06742  95.67044  95.13059 101.85852  96.43204  98.44794  98.23010\n1998 102.13804 103.25275 102.01932 102.89690 103.62209 101.81934 103.60992\n1999 103.71964 102.64444 103.76759 104.04665 106.13300 106.82584 105.69365\n2000 110.38789 107.38428 109.60527 110.17270 114.61835 106.35539 110.67086\n2001 112.45025 113.34404 113.88119 110.73914 111.61677 111.49774 112.13527\n2002 110.26696 110.99285 111.13280 111.58735 107.54579 111.87216 110.92070\n2003 108.72641 109.77205 109.75157 109.85823 105.81090 105.36978 108.56247\n2004 109.12622 109.43552 109.52322 110.42603 111.47708 112.70525 111.38248\n2005 114.72877 111.07384 106.23729 114.40231 113.83685 111.14636 109.33782\n2006 112.84431 110.57123 111.88826 111.79247 114.34733 112.62975 111.48879\n2007 112.53191 114.29580 114.23700 113.06787 112.93424 115.43386 116.32302\n2008 114.06045 113.94480 111.07963 118.83142 111.92185 110.96502 111.54674\n2009  93.60983  93.32624  92.17978  92.82197  94.61843  94.29186  94.42552\n2010  95.51379  96.12075  98.46494  99.01596 102.81820 100.22951  99.30088\n2011 104.88512 104.72507 103.63569 102.25128 116.10802  97.55663 101.60353\n2012 102.83064  98.48657 101.60323  99.95552  99.30289 100.25687 101.48753\n2013  97.45647  98.45690  97.93752 100.35136  99.79029 100.14504 100.08302\n2014  97.89835 100.00657  98.78845  99.56271  98.29814  97.26484  98.38400\n2015  98.27255  99.53811  99.50288  99.07983  99.28072 101.49169  96.66780\n2016 101.32397  99.22467  96.95194 102.97678 105.03035 100.37169  96.68839\n2017 102.72859 101.41668 102.63069 100.60801 106.58076 101.54655 100.67684\n2018 103.19713 103.14126 103.70513 103.35321 102.04279 105.47625 105.16178\n2019 104.94974 106.21301 104.70704 105.06883 108.70777 101.50380 105.49182\n           Aug       Sep       Oct       Nov       Dec\n1990  92.81532  93.42471  93.21965  92.25071  90.06120\n1991  91.72254  92.21808  91.96428  92.02285  90.46195\n1992  91.95223  89.69252  89.81277  90.02832  88.33305\n1993  87.30196  87.03081  87.21300  84.45288  87.46656\n1994  91.37247  91.19741  91.98386  92.78677  95.17153\n1995  92.38821  93.99473  92.85706  93.36671  94.38969\n1996  93.75684  94.14529  93.72433  93.79062  93.43034\n1997 101.81145  99.64928 101.86478 100.90774 101.70138\n1998 103.62658 103.60456 103.09096 104.46065 102.99964\n1999 106.07083 107.12621 108.29389 107.17738 110.10121\n2000 111.01860 110.92744 111.42763 113.10692 114.51591\n2001 115.50617 111.31601 110.65583 110.20538 108.13496\n2002 112.75124 109.55689 109.18036 109.90888 106.38982\n2003 107.51695 108.10694 110.01758 109.50133 108.16481\n2004 110.31329 111.75188 112.44658 108.46909 111.73847\n2005 110.00423 112.59573 109.23754 111.65979 113.81029\n2006 112.62602 113.48750 112.76155 112.55067 113.59525\n2007 115.82841 112.91803 115.49734 113.69439 112.28630\n2008 109.36385 109.09852 108.03726 100.63716  99.86454\n2009  96.91866  97.94748  97.85917  97.60414  96.07651\n2010  99.54513 100.43464 100.75477  98.83302 102.97020\n2011 101.60617 101.45456 102.21445 102.59847 103.85017\n2012 101.83135  99.96547  98.23490  98.64730  97.23489\n2013  96.84385  97.95614  99.86479  98.42704  97.79728\n2014  96.12996  99.28707  98.34888  97.27581  99.01780\n2015 102.05354 101.35873 100.66252 100.76102 100.45864\n2016 101.62022 100.64268  98.76241 100.83623 102.82647\n2017 103.73341 103.82246 105.29816 106.59767 105.53516\n2018 105.03058 103.00706 104.49092 104.89205 103.66170\n2019 102.63605 104.04393 104.58566 101.77858 101.58827\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nToujours avec la même spécification, extraire les révisions de la séries désaisonnalisée du point de janvier 2005 (i.e. : série désaisonnalisée lorsqu’on a les données jusqu’en janvier 2005, puis jusqu’en février 2005, etc.).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer l’ensemble des dates de fin d’estimation avec la fonction window(time(ipi_c_eu[, \"FR\"]), start = 2005).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndates &lt;- as.numeric(window(time(ipi_c_eu[, \"FR\"]), start = 2005))\nestimations &lt;- sapply(dates, function(last_date_estimation){\n    myjsa &lt;- jx13(window(ipi_c_eu[, \"FR\"], end = last_date_estimation), spec_sans_easter)\n    sa &lt;- get_indicators(myjsa, \"sa\")$sa\n    window(sa, start = 2005, end = 2005) # Pour ne récupérer que la valeur en 2005\n})\nestimations &lt;- ts(estimations, start = 2005, frequency = 12)\nplot(estimations)"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#sec-spec-jd3",
    "href": "TP/R_1_R_et_JD.html#sec-spec-jd3",
    "title": "1 - R et JDemetra+",
    "section": "2.1 Créer une specification",
    "text": "2.1 Créer une specification\nLes modèles autour de la méthode X-13ARIMA peuvent être estimés avec rjd3x13::x13(), rjd3x13::regarima()) et rjd3x13::x11().\nLes spécifications peuvent être crées avec les fonctions rjd3x13::regarima_spec, rjd3x13::spec_x11() ou rjd3x13::x13_spec() et peuvent être modifiées par :\n\nPour le préajustement : rjd3toolkit::set_arima(), rjd3toolkit::set_automodel(), rjd3toolkit::set_basic(), rjd3toolkit::set_easter(), rjd3toolkit::set_estimate(), rjd3toolkit::set_outlier(), rjd3toolkit::set_tradingdays(), rjd3toolkit::set_transform(), rjd3toolkit::add_outlier(), rjd3toolkit::remove_outlier(), rjd3toolkit::add_ramp(), rjd3toolkit::remove_ramp(), rjd3toolkit::add_usrdefvar() ;\nPour la décomposition : rjd3x13::set_x11() ;\nPour le benchmarking : rjd3toolkit::set_benchmarking().\n\n\n\n\n\n\n\nExercice\n\n\n\nFaire la désaisonnalisation d’une série avec X-13 avec la spécification suivante :\n\ndétection automatique du schéma de décomposition, des outliers et du modèle ARIMA ;\nune correction des jours ouvrables “working days” et un effet graduel de Pâques.\n\nFaire ensuite un graphique avec la série brute et la série désaisonnalisée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nUtiliser la spécification RSA4c pour la désaisonnalisation.\nSi le modèle créé s’appelle sa_jd3, regarder les valeurs de sa_jd3$result$final et rjd3toolkit::sa_decomposition(sa_jd3).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsa_jd3 &lt;- rjd3x13::x13(ipi_c_eu[, \"FR\"], \"rsa4\")\nsa_jd3\n\nRegARIMA\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)     0.02269    0.10769   0.211\nphi(2)     0.15463    0.07367   2.099\ntheta(1)  -0.52470    0.09974  -5.261\nbtheta(1) -0.70977    0.04324 -16.415\n\nRegression model:\n                  Estimate Std. Error T-stat\ntd               0.0070856  0.0002973 23.830\neaster          -0.0218293  0.0041947 -5.204\nLS (2008-11-01) -0.0851379  0.0169175 -5.033\nLS (2009-01-01) -0.0720198  0.0168966 -4.262\nAO (2011-05-01)  0.1267563  0.0170943  7.415\nNumber of observations:  360 \nNumber of effective observations:  347 \nNumber of parameters:  10 \n\nLoglikelihood:  850.2857 \nAdjusted loglikelihood:  -752.4816 \n\nStandard error of the regression (ML estimate):  0.02060681 \nAIC:  1524.963 \nAICC:  1525.618 \nBIC:  1563.456 \n\n\nDecomposition\nMonitoring and Quality Assessment Statistics: \n    M stats\nm1    0.087\nm2    0.049\nm3    0.934\nm4    0.713\nm5    0.965\nm6    0.212\nm7    0.075\nm8    0.198\nm9    0.070\nm10   0.209\nm11   0.195\nq     0.340\nqm2   0.376\n\nFinal filters: \nSeasonal filter:  \nTrend filter: 13 terms Henderson moving average\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend (in %)\n\n           Component\n cycle         8.148\n seasonal     53.817\n irregular     0.338\n calendar      2.074\n others       30.402\n total        94.779\n\nResidual seasonality tests\n                P.value\n seas.ftest.i     0.122\n seas.ftest.sa    0.486\n seas.qstest.i    0.600\n seas.qstest.sa   0.788\n td.ftest.i       0.383\n td.ftest.sa      0.420\n\n\nFinal\nLast values\n         series       sa    trend      seas       irr\nJan 2019  103.9 104.9459 104.8892 0.9900340 1.0005406\nFeb 2019  101.9 106.1674 105.2359 0.9598051 1.0088514\nMar 2019  111.0 104.5521 105.4496 1.0616713 0.9914890\nApr 2019  107.4 105.9774 105.4357 1.0134233 1.0051380\nMay 2019  105.5 108.7623 105.2678 0.9700057 1.0331958\nJun 2019  105.8 101.1875 104.9615 1.0455836 0.9640439\nJul 2019  110.1 105.3177 104.5343 1.0454088 1.0074942\nAug 2019   78.7 102.5250 104.0408 0.7676178 0.9854307\nSep 2019  108.5 104.0024 103.5185 1.0432448 1.0046754\nOct 2019  116.8 104.5360 103.0474 1.1173179 1.0144465\nNov 2019  103.8 101.7273 102.7183 1.0203752 0.9903519\nDec 2019   97.7 101.6177 102.5972 0.9614465 0.9904527\n\ny &lt;- sa_jd3$result$preadjust$a1\nsa &lt;- sa_jd3$result$final$d11final\n# ou :\ndecomp &lt;- rjd3toolkit::sa_decomposition(sa_jd3)\ny &lt;- decomp$series\nsa &lt;- decomp$sa\n# ou on peut directement utiliser les fonctions de rjd3x13 :\nplot(sa_jd3, first_date = 2000 #Pour n'afficher le graphique qu'à partir de 200\n)\n\n\n\n\n\n\n\n\nPour des graphiques ggplot2, on peut également utiliser le package ggdemetra3.\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nModifier le modèle précédent pour enlever l’effet graduel de Pâques.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspec_sans_easter_v3 &lt;- \n    sa_jd3$estimation_spec |&gt; \n    rjd3toolkit::set_easter(enabled = FALSE)\nsa2_jd3 &lt;- rjd3x13::x13(ipi_c_eu[, \"FR\"], spec_sans_easter_v3)\nsa2_jd3$result$preprocessing\n\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)     0.05029    0.10689   0.470\nphi(2)     0.09574    0.07647   1.252\ntheta(1)  -0.55562    0.09576  -5.802\nbtheta(1) -0.73033    0.03972 -18.387\n\nRegression model:\n                  Estimate Std. Error T-stat\ntd               0.0071788  0.0003171 22.637\nLS (2008-11-01) -0.0869273  0.0171661 -5.064\nLS (2009-01-01) -0.0710048  0.0171448 -4.141\nAO (2011-05-01)  0.1242974  0.0180391  6.890\nNumber of observations:  360 \nNumber of effective observations:  347 \nNumber of parameters:  9 \n\nLoglikelihood:  838.005 \nAdjusted loglikelihood:  -764.7623 \n\nStandard error of the regression (ML estimate):  0.02132569 \nAIC:  1547.525 \nAICC:  1548.059 \nBIC:  1582.168 \n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer les p-valeurs associées au modèle Reg-ARIMA de la précédente spécification.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer le modèle Reg-ARIMA et utiliser la fonction summary().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsummary(sa2_jd3$result$preprocessing)\n\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat Pr(&gt;|t|)    \nphi(1)     0.05029    0.10689   0.470    0.638    \nphi(2)     0.09574    0.07647   1.252    0.211    \ntheta(1)  -0.55562    0.09576  -5.802  1.5e-08 ***\nbtheta(1) -0.73033    0.03972 -18.387  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                  Estimate Std. Error T-stat Pr(&gt;|t|)    \ntd               0.0071788  0.0003171 22.637  &lt; 2e-16 ***\nLS (2008-11-01) -0.0869273  0.0171661 -5.064 6.76e-07 ***\nLS (2009-01-01) -0.0710048  0.0171448 -4.141 4.36e-05 ***\nAO (2011-05-01)  0.1242974  0.0180391  6.890 2.72e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations:  360 , Number of effective observations:  347 , Number of parameters:  9 \nLoglikelihood:  838.005, Adjusted loglikelihood:  -764.7623\nStandard error of the regression (ML estimate):  0.02132569 \nAIC:  1547.525 , AICc:  1548.059 , BIC:  1582.168"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#créer-un-workspace-1",
    "href": "TP/R_1_R_et_JD.html#créer-un-workspace-1",
    "title": "1 - R et JDemetra+",
    "section": "2.2 Créer un workspace",
    "text": "2.2 Créer un workspace\nDans cette partie nous allons créer un workspace depuis R. Pour cela les fonctions qui peuvent être utilisées sont rjdemetra3::.jws_new(), rjdemetra3::read_workspace(), rjdemetra3::.jws_sap_new(), rjdemetra3::add_sa_item(), rjdemetra3::save_workspace().\n\n\n\n\n\n\nExercice\n\n\n\nCréer un workspace qui va contenir une série désaisonnalisée selon 3 spécifications différentes.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- rjdemetra3::.jws_new()\njsap &lt;- rjdemetra3::.jws_sap_new(jws, \"MP-1\")\nrjdemetra3::add_sa_item(jsap, \"X13 avec Pâques\", sa_jd3)\nrjdemetra3::add_sa_item(jsap, \"X13 sans Pâques\", sa2_jd3)\nrjdemetra3::add_sa_item(jsap, \"TRAMO-SEATS\", y, rjd3tramoseats::spec_tramoseats())\nrjdemetra3::save_workspace(jws, \"ws_v3.xml\")\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nImporter le workspace précédent et récupérer :\n\nLe nom du premier multi-processing\nLe nombre de modèles dans ce premier multi-processing\nL’ensemble des séries brutes\nLe 2ème modèle\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# charge tous les modèles du workspace :\njws &lt;- rjdemetra3::.jws_load(\"ws_v3.xml\")\nws &lt;- rjdemetra3::read_workspace(jws)\nnames(ws$processing)[1]\n\n[1] \"MP-1\"\n\nlength(ws$processing[[1]]) # Nombre de multiprocessing\n\n[1] 3\n\n\nAutre façon de faire similaire à RJDemetra :\n\n# charge tous les modèles du workspace :\njws &lt;- rjdemetra3::.jws_load(\"ws_v3.xml\")\nrjdemetra3::.jws_compute(jws)\nrjdemetra3::.jws_sap_count(jws) # Nombre de multiprocessing\n\n[1] 1\n\njsap1 &lt;- rjdemetra3::.jws_sap(jws, 1) # Le premier multiprocessing\nrjdemetra3::.jsap_name(jsap1)\n\n[1] \"MP-1\"\n\nrjdemetra3::.jsap_sa_count(jsap1)\n\n[1] 3\n\nmodel2 &lt;- rjdemetra3::.jsap_sa(jsap1, 2) # On récupère l'objet associé au 2ème modèle\nrjdemetra3::.jsa_read(model2)\n\n$ts\n$name\n[1] \"X13 sans Pâques\"\n\n$moniker\n$source\n[1] \"\"\n\n$id\n[1] \"f15592ce-2d48-4450-89ca-5a2f3a8f4644\"\n\nattr(,\"class\")\n[1] \"JD3_TSMONIKER\"\n\n$metadata\nNULL\n\n$data\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n1990  92.1  92.3 102.1  93.0  93.3 100.8  92.9  66.7  95.8 105.0  96.7  89.2\n1991  92.5  89.2  97.4  93.8  87.5 100.3  93.4  64.3  96.9 103.5  94.0  92.1\n1992  90.7  89.0  99.4  93.7  86.1 101.3  90.4  62.9  96.6  98.4  91.9  92.6\n1993  82.3  84.0  95.6  88.3  82.2  97.9  85.5  61.3  93.7  93.0  88.3  92.1\n1994  83.6  83.7  97.0  88.3  88.3 102.9  87.3  65.9  98.2  98.0  96.8  98.0\n1995  91.8  90.1 102.9  90.4  91.6 103.7  90.6  66.8  98.7 101.4  97.2  94.8\n1996  92.0  91.1  98.1  94.3  90.5 101.8  96.1  66.3  98.9 105.0  95.0  96.0\n1997  91.9  91.3  99.1 102.8  93.2 108.2 100.4  70.5 107.3 114.1  99.6 106.7\n1998  98.2  98.7 109.3 103.7  97.6 114.7 106.1  72.1 111.5 112.6 105.6 107.4\n1999  97.2  98.3 114.5 104.8  99.9 120.2 105.7  76.1 115.2 115.1 111.1 114.0\n2000 103.4 107.5 121.7 105.7 113.1 119.4 108.1  82.0 116.4 121.3 117.2 111.9\n2001 110.7 108.9 124.0 109.3 109.8 121.9 112.4  85.5 114.1 123.4 114.2 104.9\n2002 108.4 106.7 118.5 113.4 105.6 119.2 113.9  81.4 115.6 121.7 111.0 105.2\n2003 106.9 105.4 117.1 112.0 101.5 115.2 111.2  75.7 117.5 122.4 107.8 109.3\n2004 104.7 106.7 122.8 112.7 104.5 126.5 111.1  79.7 121.9 118.8 112.2 112.6\n2005 107.6 106.3 118.8 113.7 109.7 125.0 106.4  81.7 123.0 115.1 115.5 111.6\n2006 108.8 105.9 124.8 108.0 113.1 126.7 108.7  84.1 121.0 121.5 116.6 108.2\n2007 111.5 109.6 124.0 111.7 111.7 126.6 116.6  87.1 117.3 127.2 118.0 106.5\n2008 113.2 114.4 117.5 120.2 107.6 121.4 115.1  78.8 118.9 118.8  99.5  99.2\n2009  90.7  90.1 100.0  93.9  88.3 105.5  97.9  70.3 106.5 104.7  99.0  95.2\n2010  90.3  93.1 109.5 100.4  95.5 111.8 100.8  74.5 109.0 105.0 102.7 101.9\n2011  99.0 101.6 115.3 101.6 110.1 108.5 101.0  78.3 110.0 106.4 106.3 100.2\n2012  99.3  99.9 110.3  99.8  96.1 108.5 103.8  78.8 102.9 107.6 101.9  91.5\n2013  96.3  95.7 103.8 103.3  96.2 105.4 105.2  73.4 103.3 109.3  99.0  94.5\n2014  96.7  97.0 104.8 102.8  92.3 104.7 103.2  71.4 107.2 107.8  95.6  98.3\n2015  94.6  96.1 108.4 102.4  90.9 111.8 101.1  76.1 109.2 107.8 101.9  99.9\n2016  95.2  99.6 108.4 103.5  98.7 110.4  95.9  79.9 108.1 103.6 105.0  99.7\n2017  99.1  97.3 114.7  98.3 102.9 111.5  99.8  81.7 108.5 113.7 111.3  99.6\n2018 102.2  98.9 112.9 103.2  98.8 112.8 106.9  82.7 104.8 116.3 109.7  97.5\n2019 103.9 101.9 111.0 107.4 105.5 105.8 110.1  78.7 108.5 116.8 103.8  97.7\n\nattr(,\"class\")\n[1] \"JD3_TS\"\n\n$domainSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: AUTO\nAIC difference: -2\nAdjust: NONE\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: Yes\nAutoAdjust: TRUE\nTest: REMOVE\n\nEaster: No\n\nPre-specified outliers: 0\nRamps: No\n\nOutliers\nDetection span: All \nOutliers type: \n    - AO, critical value : 0 (Auto)\n    - LS, critical value : 0 (Auto)\n    - TC, critical value : 0 (Auto)\nTC rate: 0.7 (Auto)\nMethod: ADDONE (Auto)\n\nARIMA\nSARIMA model:  (0,1,1) (0,1,1)\n\nCoefficients\n          Estimate      Type\ntheta(1)         0 UNDEFINED\nbtheta(1)        0 UNDEFINED\n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$estimationSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: AUTO\nAIC difference: -2\nAdjust: NONE\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: Yes\nAutoAdjust: TRUE\nTest: REMOVE\n\nEaster: No\n\nPre-specified outliers: 0\nRamps: No\n\nOutliers\nDetection span: All \nOutliers type: \n    - AO, critical value : 0 (Auto)\n    - LS, critical value : 0 (Auto)\n    - TC, critical value : 0 (Auto)\nTC rate: 0.7 (Auto)\nMethod: ADDONE (Auto)\n\nARIMA\nSARIMA model:  (0,1,1) (0,1,1)\n\nCoefficients\n          Estimate      Type\ntheta(1)         0 UNDEFINED\nbtheta(1)        0 UNDEFINED\n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$pointSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: LOG\nAIC difference: -2\nAdjust: LEAPYEAR\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: No\nAutoAdjust: FALSE\nTest: NO\n\nEaster: No\n\nPre-specified outliers: 3\n    - LS (2008-11-01), coefficient: -0.0869273387886007 (ESTIMATED)\n    - LS (2009-01-01), coefficient: -0.0710047923357392 (ESTIMATED)\n    - AO (2011-05-01), coefficient: 0.124297351091159 (ESTIMATED)\nRamps: No\n\nOutliers\nIs enabled: No\n\nARIMA\nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n             Estimate      Type\nphi(1)     0.05029197 ESTIMATED\nphi(2)     0.09573828 ESTIMATED\ntheta(1)  -0.55562180 ESTIMATED\nbtheta(1) -0.73032859 ESTIMATED\n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$results\nRegARIMA\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)     0.05029    0.10689   0.470\nphi(2)     0.09574    0.07647   1.252\ntheta(1)  -0.55562    0.09576  -5.802\nbtheta(1) -0.73033    0.03972 -18.387\n\nRegression model:\n                  Estimate Std. Error T-stat\ntd               0.0071788  0.0003171 22.637\nLS (2008-11-01) -0.0869273  0.0171661 -5.064\nLS (2009-01-01) -0.0710048  0.0171448 -4.141\nAO (2011-05-01)  0.1242974  0.0180391  6.890\nNumber of observations:  360 \nNumber of effective observations:  347 \nNumber of parameters:  9 \n\nLoglikelihood:  838.005 \nAdjusted loglikelihood:  -764.7623 \n\nStandard error of the regression (ML estimate):  0.02132569 \nAIC:  1547.525 \nAICC:  1548.059 \nBIC:  1582.168 \n\n\nDecomposition\nMonitoring and Quality Assessment Statistics: \n    M stats\nm1    0.080\nm2    0.044\nm3    0.925\nm4    0.324\nm5    1.018\nm6    0.172\nm7    0.075\nm8    0.207\nm9    0.069\nm10   0.229\nm11   0.207\nq     0.311\nqm2   0.344\n\nFinal filters: \nSeasonal filter:  \nTrend filter: 13 terms Henderson moving average\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend (in %)\n\n           Component\n cycle         8.120\n seasonal     54.041\n irregular     0.305\n calendar      1.946\n others       30.441\n total        94.853\n\nResidual seasonality tests\n                P.value\n seas.ftest.i     0.175\n seas.ftest.sa    0.566\n seas.qstest.i    0.956\n seas.qstest.sa   1.000\n td.ftest.i       0.281\n td.ftest.sa      0.279\n\n\nFinal\nLast values\n         series       sa    trend      seas       irr\nJan 2019  103.9 104.9497 104.8872 0.9899977 1.0005966\nFeb 2019  101.9 106.2130 105.1277 0.9593928 1.0103234\nMar 2019  111.0 104.7070 105.2207 1.0601008 0.9951181\nApr 2019  107.4 105.0688 105.1200 1.0221872 0.9995130\nMay 2019  105.5 108.7078 104.9337 0.9704918 1.0359659\nJun 2019  105.8 101.5038 104.6881 1.0423255 0.9695828\nJul 2019  110.1 105.4918 104.3766 1.0436829 1.0106850\nAug 2019   78.7 102.6360 104.0097 0.7667871 0.9867928\nSep 2019  108.5 104.0439 103.5870 1.0428287 1.0044107\nOct 2019  116.8 104.5857 103.1442 1.1167879 1.0139754\nNov 2019  103.8 101.7786 102.7722 1.0198610 0.9903319\nDec 2019   97.7 101.5883 102.5735 0.9617251 0.9903948\n\n# Pour extraire toutes les séries brutes il faut faire une boucle :\nall_y &lt;- lapply(\n    lapply(\n        seq_len(rjdemetra3::.jsap_sa_count(jsap1)),\n        rjdemetra3::.jsap_sa, jsap = jsap1\n    ),\n    rjdemetra3::get_raw_data\n)"
  },
  {
    "objectID": "TP/R_1_R_et_JD.html#manipuler-les-objets-java-1",
    "href": "TP/R_1_R_et_JD.html#manipuler-les-objets-java-1",
    "title": "1 - R et JDemetra+",
    "section": "2.3 Manipuler les objets Java",
    "text": "2.3 Manipuler les objets Java\nLa manipulation des objets Java se fait de la même façon qu’avec RJDemetra : jx13() pour estimer les modèles, rjd3toolkit::dictionary() pour connaitre l’ensemble des objets exportables et rjd3toolkit::result() et rjd3toolkit::user_defined() pour exporter des objets.\n\n\n\n\n\n\nExercice\n\n\n\nCréer un modèle à partir de la fonction jx13() et la spécification sans effet graduel de pâques calculée dans la section 2.1.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmyjsa &lt;- rjd3x13::jx13(ipi_c_eu[, \"FR\"], spec_sans_easter_v3)\nrjd3toolkit::result(myjsa, \"sa\")\n\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1990  93.27297  96.29529  94.47992  93.73334  93.94507  92.83948  94.28898\n1991  93.61809  93.12145  92.56800  92.23966  88.02740  94.55282  92.48219\n1992  91.62891  91.43164  92.38484  92.19526  91.08704  90.59578  89.51814\n1993  87.30634  87.99736  86.85921  86.97894  86.99296  87.29234  86.76534\n1994  88.69622  87.77278  88.37550  89.30617  91.27332  91.48108  90.65425\n1995  95.09916  94.52731  93.92731  93.90941  92.37904  92.04264  93.77960\n1996  93.06670  91.54362  94.26169  93.30918  91.32878  94.96354  94.26156\n1997  93.06742  95.67044  95.13059 101.85852  96.43204  98.44794  98.23010\n1998 102.13804 103.25275 102.01932 102.89690 103.62209 101.81934 103.60992\n1999 103.71964 102.64444 103.76759 104.04665 106.13300 106.82584 105.69365\n2000 110.38789 107.38428 109.60527 110.17270 114.61835 106.35539 110.67086\n2001 112.45025 113.34404 113.88119 110.73914 111.61677 111.49774 112.13527\n2002 110.26696 110.99285 111.13280 111.58735 107.54579 111.87216 110.92070\n2003 108.72641 109.77205 109.75157 109.85823 105.81090 105.36978 108.56247\n2004 109.12622 109.43552 109.52322 110.42603 111.47708 112.70525 111.38248\n2005 114.72876 111.07384 106.23729 114.40231 113.83685 111.14636 109.33782\n2006 112.84430 110.57123 111.88827 111.79247 114.34733 112.62975 111.48879\n2007 112.53191 114.29580 114.23701 113.06787 112.93424 115.43386 116.32303\n2008 114.06045 113.94479 111.07964 118.83142 111.92185 110.96502 111.54674\n2009  93.60983  93.32624  92.17979  92.82197  94.61843  94.29186  94.42552\n2010  95.51378  96.12075  98.46495  99.01596 102.81821 100.22951  99.30088\n2011 104.88511 104.72507 103.63569 102.25128 116.10803  97.55663 101.60353\n2012 102.83064  98.48657 101.60323  99.95552  99.30289 100.25687 101.48753\n2013  97.45647  98.45690  97.93752 100.35136  99.79029 100.14504 100.08302\n2014  97.89835 100.00657  98.78845  99.56271  98.29814  97.26484  98.38400\n2015  98.27255  99.53811  99.50288  99.07983  99.28072 101.49169  96.66780\n2016 101.32397  99.22467  96.95194 102.97678 105.03035 100.37169  96.68839\n2017 102.72859 101.41668 102.63068 100.60800 106.58076 101.54656 100.67684\n2018 103.19713 103.14126 103.70512 103.35321 102.04279 105.47626 105.16178\n2019 104.94974 106.21301 104.70703 105.06882 108.70777 101.50380 105.49182\n           Aug       Sep       Oct       Nov       Dec\n1990  92.81532  93.42471  93.21965  92.25071  90.06120\n1991  91.72254  92.21808  91.96428  92.02285  90.46195\n1992  91.95223  89.69252  89.81277  90.02832  88.33305\n1993  87.30196  87.03081  87.21300  84.45288  87.46656\n1994  91.37247  91.19741  91.98386  92.78677  95.17153\n1995  92.38821  93.99473  92.85706  93.36671  94.38969\n1996  93.75684  94.14529  93.72433  93.79062  93.43034\n1997 101.81145  99.64928 101.86478 100.90774 101.70138\n1998 103.62658 103.60456 103.09096 104.46065 102.99964\n1999 106.07083 107.12621 108.29389 107.17738 110.10121\n2000 111.01860 110.92744 111.42763 113.10692 114.51591\n2001 115.50617 111.31601 110.65583 110.20538 108.13496\n2002 112.75124 109.55689 109.18036 109.90888 106.38982\n2003 107.51695 108.10694 110.01758 109.50133 108.16481\n2004 110.31329 111.75189 112.44658 108.46909 111.73847\n2005 110.00423 112.59573 109.23755 111.65978 113.81028\n2006 112.62602 113.48751 112.76156 112.55066 113.59524\n2007 115.82842 112.91804 115.49735 113.69438 112.28629\n2008 109.36385 109.09853 108.03727 100.63715  99.86453\n2009  96.91866  97.94749  97.85918  97.60413  96.07650\n2010  99.54513 100.43465 100.75478  98.83301 102.97020\n2011 101.60617 101.45457 102.21445 102.59847 103.85016\n2012 101.83135  99.96547  98.23490  98.64730  97.23489\n2013  96.84385  97.95614  99.86479  98.42704  97.79728\n2014  96.12996  99.28707  98.34888  97.27581  99.01780\n2015 102.05354 101.35873 100.66252 100.76102 100.45864\n2016 101.62022 100.64268  98.76241 100.83623 102.82647\n2017 103.73341 103.82246 105.29816 106.59767 105.53517\n2018 105.03057 103.00707 104.49092 104.89205 103.66171\n2019 102.63605 104.04393 104.58566 101.77858 101.58828\n\n\n\n\n\nPour les révisions, la fonction rjd3x13::x13_revisions() facilite grandement la tâche. L’historique des révisions peut s’exporter à partir de trois paramètres :\n\ndata_ids qui permet d’exporter des statistiques ;\nts_ids qui permet d’exporter des estimations d’une composante à une certaine date ;\ncmp_ids qui permet l’ensemble des estimations d’une composante à une ensemble de dates.\n\n\ndata_ids &lt;- list(\n    # Export du coefficient du premier régresseur jours ouvrables\n    list(start = \"2005-01-01\", id = \"regression.td(1)\"))\nts_ids &lt;- list(\n    # Export de l'historique des estimations de la séries SA de janv 2010 à partir de janvier 2010\n    list(period = \"2010-01-01\", start = \"2010-01-01\", id = \"sa\"))\ncmp_ids &lt;- list(\n    # Export de l'ensemble des tendances estimées entre janv 2010 et dec 2014\n    list(start = \"2010-01-01\", end = \"2014-12-01\", id = \"t\"))\nrh &lt;- rjd3x13::x13_revisions(\n    sa2_jd3$result$preadjust$a1,\n    spec = sa2_jd3$result_spec, \n    data_ids, ts_ids, cmp_ids)\nplot(rh$data$`regression.td(1)`,\n     ylab = \"Coef\", main = \"Coef td\")\n\n\n\n\n\n\n\nplot(rh$series$sa,\n     ylab = NULL, main = \"SA de janv 2010\")\n\n\n\n\n\n\n\nncol(rh$components$t) # nombre de séries exportées\n\n[1] 60"
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html",
    "href": "TP/JD_7_Etude_de_cas.html",
    "title": "7 - Étude de cas",
    "section": "",
    "text": "L’objectif de ce TP est de faire une étude de cas spécifique pour voir des problèmes possibles et une proposition de solution.\nDisclaimer : il peut exister plusieurs solutions, celles données dans ce TP ne sont que des propositions qui peuvent être discuté.\nPour télécharger le workspace, cliquer ici et dézipper le fichier. Pour importer les séries depuis R, vous pouvez par exemple utiliser le code suivant :\nlibrary(RJDemetra)\ndir &lt;- tempdir()\ndownload.file(\"https://aqlt.github.io/formation.2023.cvsdata/Etude_de_cas.zip\",\n              file.path(dir, \"Etude_de_cas.zip\"))\nunzip(file.path(dir, \"Etude_de_cas.zip\"),\n      exdir = dir)\nu_def_var &lt;- c(\"diagnostics.td-sa-last\", \"diagnostics.td-i-last\",\n               \"diagnostics.fcast-insample-mean\", \"diagnostics.fcast-outsample-mean\",\n               \"diagnostics.fcast-outsample-variance\")\njws &lt;- load_workspace(file.path(dir, \"Etude_de_cas.xml\"))\ncompute(jws)\nall_models &lt;- get_model(jws,\n            userdefined = u_def_var)[[1]]\nall_models$RF2932"
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2932",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2932",
    "title": "7 - Étude de cas",
    "section": "1.1 Série RF2932",
    "text": "1.1 Série RF2932\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un problème d’hétéroscédasticité (au seuil de 1 %) et un léger problème de non-normalité (au seuil de 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous du schéma de décomposition ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDécision : forcer le schéma en multiplicatif.\n\n\n\n\n\n\n\n\n\nSolution avec RJDemetra\n\n\n\n\n\n\nRF2932_init &lt;- x13(get_ts(all_models$RF2932),\n                   x13_spec(all_models$RF2932),\n                   userdefined = c(\"diagnostics.levelstat\",\n                                   \"diagnostics.logstat\"))\n# avec modèle airline, le modèle additif est meilleur en terme d'aicc\nc(RF2932_init$user_defined) \n\n$diagnostics.levelstat\n[1] 1106.606\n\n$diagnostics.logstat\n[1] 1122.762\n\nRF2932_init$regarima$residuals.stat\n\n$st.error\n[1] 6.372732\n\n$tests\n\nNormality\n         Statistic P.value    \nmean     -0.311958  0.7555 ***\nskewness -0.002427  0.9898 ***\nkurtosis  3.690535  0.0702  **\n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                              25.022652  0.2960 ***\nljung box (residuals at seasonal lags)  0.004277  0.9979 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value  \nljung box (squared residuals) 43.621083  0.0040  \n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nsummary(RF2932_init$regarima)\n\ny = regression model + arima (1, 1, 0, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(1)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nPhi(1)     0.30362    0.07510  4.043 8.08e-05 ***\nBTheta(1) -0.41738    0.06849 -6.094 7.51e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                  Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG1_semaine_mens   1.1666     0.1017 11.471  &lt; 2e-16 ***\nLS (11-2008)      -22.7610     5.2300 -4.352 2.36e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 6.373 on 160 degrees of freedom\nLog likelihood = -540.9, aic =  1092, aicc =  1092, bic(corrected for length) = 3.828\n\nplot(get_ts(RF2932_init)) # schéma parait plutôt multiplicatif\n\n\n\n\n\n\n\nRF2932 &lt;- x13(get_ts(RF2932_init),\n              x13_spec(RF2932_init,\n                       transform.function = \"Log\"))\n# critères d'information plus petits avec le modèle ARIMA final\nsummary(RF2932$regarima) \n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: yes\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(2)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.22136    0.07840 -2.823  0.00534 ** \nBTheta(1) -0.50008    0.06941 -7.204 1.97e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                    Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG1_semaine_mens  0.0112093  0.0008184 13.696  &lt; 2e-16 ***\nAO (12-2008)      -0.3056862  0.0359622 -8.500 1.07e-14 ***\nLS (11-2008)      -0.2290773  0.0448183 -5.111 8.78e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 0.05127 on 159 degrees of freedom\nLog likelihood = 254.3, aic =  1040, aicc =  1040, bic(corrected for length) = -5.786\n\nRF2932$regarima$residuals.stat\n\n$st.error\n[1] 0.05127311\n\n$tests\n\nNormality\n         Statistic P.value    \nmean     -0.259126  0.7959 ***\nskewness  0.224194  0.2397 ***\nkurtosis  2.988710  0.9764 ***\n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                              25.316156  0.2822 ***\nljung box (residuals at seasonal lags)  0.004006  0.9980 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value    \nljung box (squared residuals) 24.967584  0.2986 ***\n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **"
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2813",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2813",
    "title": "7 - Étude de cas",
    "section": "1.2 Série RF2813",
    "text": "1.2 Série RF2813\nL’analyse de cette série nécessite d’avoir vu les statistiques M qui jugent la qualité de la décomposition.\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un problème d’autocorrélation des résidus (au seuil de 1 %) et une mauvaise décomposition (Q-M2).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous du schéma de décomposition ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLe problème d’autocorrélation peut être atténué en forçant le schéma additif (p-valeur du test est alors égale à 0,04).\nLa mauvaise décomposition vient du fait que la tendance est plate et donc que la composante irrégulière est plus variable que la composante tendance-cycle.\nDécision : forcer le schéma en additif."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2223",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2223",
    "title": "7 - Étude de cas",
    "section": "1.3 Série RF2223",
    "text": "1.3 Série RF2223\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un effet JO résiduel (au seuil de 5 % mais pas 1 %) et un problème d’hétéroscédasticité (au seuil de 5 % mais pas 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRéduire le seuil de détection des outliers pour voir ce qu’il se passe.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDécision : Ajouter deux AO en 8-2007 et 7-2009.\nIl est préférable de rajouter les outliers à la main plutôt que de modifier de manière permanente le seuil de détection des outliers : cela évitera, pour les futures révisions du modèle,de détecter trop d’outliers.\n\n\n\n\n\n\n\n\n\nSolution avec RJDemetra\n\n\n\n\n\n\nRF2223_init &lt;- all_models$RF2223\nRF2223_init$regarima$residuals.stat\n\n$st.error\n[1] 4.853537\n\n$tests\n\nNormality\n         Statistic P.value    \nmean       0.06654  0.9470 ***\nskewness   0.11693  0.5398 ***\nkurtosis   3.26842  0.4816 ***\n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                               21.12931  0.5128 ***\nljung box (residuals at seasonal lags)   3.14839  0.2072 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value  \nljung box (squared residuals)  36.36390  0.0277  \n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nsummary(RF2223_init$regarima)\n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, no outliers\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.54574    0.06600 -8.269 4.26e-14 ***\nBTheta(1) -0.61218    0.06191 -9.888  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                  Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG1_semaine_mens    1.359      0.092  14.77   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 4.854 on 161 degrees of freedom\nLog likelihood = -497.8, aic =  1004, aicc =  1004, bic(corrected for length) = 3.252\n\n# Pas d'effet JO résiduel sur l'ensemble de la série\nRF2223_init$diagnostics\n\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         4.253\n Seasonal     92.479\n Irregular     1.443\n TD & Hol.     3.110\n Others        0.000\n Total       101.284\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                       0.00\n   Test for the presence of seasonality assuming stability    0.00\n   Evolutive seasonality test                                 0.65\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          1.000\n qs test on i                           1.000\n f-test on sa (seasonal dummies)        0.999\n f-test on i (seasonal dummies)         0.995\n Residual seasonality (entire series)   0.998\n Residual seasonality (last 3 years)    0.978\n f-test on sa (td)                      0.477\n f-test on i (td)                       0.233\n\n# Mais effet JO résiduel si test sur 8 dernières années\nc(RF2223_init$user_defined)\n\n$`diagnostics.td-sa-last`\n[1] 2.06202460 0.06576482\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.td-i-last`\n[1] 1.4421150 0.2077379\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.fcast-insample-mean`\n[1] 0.0958935 0.9237367\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.07084533  0.94361780\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 0.3810361 0.9895846\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 147 degrees of freedom in the denominator\"\n\nRF2223 &lt;- x13(get_ts(RF2223_init),\n              x13_spec(RF2223_init,\n                       outlier.usedefcv = FALSE,\n                       outlier.cv = 2.8),\n              userdefined = u_def_var)\nsummary(RF2223$regarima)\n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(1)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.52173    0.06742 -7.738 9.53e-13 ***\nBTheta(1) -0.58205    0.06388 -9.111 2.22e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                   Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG1_semaine_mens   1.38382    0.08785  15.75  &lt; 2e-16 ***\nAO (7-2009)       -12.94932    3.69997  -3.50 0.000599 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 4.694 on 160 degrees of freedom\nLog likelihood = -491.9, aic = 993.8, aicc = 994.2, bic(corrected for length) = 3.216\n\n# Plus d'effet résiduel\nc(RF2223$user_defined)\n\n$`diagnostics.td-sa-last`\n[1] 1.93300014 0.08420131\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.td-i-last`\n[1] 1.3621417 0.2388152\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.fcast-insample-mean`\n[1] 0.1255096 0.9002928\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.1398287  0.8889880\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 0.4224636 0.9813103\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 147 degrees of freedom in the denominator\"\n\n# Pour rajouter les outliers à la main\nRF2223 &lt;- x13(get_ts(RF2223_init),\n              x13_spec(RF2223_init,\n                       usrdef.outliersEnabled = TRUE,\n                       usrdef.outliersType = c(\"AO\", \"AO\"),\n                       usrdef.outliersDate = c(\"2008-04-01\", \"2009-07-01\")),\n              userdefined = u_def_var)\nsummary(RF2223$regarima)\n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(2)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.52758    0.06732 -7.837 5.38e-13 ***\nBTheta(1) -0.58811    0.06338 -9.280  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                   Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG1_semaine_mens   1.34012    0.08781 15.262  &lt; 2e-16 ***\nAO (4-2008)        10.27747    3.68830  2.787 0.005953 ** \nAO (7-2009)       -12.90807    3.63731 -3.549 0.000504 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 4.582 on 159 degrees of freedom\nLog likelihood =  -488, aic =   988, aicc = 988.5, bic(corrected for length) = 3.199"
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2453-tc-or-not-tc",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2453-tc-or-not-tc",
    "title": "7 - Étude de cas",
    "section": "1.4 Série RF2453 : TC or not TC",
    "text": "1.4 Série RF2453 : TC or not TC\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un effet JO résiduel (au seuil de 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous des outliers détectés ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSupprimer la détection des TC permet de corriger le problème sur l’irrégulier mais pas sur la série désaisonnalisée.\nDécision : désactiver la détection automatique de TC.\n\n\n\n\n\n\n\n\n\nSolution avec RJDemetra\n\n\n\n\n\n\nRF2453_init &lt;- all_models$RF2453\nRF2453_init$regarima$residuals.stat\n\n$st.error\n[1] 6.652116\n\n$tests\n\nNormality\n         Statistic P.value    \nmean       -0.1568  0.8756 ***\nskewness    0.4822  0.0115    \nkurtosis    3.8748  0.0218    \n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                                20.3325  0.5623 ***\nljung box (residuals at seasonal lags)    0.2154  0.8979 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value    \nljung box (squared residuals)   23.2289  0.3889 ***\n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\n# Pas d'effet JO résiduel sur l'ensemble de la série\nRF2453_init$diagnostics\n\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         4.325\n Seasonal     68.672\n Irregular     1.752\n TD & Hol.     2.078\n Others       25.645\n Total       102.472\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.102\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          1.000\n qs test on i                           1.000\n f-test on sa (seasonal dummies)        0.933\n f-test on i (seasonal dummies)         0.824\n Residual seasonality (entire series)   0.954\n Residual seasonality (last 3 years)    0.310\n f-test on sa (td)                      0.366\n f-test on i (td)                       0.239\n\n# Mais effet JO résiduel si test sur 8 dernières années\nc(RF2453_init$user_defined)\n\n$`diagnostics.td-sa-last`\n[1] 3.479738255 0.003917893\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.td-i-last`\n[1] 1.97643296 0.07750703\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.fcast-insample-mean`\n[1] -0.1242795  0.9012649\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.07988605  0.93643728\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 0.7422420 0.7628641\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 147 degrees of freedom in the denominator\"\n\n# Beaucoup de TC qui se suivent\nsummary(RF2453_init$regarima)\n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(5), no leap year effect, no Easter effect, outliers(3)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.50833    0.06987 -7.276 1.32e-11 ***\nBTheta(1) -0.53609    0.07121 -7.528 3.18e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                     Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG5_lundi_mens      0.005607   0.664701  0.008  0.99328    \nREG5_mardi_mens      2.242561   0.762597  2.941  0.00375 ** \nREG5_mercredi_mens   1.337224   0.759377  1.761  0.08010 .  \nREG5_jeudi_mens      2.090633   0.769670  2.716  0.00731 ** \nREG5_vendredi_mens   0.162574   0.684711  0.237  0.81261    \nTC (12-2008)       -28.316280   5.687836 -4.978 1.60e-06 ***\nTC (2-2009)        -24.963684   5.498501 -4.540 1.08e-05 ***\nLS (10-2008)       -25.123962   5.431160 -4.626 7.50e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 6.652 on 154 degrees of freedom\nLog likelihood =  -549, aic =  1120, aicc =  1122, bic(corrected for length) = 4.099\n\n# Pour rajouter les outliers à la main\nRF2453 &lt;- x13(get_ts(RF2453_init),\n              x13_spec(RF2453_init,\n                       outlier.tc = FALSE),\n              userdefined = u_def_var)\nsummary(RF2453$regarima)\n\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-2004 to 10-2018\nLog-transformation: no\nRegression model: no mean, trading days effect(5), no leap year effect, no Easter effect, outliers(3)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nTheta(1)  -0.46817    0.07185 -6.516 8.38e-10 ***\nBTheta(1) -0.52239    0.07174 -7.281 1.28e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                     Estimate Std. Error T-stat Pr(&gt;|t|)    \nREG5_lundi_mens    -8.241e-04  6.617e-01 -0.001  0.99901    \nREG5_mardi_mens     1.806e+00  7.637e-01  2.365  0.01921 *  \nREG5_mercredi_mens  1.639e+00  7.589e-01  2.159  0.03228 *  \nREG5_jeudi_mens     2.044e+00  7.649e-01  2.672  0.00829 ** \nREG5_vendredi_mens  4.014e-01  6.794e-01  0.591  0.55543    \nLS (10-2008)       -2.576e+01  5.627e+00 -4.578 9.21e-06 ***\nLS (8-2009)         2.401e+01  5.419e+00  4.431 1.70e-05 ***\nLS (12-2008)       -2.310e+01  5.603e+00 -4.123 5.91e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 6.765 on 154 degrees of freedom\nLog likelihood = -551.6, aic =  1125, aicc =  1127, bic(corrected for length) = 4.133\n\nc(RF2453$user_defined)\n\n$`diagnostics.td-sa-last`\n[1] 3.203562252 0.006831075\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.td-i-last`\n[1] 1.8162238 0.1050023\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n\n$`diagnostics.fcast-insample-mean`\n[1] -0.1302518  0.8965465\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.06839528  0.94556456\nattr(,\"description\")\n[1] \"T with 146 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 0.6828541 0.8239484\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 147 degrees of freedom in the denominator\""
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf1101",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf1101",
    "title": "7 - Étude de cas",
    "section": "2.1 Série RF1101",
    "text": "2.1 Série RF1101\n\n\n\n\n\n\nExercice\n\n\n\nAnalyser les S-I ratios et le graphique yearly components de la série brute : que remarquez vous ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPour cette série, le modèle est estimé depuis 2004 mais les CVS-CJO ne sont mises à jour qu’à partir de 2012.\nIl y a une nette rupture de saisonnalité en 2008 qui n’affecte pas la période après 2012 (filtre M3X5 utilisé, soit pour l’estimation des coefficients saisonniers de l’année A utilise les moyennes de l’année A-3 à A+3). Ainsi, commencer l’estimation du modèle à partir de 2008 permet d’avoir un modèle de pré-ajustement mieux estimé sur le présent et la rupture de saisonnalité n’affectera pas les coefficients publiés.\nUne autre solution est de rajouter un seasonal outlier en août 2008."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2561",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2561",
    "title": "7 - Étude de cas",
    "section": "3.1 Série RF2561",
    "text": "3.1 Série RF2561\n\n\n\n\n\n\nExercice\n\n\n\nIl y a de la saisonnalité résiduelle et une mauvaise qualité des résidus du modèle RegARIMA.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nAnalyser la série sur la fin de la période pour voir d’où vient la saisonnalité résiduelle. Comment pourrait-on la corriger ? Est-ce qu’il s’agit d’une rupture brute ou progressive ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nUne rupture de saisonnalité s’observe en juin 2011 : avant cette date juin était un point haut alors qu’à partir de 2011 il est au même niveau que les mois de mai et juillet. Ajout un SO à cette date corrige la rupture mais laisse une saisonnalité résiduelle qui vient du mois de décembre : on observe sur la série désaisonnalisée des pics systématiques en décembre sur les dernières années. Cette fois-ci ce n’est pas une rupture brute de la saisonnalité : le point de décembre qui était également un point haut avant 2011 devient progressivement de plus en plus bas. Le MSR de décembre (à 0,77) est d’ailleurs bien plus bas que celui des autres mois (qui sont autour de 2) ce qui suggère de prendre un filtre saisonnier plus court en décembre (le filtre actuellement choisi est M3X3). La mauvaise qualité des résidus est difficilement corrigeable, il faudrait prendre une période d’estimation beaucoup plus courtes qui ajouterait donc une instabilité des estimations.\nDécision : rajouter un SO en juin 2011 et utiliser le filtre M3X1 pour le mois de décembre. Pas d’intervention pour corriger la qualité des résidus."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf3299",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf3299",
    "title": "7 - Étude de cas",
    "section": "3.2 Série RF3299",
    "text": "3.2 Série RF3299\n\n\n\n\n\n\nExercice\n\n\n\nIl y a de la saisonnalité résiduelle.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nAnalyser correctement le problème de saisonnalité résiduelle.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAjouter des SO en 10-2012 et 12-2015."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#séries-c4672",
    "href": "TP/JD_7_Etude_de_cas.html#séries-c4672",
    "title": "7 - Étude de cas",
    "section": "3.3 Séries C4672",
    "text": "3.3 Séries C4672\n\n\n\n\n\n\nExercice\n\n\n\nDans cet exercice il y a deux séries à étudier : la série C4672 depuis 1999 et la même série mais estimée à partir de 2005.\n\nCommencez par la série qui commence en 1999. Comment vous parait le modèle ?\nAnalyser le modèle de la série qui commence en 2005 et comparer les résultats.\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nSaisonnalité résiduelle non détectée pour modèle ensemble mais détectée si modèle coupé à partir de 2005.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAjouter un SO 11-2008."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-c4773",
    "href": "TP/JD_7_Etude_de_cas.html#série-c4773",
    "title": "7 - Étude de cas",
    "section": "3.4 Série C4773",
    "text": "3.4 Série C4773\n\n\n\n\n\n\nExercice\n\n\n\nSaisonnalité résiduelle détectée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nÉtudier les S-I ratio : la saisonnalité est-elle stable ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOn observe une saisonnalité plutôt stable sauf en juillet et août (étude des S-I ratio). Les S-I ratio montrent aussi en juillet et août un comportement « atypique » de l’irrégulier en début de période. On n’observe pas de changement brusque de saisonnalité. L’étude des MSR par mois suggère de prendre un filtre plus court en juillet et en août : cela permet de corriger la saisonnalité résiduelle."
  },
  {
    "objectID": "TP/JD_5_Preajustment.html",
    "href": "TP/JD_5_Preajustment.html",
    "title": "5 - Pré-ajustement",
    "section": "",
    "text": "L’objectif de ce TP est d’analyser la qualité du pre-ajustement et de modifier, si nécessaire, la spécification"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#transformation",
    "href": "TP/JD_5_Preajustment.html#transformation",
    "title": "5 - Pré-ajustement",
    "section": "2.1 Transformation",
    "text": "2.1 Transformation\n\nEssayez de changer le schéma de décomposition (onglet TRANSFORMATION &gt; function)\n\nQu’est-ce que vous remarquez ? Est-ce qu’il y a eu des changements dans la partie le pré-ajustement ?\nEst-ce que les critères AICc et BIC ont été modifiés ?"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#régresseurs-calendaires",
    "href": "TP/JD_5_Preajustment.html#régresseurs-calendaires",
    "title": "5 - Pré-ajustement",
    "section": "2.2 Régresseurs calendaires",
    "text": "2.2 Régresseurs calendaires\n\nEssayez de changer le jeu de régresseurs jours ouvrables :\nQue pouvez-vous noter sur les tests de Student, Fischer, coefficients, AICc et BIC ?\nEst-ce qu’il y a des effets calendaires résiduels ?\nQuelle est la qualité du modèle Reg-ARIMA ?"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#outliers",
    "href": "TP/JD_5_Preajustment.html#outliers",
    "title": "5 - Pré-ajustement",
    "section": "2.3 Outliers",
    "text": "2.3 Outliers\n\nDans la partie REGRESSION &gt; Pre-specified outliers\n\nAjouter des outliers qui vous semblent pertinents et qui ne sont pas détectés par JDemetra+ (si vous avez connaissance d’un évènement particulier)\n\nEssayer de changer le seuil critique de détection des outliers (Critical value)\nQue remarquez vous sur le nombre d’outliers, l’AICc et le BIC ?\nEn quoi cela affecte la qualité de l’ajustement et des résidus du modèle ?\nEssayer de changer le type d’outliers détectés."
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#forecasts-results",
    "href": "TP/JD_5_Preajustment.html#forecasts-results",
    "title": "5 - Pré-ajustement",
    "section": "2.4 Forecasts results",
    "text": "2.4 Forecasts results\n\nAller dans la partie Pre-processing &gt; Forecasts &gt; Out-of-sample test\nQue comprenez-vous ?\nEn quoi c’est utile ?"
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html",
    "href": "TP/JD_3_CVS_sans_CJO.html",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à faire une désaisonnalisation sans correction des jours ouvrables (CJO)."
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#schéma-de-décomposition",
    "href": "TP/JD_3_CVS_sans_CJO.html#schéma-de-décomposition",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.1 9.1. Schéma de décomposition",
    "text": "2.1 9.1. Schéma de décomposition\n\nDans la fenêtre Main results\n\nQuel est le schéma de décomposition choisi par JDemetra+ ? Est-ce que vous êtes d’accord ?"
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#outliers",
    "href": "TP/JD_3_CVS_sans_CJO.html#outliers",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.2 Outliers",
    "text": "2.2 Outliers\n\nDans la fenêtre Main results\n\nCombien d’outliers ont été détectés par JDemetra+ ?\n\nY en a-t-il trop ?\n\n\nDans la fenêtre Pre-processing\n\nQuels sont les différents types d’outliers détéctés par JDemetra+ ?\n\nRetourner dans la fenêtre Main results\n\nAller dans Main results &gt; Charts\n\nRegarder les différents graphiques : pouvez-vous repérer, sur la série brute, les points atypiques détéctés dans le modèle ?"
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#s-i-ratio",
    "href": "TP/JD_3_CVS_sans_CJO.html#s-i-ratio",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.3 S-I Ratio",
    "text": "2.3 S-I Ratio\n\nAller dans la fenêtre Main results &gt; S-I ratio\nPouvez-vous repérer le schéma de décomposition ?\nQuel est l’objectif de ce graphique ?\nLes coefficients saisonniers sont-ils stables ?"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html",
    "href": "TP/JD_1_Premiere_manipulation_JD.html",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "",
    "text": "L’objectif de ce TP est de faire une première manipulation de JDemetra+ : créer un workspace, importer des données, lancer une première désaisonnalisation."
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#importation-dun-fichier-excel-sous-jdemetra",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#importation-dun-fichier-excel-sous-jdemetra",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "2.1 Importation d’un fichier Excel sous JDemetra+",
    "text": "2.1 Importation d’un fichier Excel sous JDemetra+\nOn se place ici dans le cas où les données brutes figurent dans un fichier Excel qui respecte les règles suivantes :\n\nla première colonne correspond à la date au format JJ/MM/AAAA\nla première ligne contient le nom des séries\n\n\n\n\n\n\n\nPour information\n\n\n\nPour créer un tel fichier Excel depuis R, voir le TP 0 - Traitement des séries temporelles sous R.\n\n\n\nRetourner sous JDemetra+\nCliquer sur l’onglet Providers\nClic-droit sur Spreadsheets\nCliquer sur Open\nCliquer sur le bouton …\nSélectionner un fichier Excel contenant les séries à désaisonnaliser\nCliquer sur OK\n\nQue voit-on sous Spreadsheets ?"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#mettre-un-fichier-en-favori",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#mettre-un-fichier-en-favori",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "2.2 Mettre un fichier en « favori »",
    "text": "2.2 Mettre un fichier en « favori »\n\nSauvegarder le workspace puis l’ouvrir de nouveau\nCliquer sur l’onglet Providers\nQue voit-on ?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes données ont disparues !\n\n\n\n\nImporter de nouveau votre fichier Excel\nClic-droit sur le nom du fichier Excel qui est apparu sous Spreadsheets\nCliquer sur Add star\nQue se passe-t-il ?\nSauvegarder le workspace, fermer le logiciel puis l’ouvrir de nouveau\nCliquer sur l’onglet Providers\n\nQue voit-on ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes données restent ! Si on utilise souvent ce fichier Excel c’est un moyen de le garder en mémoire.\n\n\n\n\n\n\n\n\n\nPour information\n\n\n\nJDemetra+ stocke l’emplacement du fichier Excel, si vous le changez de répertoire, les données ne seront plus reconnues ! Peu pratique me direz-vous mais c’est en fait indispensable si l’on souhaite mettre à jour. Évitez donc de laisser votre fichier dans le dossier “Téléchargements” !"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#création-dun-nouveau-multi-document",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#création-dun-nouveau-multi-document",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.1 Création d’un nouveau « multi-document »",
    "text": "3.1 Création d’un nouveau « multi-document »\n\nCliquer sur l’onglet Workspace\nDouble-clic sur Seasonal adjustment\nClic-droit sur multi-documents\nCliquer sur New\nDouble-clic sur multi-documents\n\nQue voit-on ?\n\nDouble-clic sur le « multi-document » créé, nommé SAProcessing-1 par défaut\n\nQue se passe-t-il ?"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#choisir-une-spécfication-pré-définie",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#choisir-une-spécfication-pré-définie",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.2 Choisir une spécfication pré-définie",
    "text": "3.2 Choisir une spécfication pré-définie\n\nAller dans l’onglet SAProcessing-1\nCliquer sur la flèche située à côté de la petite « calculatrice »\nCliquer sur le + à côté de « x13 » puis cliquer sur RSA5c (ou RSA5 si l’on utilise JDemetra+ &gt; 3.0.0)\nCliquer quelque part dans SAProcessing-1"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#lancer-une-désaisonnalisation",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#lancer-une-désaisonnalisation",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.3 Lancer une désaisonnalisation",
    "text": "3.3 Lancer une désaisonnalisation\n\nCliquer sur Providers\nFaire glisser l’ensemble des séries de votre fichier dans l’onglet SAProcessing-1\n\nQue voit-on ?\n\nCliquer sur la flèche verte figurant dans l’onglet SAProcessing-1\n\n\n\nQue se passe-t-il ?\nCliquer sur une série\n\nQue voit-on ?\n\nSauvegarder le workspace\n\n\n\n\n\n\n\nPour information\n\n\n\nIl y a de grandes chances pour qu’un jour vous oubliiez l’étape 3.2 avant de “faire glisser” vos séries. Dans ce cas, vous aurez beau changer la spécification, cela n’affectera vos séries déjà importées. Deux solutions s’offrent à vous :\n\nSolution brutale : fermer le workspace, supprimer toutes les séries, bref, tout recommencer.\nSolution maligne : sélectionner toutes les séries (ctrl + clic gauche ou ctrl + a, ou ctrl + maj…), clic droit, Spécification &gt; Select &gt; choisir la spécification voulue.\n\n\nDans JDemetra+ &gt; 3.0.0 le choix d’une spécification est obligatoire pour ajouter des séries. Pour modifier la spécification par défaut il faut sélectionner les séries, clic droit, Edit &gt; Reference specification &gt; Select &gt; choisir la spécification voulue."
  },
  {
    "objectID": "TP/JD_2_Analyse_exploratoire.html",
    "href": "TP/JD_2_Analyse_exploratoire.html",
    "title": "2 - Analyse exploratoire",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à faire une analyse exploratoire sous JDemetra+.\n\n\n1 Tracer un graphique dans JDemetra+\n\nCliquer sur la commande Tools&gt;Container&gt;Chart de la barre de menus en haut de l’écran\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet Chart.\n\nQue peut-on dire ?\n\nEst-ce que la série présente une tendance ?\nEst-ce que la série semble saisonnière?\n\n\nEst-ce que la série présente des pics ?\n\nSi oui, ces pics ont-ils ont toujours la même amplitude ?\n\nCliquer sur la courbe\nClic-droit sur la courbe\nCliquer sur Split into yearly components\n\nQue se passe-t-il ?\nQue peut-on dire en analysant ce graphique ?\n\n\n\n\n2 Tracer les taux de croissance d’une série dans JDemetra+\n\nCliquer sur la commande Tools&gt;Container&gt;GrowthChart de la barre de menus en haut de l’écran\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet GrowthChart.\n\nQuel est le taux de croissance représenté par défaut sur ce graphique ?\nReprésenter le taux de croissance en glissement annuel par un clic droit sur le graphique et en sélectionnant ensuite dans le menu qui s’affiche l’item Kind puis Previous Year.\nPlacer le curseur de la souris sur une des « barres » du graphique : que se passe-t-il?\n\nQuelles informations peut-on tirer de ces graphiques ?\n\n\n\n3 Tracer le spectre d’une série sous JDemetra+\n\nCliquer sur la commande Tools&gt;Spectral analysis&gt;Periodogram de la barre de menus en haut de l’écran\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet Periodogram Window.\n\nLe spectre présente-il des pics ?\n\nSi oui, à quelles fréquences ?\n\n\nFaire la même chose en prenant un autre outil que le Periodogram."
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html",
    "href": "TP/JD_4_CVS_CJO.html",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "",
    "text": "Cliquer sur l’onglet Providers\nClic-droit sur Spreadsheets\nCliquer sur Open\nCliquer sur le bouton …\nSélectionner le fichier Excel « regcjo.xlsx » contenant les régresseurs « Jours Ouvrables ».\nCliquer sur OK\nCliquer sur l’onglet Workspace\nCliquer sur le + à côté d’Utilities\nClic-droit sur Variables\nCliquer sur New\nCliquer sur le + à côté de Variables\nDouble cliquer sur l’icône Vars-1\nQue se passe-t-il ?\nRetourner dans l’onglet Providers\nFaire glisser l’ensemble des séries du fichier « regcjo.xls » dans l’onglet Vars-1\nRenommer les séries en reprenant leur nom d’origine dans le fichier excel « regcjo.xls ».\n\nCe travail peut être très fastidieux… Heureusement depuis R il existe une solution plus automatique !\nIl existe deux façons de faire, en fonction de si l’on utilise une version 2.x.y ou 3.x.y de JDemetra+. Repartons déjà des régresseurs jours ouvrables (pour leur création, voir le TP R associé) :\n\nlibrary(rjd3toolkit)\nFR &lt;- national_calendar(list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n))\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votre !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\nregresseurs_JO_trim &lt;- gen_calendrier(FR, frequency = 4)\nregresseurs_JO_mens &lt;- gen_calendrier(FR, frequency = 12)\n\ncolnames(regresseurs_JO_trim) &lt;- paste0(colnames(regresseurs_JO_trim), \"_trim\")\ncolnames(regresseurs_JO_mens) &lt;- paste0(colnames(regresseurs_JO_mens), \"_mens\")\n\n\n\nCi-dessous un code pour vous éviter de faire le travail manuel. Il est un peu peu compliqué mais une fois le code écrit, vous pouvez l’utiliser tel quel ! Vous pourrez ensuite repartir du workspace créé pour y ajouter vos propres séries.\n\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables &lt;- function(liste_var, workspace){\n    if(!is.mts(liste_var))\n        stop(\"liste_var doit être de type mts\")\n    context_dictionary &lt;- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n    ts_variable_managers &lt;- context_dictionary$getTsVariableManagers()\n    ts_variables &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n    jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    if (is.null(jd_r_variables)) {\n        ts_variable_managers$set(\"r\",\n                                 .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n        jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    }\n    jd_var_names &lt;- jd_r_variables$getNames()\n    \n    model_var_names &lt;- colnames(liste_var)\n    \n    for (i in seq_along(model_var_names)) {\n        name &lt;- model_var_names[i]\n        dictionary_var &lt;- jd_r_variables$get(name)\n        tsvar &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n                       name, RJDemetra:::ts_r2jd(liste_var[, i]))\n        if (is.null(dictionary_var)) {\n            jd_r_variables$set(name, tsvar)\n        } else {\n            warning(sprintf(\"La variable %s existe déjà\", name))\n        }\n    }\n}\n\n# Création d'un nouveaux\njws &lt;- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO_mens, jws)\ncomplete_variables(regresseurs_JO_trim, jws)\nsave_workspace(jws,\"workspace_CJO.xml\")\n\n\n\n\nPour la version 3 de JDemetra+, le code est plus simple. Vous pouvez également ajouter les calendriers\n\n# On va créer deux groupes de variables, on peut donc simplifier les noms\ncolnames(regresseurs_JO_mens) &lt;- \n    colnames(regresseurs_JO_trim) &lt;- \n    gsub(\"_mens\", \"\", colnames(regresseurs_JO_mens))\nctxt &lt;- rjd3toolkit::modelling_context(\n    # on appelle \"FR\" le calendrier\n    calendars = list(FR = FR), \n    # on crée un groupe de variables \"cjo_mens\" contenant les régresseurs mensuels\n    # et un groupe de variables \"cjo_trim\" contenant les régresseurs trimestriels\n    variables = list(cjo_mens = regresseurs_JO_mens,\n                     cjo_trim = regresseurs_JO_trim)\n) \n\njws &lt;- rjdemetra3::.jws_new(ctxt)\n# On peut également ajouter les calendriers et les variables avec les fonctions :\n# rjdemetra3:::add_variable()\n# rjdemetra3:::add_calendar()\nrjdemetra3::save_workspace(jws, \"workspace_CJO_v3.xml\")"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#jdemetra-2.x.y",
    "href": "TP/JD_4_CVS_CJO.html#jdemetra-2.x.y",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "",
    "text": "Ci-dessous un code pour vous éviter de faire le travail manuel. Il est un peu peu compliqué mais une fois le code écrit, vous pouvez l’utiliser tel quel ! Vous pourrez ensuite repartir du workspace créé pour y ajouter vos propres séries.\n\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables &lt;- function(liste_var, workspace){\n    if(!is.mts(liste_var))\n        stop(\"liste_var doit être de type mts\")\n    context_dictionary &lt;- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n    ts_variable_managers &lt;- context_dictionary$getTsVariableManagers()\n    ts_variables &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n    jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    if (is.null(jd_r_variables)) {\n        ts_variable_managers$set(\"r\",\n                                 .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n        jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    }\n    jd_var_names &lt;- jd_r_variables$getNames()\n    \n    model_var_names &lt;- colnames(liste_var)\n    \n    for (i in seq_along(model_var_names)) {\n        name &lt;- model_var_names[i]\n        dictionary_var &lt;- jd_r_variables$get(name)\n        tsvar &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n                       name, RJDemetra:::ts_r2jd(liste_var[, i]))\n        if (is.null(dictionary_var)) {\n            jd_r_variables$set(name, tsvar)\n        } else {\n            warning(sprintf(\"La variable %s existe déjà\", name))\n        }\n    }\n}\n\n# Création d'un nouveaux\njws &lt;- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO_mens, jws)\ncomplete_variables(regresseurs_JO_trim, jws)\nsave_workspace(jws,\"workspace_CJO.xml\")"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#jdemetra-3.x.y",
    "href": "TP/JD_4_CVS_CJO.html#jdemetra-3.x.y",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "",
    "text": "Pour la version 3 de JDemetra+, le code est plus simple. Vous pouvez également ajouter les calendriers\n\n# On va créer deux groupes de variables, on peut donc simplifier les noms\ncolnames(regresseurs_JO_mens) &lt;- \n    colnames(regresseurs_JO_trim) &lt;- \n    gsub(\"_mens\", \"\", colnames(regresseurs_JO_mens))\nctxt &lt;- rjd3toolkit::modelling_context(\n    # on appelle \"FR\" le calendrier\n    calendars = list(FR = FR), \n    # on crée un groupe de variables \"cjo_mens\" contenant les régresseurs mensuels\n    # et un groupe de variables \"cjo_trim\" contenant les régresseurs trimestriels\n    variables = list(cjo_mens = regresseurs_JO_mens,\n                     cjo_trim = regresseurs_JO_trim)\n) \n\njws &lt;- rjdemetra3::.jws_new(ctxt)\n# On peut également ajouter les calendriers et les variables avec les fonctions :\n# rjdemetra3:::add_variable()\n# rjdemetra3:::add_calendar()\nrjdemetra3::save_workspace(jws, \"workspace_CJO_v3.xml\")"
  },
  {
    "objectID": "TP/JD_6_X11.html",
    "href": "TP/JD_6_X11.html",
    "title": "6 - X11",
    "section": "",
    "text": "L’objectif de ce TP est d’analyser la décomposition et de changer la spécification si nécessaire"
  },
  {
    "objectID": "TP/JD_6_X11.html#filtre-saisonnier",
    "href": "TP/JD_6_X11.html#filtre-saisonnier",
    "title": "6 - X11",
    "section": "2.1 Filtre saisonnier",
    "text": "2.1 Filtre saisonnier\n\nEssayer de changer le filtre saisonnier dans X11 &gt; Seasonal filter\n\nLorsque vous prenez un filtre plus long ou plus court, qu’observez vous sur les M statistics, S-I ratios, la saisonnalité et la série désaisonnalisée ?\nEn quoi cela affecte les autres diagnostics (en particulier la saisonnalité résiduelle) ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#filtre-de-henderson",
    "href": "TP/JD_6_X11.html#filtre-de-henderson",
    "title": "6 - X11",
    "section": "2.2 Filtre de Henderson",
    "text": "2.2 Filtre de Henderson\n\nEssayer de changer le filtre de Henderson dans X11 &gt; Henderson filter\n\nLorsque vous prenez un filtre plus long ou plus court, qu’observez vous sur les M statistics, S-I ratios, la saisonnalité et la série désaisonnalisée ?\nEn quoi cela affecte les autres diagnostics ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#lsigma-and-usigma",
    "href": "TP/JD_6_X11.html#lsigma-and-usigma",
    "title": "6 - X11",
    "section": "2.3 Lsigma and Usigma",
    "text": "2.3 Lsigma and Usigma\n\nEssayer de changer les paramètres Lsigma et Usigma\n\nQu’observez-vous sur les statistiques M ?\nEn quoi cela affecte les autres diagnostics ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#calendar-sigma",
    "href": "TP/JD_6_X11.html#calendar-sigma",
    "title": "6 - X11",
    "section": "2.4 Calendar sigma",
    "text": "2.4 Calendar sigma\n\nAller dans la fenêtre Decomposition (X11) &gt; Quality measures &gt; Details et descendre jusqu’au test de Cochran\n\nEst-ce que le test est rejeté ? Si oui qu’est-ce que cela implique ? Regarder les S-I ratios : est-ce que vous êtes d’accord avec ce test ?\nChanger le paramètre calendarsigma à “Signif” : en quoi les différents diagnostics sont impactés ?"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html",
    "href": "TP/R_0_Manipulation_series_temporelles.html",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler les séries temporelles sous R en utilisant les packages de bases.\nDans R il existe de nombreux packages qui permettent de manipuler les séries temporelles. Pour n’en citer que quelques-uns :\n- Les objets ts peuvent être créés à partir du package stats ;\n- Les objets zoo peuvent être créés à partir du package zoo ;\n- Les objets xts peuvent être créés à partir du package xts ;\n- Les objets tis peuvent être créés à partir du package tseries ;\n- Les objets tsibble peuvent être créés à partir du package tsibble.\ntsbox permet quand à lui de facilement passer d’une classe à l’autre.\nIci nous nous concentrerons essentiellement sur les trois premiers : ts stocker les séries temporelles, zoo et xts pour effectuer certaines manipulations supplémentaires.\nLes packages suivants seront utilisés :\npackages_to_install &lt;- c(\"zoo\", \"xts\", \"dplyr\", \"XLConnect\", \"remotes\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"])\n    remotes::install_github(\"rjdemetra/rjd3toolkit\")"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#création-dune-série-temporelle",
    "href": "TP/R_0_Manipulation_series_temporelles.html#création-dune-série-temporelle",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.1 Création d’une série temporelle",
    "text": "1.1 Création d’une série temporelle\nLa fonction ts() permet de créer des objets séries-temporelles à partir un vecteur (ou une matrice). La syntaxe de base est ts(vector, start=, end=, frequency=) où start et end sont la première et la dernière observation, frequency est le nombre d’observations par unité de temps (1=annuelle, 2=semestrielle, 4=trimestrielle, 6=bi-mestrielle, 12=mensuelle, etc.).\nPar exemple pour créer une série trimestrielle ayant les valeurs de 1 à 10 et commençant en 1959Q2 :\n\nts(1:10, frequency = 4, start = c(1959, 2)) # 2ème trimestre de 1959\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n\n# Équivalent à \nts(1:10, frequency = 4, start = 1959 + 1/4)\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n\n\nOn peut aussi définir l’objet à partir de sa date de fin :\n\nts(1:10, frequency = 4, end = c(1959, 2))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1957    1    2    3    4\n1958    5    6    7    8\n1959    9   10          \n\n\nSi l’on directement extraire un sous-ensemble de la série on peut spécifier les paramètres end et start. Par exemple pour ne garder que les valeurs jusqu’en 1960 inclus :\n\nts(1:10, frequency = 4, start = c(1959, 2), end = c(1960, 4))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n\n\nOu alors utiliser la fonction window une fois l’objet créé :\n\nts_object &lt;- ts(1:10, frequency = 4, start = c(1959, 2))\nwindow(ts_object, end = c(1960, 4))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n\n\nOn peut récupérer les différents attributs avec les fonctions start(), end() et frequency() :\n\nstart(ts_object)\n\n[1] 1959    2\n\nend(ts_object)\n\n[1] 1961    3\n\nfrequency(ts_object)\n\n[1] 4\n\n\nDeux autres fonctions peuvent aussi être utiles : time() crée un série-temporelle à partir des dates de notre série-temporelle et cycle() donne la position dans le cycle de chaque observation.\n\ntime(ts_object)\n\n        Qtr1    Qtr2    Qtr3    Qtr4\n1959         1959.25 1959.50 1959.75\n1960 1960.00 1960.25 1960.50 1960.75\n1961 1961.00 1961.25 1961.50        \n\ncycle(ts_object)\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         2    3    4\n1960    1    2    3    4\n1961    1    2    3     \n\n\n\n\n\n\n\n\nExercice\n\n\n\nExtraire toutes les données du 2ème trimestre de l’objet ts_object\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nts_object[cycle(ts_object) == 2]\n\n[1] 1 5 9\n\n\nAutre option : utiliser la fonction window()\n\nwindow(ts_object, frequency = 1)\n\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n\n\nExplication : lorsque l’on spécifie le paramètre frequency dans la fonction window(), on change la fréquence de la série. Dans notre cas, on veut extraire les valeurs du deuxième trimestre : on veut donc une série annuelle qui contient toutes les valeurs des deuxièmes trimestres. La première observation de ts_object étant un deuxième trimestre, cela donne ce que l’on veut. Pour extraire les valeurs des troisièmes trimestres il faut en plus changer la date de début :\n\nwindow(ts_object, start = c(1950, 3), frequency = 1)\n\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCréer une série temporelle mensuelle qui commence en 2000, qui se termine en janvier 2020, qui vaut 1 en avril 2009 et 0 à toutes les autres dates.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 : utiliser la fonction window()\n\nindicatrice &lt;- ts(0, start = 2000, end = 2020, frequency = 12)\nwindow(indicatrice, start = c(2009, 4), end = c(2009, 4)) &lt;- 1\nindicatrice\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n\n\nOption 2 : utiliser time()\n\nindicatrice &lt;- ts(0, start = 2000, end = 2020, frequency = 12)\n# Donne un vecteur de booléens\n(time(indicatrice) == 2009 + 3/12) \n\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2000 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2001 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2002 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2003 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2004 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2005 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2006 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2007 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2008 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2009 FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2010 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2011 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2012 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2013 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2014 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2015 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2016 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2017 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2018 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2019 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2020 FALSE                                                                  \n\n# on ajoute + 0 pour forcer la convertion en numérique\n(time(indicatrice) == 2009 + 3/12) + 0\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n\n\n\n\n\nPour tracer un graphique il suffit maintenant d’utiliser les fonctions plot() et lines()\n\nplot(ts_object * 2)\nlines(ts_object, col = \"red\")"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#séries-multivariées",
    "href": "TP/R_0_Manipulation_series_temporelles.html#séries-multivariées",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.2 Séries multivariées",
    "text": "1.2 Séries multivariées\nDe la même façon que précédemment on peut créer une série temporelle multivariée. Cette fois-ci l’objet créé est à la fois mts, ts et matrix\n\nset.seed(1)\n# On génère 300 observations d'une loi normale (0, 1)\nloi_normale &lt;- rnorm(300)\nmts &lt;- ts(matrix(loi_normale, nrow = 100, ncol = 3),\n          start = c(1961, 1), frequency = 12)\n\nOn peut accéder à la première variable de la même façon que dans une matrice : par son nom ou son numéro de colonne :\n\ncolnames(mts)\n\n[1] \"Series 1\" \"Series 2\" \"Series 3\"\n\n# mts[,1] # ou de façon équivalente :\nmts[, \"Series 1\"]\n\n              Jan          Feb          Mar          Apr          May\n1961 -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772\n1962 -0.621240581 -2.214699887  1.124930918 -0.044933609 -0.016190263\n1963  0.619825748 -0.056128740 -0.155795507 -1.470752384 -0.478150055\n1964 -0.394289954 -0.059313397  1.100025372  0.763175748 -0.164523596\n1965 -0.112346212  0.881107726  0.398105880 -0.612026393  0.341119691\n1966  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209\n1967  0.610726353 -0.934097632 -1.253633400  0.291446236 -0.443291873\n1968  0.593946188  0.332950371  1.063099837 -0.304183924  0.370018810\n1969 -1.276592208 -0.573265414 -1.224612615 -0.473400636             \n              Jun          Jul          Aug          Sep          Oct\n1961 -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387\n1962  0.943836211  0.821221195  0.593901321  0.918977372  0.782136301\n1963  0.417941560  1.358679552 -0.102787727  0.387671612 -0.053805041\n1964 -0.253361680  0.696963375  0.556663199 -0.688755695 -0.707495157\n1965 -1.129363096  1.433023702  1.980399899 -0.367221476 -1.044134626\n1966  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670\n1967  0.001105352  0.074341324 -0.589520946 -0.568668733 -0.135178615\n1968  0.267098791 -0.542520031  1.207867806  1.160402616  0.700213650\n1969                                                                 \n              Nov          Dec\n1961  1.511781168  0.389843236\n1962  0.074564983 -1.989351696\n1963 -1.377059557 -0.414994563\n1964  0.364581962  0.768532925\n1965  0.569719627 -0.135054604\n1966  0.475509529 -0.709946431\n1967  1.178086997 -1.523566800\n1968  1.586833455  0.558486426\n1969                          \n\n\nEt avec les même fonctions que pour les matrices on peut récupérer les noms des colonnes (colnames), le nombre de variables (ncol), etc.\n\n\n\n\n\n\nAttention\n\n\n\nUne source classique d’erreur est de manipuler des séries-temporelles uni et multivariées et de vouloir utiliser les fonctions liées aux matrices sur les séries univariées. Par exemple, colnames(ts_object) renverra toujours l’objet NULL. Une solution est de tester si l’objet est multivarié avec la fonction is.mts()."
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#manipulation-basiques",
    "href": "TP/R_0_Manipulation_series_temporelles.html#manipulation-basiques",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.3 Manipulation basiques",
    "text": "1.3 Manipulation basiques\nPour concaténer plusieurs séries temporelles, les fonctions deux fonctions suivantes peuvent ts.union() et ts.intersect().\n\nts_object2 &lt;- ts(1:10, frequency = 4, start = c(1960, 1))\nts.union(ts_object, ts_object2) # on garde toute la couverture temporelle en rajoutant des NA\n\n        ts_object ts_object2\n1959 Q2         1         NA\n1959 Q3         2         NA\n1959 Q4         3         NA\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n1961 Q4        NA          8\n1962 Q1        NA          9\n1962 Q2        NA         10\n\nts.intersect(ts_object, ts_object2) # on ne garde que les périodes communes\n\n        ts_object ts_object2\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n\n\nOn va maintenant utiliser la série d’indice de production industrielle de la France (CVS-CJO) :\n\nipi_fr_manuf &lt;- ts(c(99, 99.4, 99.7, 99.4, 100.8, 100, 98.7, 100.2, 101.2, \n100.6, 99.9, 100.9, 102.4, 100.8, 99.5, 100.7, 99.8, 99.1, 99.8, \n101.6, 100.4, 99.4, 102.8, 101, 100.2, 101.1, 102.6, 101.8, 103.7, \n103, 103.6, 103.5, 104.4, 105.6, 105.5, 105.9, 103.6, 102.9, \n103.8, 103.8, 102.5, 104.2, 104, 104.6, 103.4, 104.2, 103.4, \n103.7, 104.9, 105.8, 104.4, 104.3, 106, 103.7, 104.1, 103.1, \n103.9, 104.4), start = 2015, frequency = 12)\n\nPour calculer la série retardée/avancée, il suffit d’utiliser la fonction lag() :\n\n# série retardée d'un mois : en février 2010 on a la valeur de janvier 2010\nlag(ipi_fr_manuf, k = -1) \n\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2015        99.0  99.4  99.7  99.4 100.8 100.0  98.7 100.2 101.2 100.6  99.9\n2016 100.9 102.4 100.8  99.5 100.7  99.8  99.1  99.8 101.6 100.4  99.4 102.8\n2017 101.0 100.2 101.1 102.6 101.8 103.7 103.0 103.6 103.5 104.4 105.6 105.5\n2018 105.9 103.6 102.9 103.8 103.8 102.5 104.2 104.0 104.6 103.4 104.2 103.4\n2019 103.7 104.9 105.8 104.4 104.3 106.0 103.7 104.1 103.1 103.9 104.4      \n\n\nLa fonction diff permet de calculer la différence entre deux périodes :\n\ndiff(ipi_fr_manuf, lag = 1)\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2015       0.4  0.3 -0.3  1.4 -0.8 -1.3  1.5  1.0 -0.6 -0.7  1.0\n2016  1.5 -1.6 -1.3  1.2 -0.9 -0.7  0.7  1.8 -1.2 -1.0  3.4 -1.8\n2017 -0.8  0.9  1.5 -0.8  1.9 -0.7  0.6 -0.1  0.9  1.2 -0.1  0.4\n2018 -2.3 -0.7  0.9  0.0 -1.3  1.7 -0.2  0.6 -1.2  0.8 -0.8  0.3\n2019  1.2  0.9 -1.4 -0.1  1.7 -2.3  0.4 -1.0  0.8  0.5          \n\n\nEn revanche, le paramètre lag ne peut prendre que une valeur. La fonction rjd3toolkit::differences() permet d’effectuer plusieurs différences et a également un paramètre mean pour centrer la série. Par exemple, pour effectuer à la fois une différenciation régulière et saisonnière (d’ordre 12) :\n\nrjd3toolkit::differences(ipi_fr_manuf, lags = c(1, 12))\n\n             Jan         Feb         Mar         Apr         May         Jun\n2016             -1.92888889 -1.52888889  1.57111111 -2.22888889  0.17111111\n2017 -2.22888889  2.57111111  2.87111111 -1.92888889  2.87111111  0.07111111\n2018 -1.42888889 -1.52888889 -0.52888889  0.87111111 -3.12888889  2.47111111\n2019  3.57111111  1.67111111 -2.22888889 -0.02888889  3.07111111 -3.92888889\n             Jul         Aug         Sep         Oct         Nov         Dec\n2016  2.07111111  0.37111111 -2.12888889 -0.32888889  4.17111111 -2.72888889\n2017 -0.02888889 -1.82888889  2.17111111  2.27111111 -3.42888889  2.27111111\n2018 -0.72888889  0.77111111 -2.02888889 -0.32888889 -0.62888889 -0.02888889\n2019  0.67111111 -1.52888889  2.07111111 -0.22888889                        \n\n\n\n\n\n\n\n\nExercice\n\n\n\nÉcrire une fonction ev() qui calcule l’évolution mensuelle si la série en entrée est mensuelle, l’évolution trimestrielle si la série en entrée est trimestrielle, etc.\nLa fonction ev() transformera donc toute série \\(X_t\\) en : \\[\nY_t=\\frac{X_t-X_{t-1}}{\nX_{t-1}\n}=\\frac{X_t}{\nX_{t-1}\n} - 1.\n\\]\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nev &lt;- function(x){\n  result &lt;- (x/stats::lag(x, k = -1) - 1) * 100\n  return(result)\n}\n# Ou de manière équivalente :\nev2 &lt;- function(x){\n  # Attention ici c'est bien k = 1 dans la fonction diff\n  # et k = -1 dans la fonction lag\n  result &lt;- (diff(x, lag = 1) /lag(x, k = -1)) * 100\n  return(result)\n}\n\nRemarque : pour des raisons informatiques ces deux fonctions ne donnent pas exactement le même résultat. C’est un problème récurrent lorsque l’on souhaite tester l’égalité entre deux séries temporelles :\n\nall(ev(ipi_fr_manuf) == ev2(ipi_fr_manuf))\n\n[1] FALSE\n\n\nUne solution est plutôt d’utiliser la fonction all.equal() :\n\nisTRUE(all.equal(ev(ipi_fr_manuf), ev2(ipi_fr_manuf)))\n\n[1] TRUE"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-xts",
    "href": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-xts",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "2.1 Utilisation de xts",
    "text": "2.1 Utilisation de xts\nUn des avantages du package xts est qu’il permet d’appliquer une fonction à chaque période d’une série temporelle (par exemple à toutes les données trimestrielles, annuelles, etc.). Il s’agit des fonctions apply.monthly(), apply.quarterly(), apply.yearly(), etc. Pour cela il faut auparavant convertir les données au format xts.\nPar exemple pour calculer la moyenne annuelle :\n\nlibrary(xts)\nmoy_an &lt;- apply.yearly(as.xts(ipi_fr_manuf), mean)\nmoy_an\n\n              [,1]\nDec 2015  99.98333\nDec 2016 100.60833\nDec 2017 103.40833\nDec 2018 103.67500\nOct 2019 104.46000\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer l’évolution trimestrielle de ipi_fr_manuf.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTout d’abord on prolonge l’IPI par des valeurs manquantes jusqu’à la fin de l’année, sinon la dernière somme sur le trimestre est fausse.\n\nipi_fr_manuf_prolonge &lt;- window(ipi_fr_manuf, end = c(2019, 12), extend = TRUE)\nsomme_trim &lt;- apply.quarterly(as.xts(ipi_fr_manuf_prolonge), sum)\n\nAttention la fonction lag n’agit pas pareil pour les objets xts et ts : il faut ici utiliser l’option k = 1. Voir l’aide associée à ?lag.xts. Pour garder la même convention entre lag.ts() et lag.xts() on peut utiliser l’option options(xts.compat.zoo.lag=TRUE).\n\nevol_trim &lt;- (somme_trim/lag(somme_trim, k = 1) - 1) * 100\n\nOn peut utiliser la fonction format() si l’on veut convertir automatiquement en un objet ts :\n\nstart_year &lt;- as.numeric(format(start(evol_trim), \"%Y\"))\nstart_quarter &lt;- as.numeric(substr(quarters(start(evol_trim)), 2, 2))\nts(evol_trim, start = c(start_year, start_quarter), frequency = 4)\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015          NA  0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n\n\nOn peut aussi directement utiliser le package ts_box et la fonction ts_ts() :\n\ntsbox::ts_ts(evol_trim)\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015                      NA  0.70446159 -0.03331113\n2016  0.43318894  0.43132050 -1.02411629  0.73431242\n2017  0.46388337  0.23087071  1.51365581  0.97244733\n2018  1.76565008 -2.11356467  0.06445375  0.48309179\n2019 -0.22435897  1.22068744 -0.34909553 -0.92356688\n2020          NA                                    \n\n\n\n\n\nOn aurait en fait pu le faire directement avec les fonctions de base R ! Par contre la situation aurait été plus compliquée avec des données haute fréquence (du type journalières) non correctement gérées par ts :\n\nstats::aggregate.ts(ipi_fr_manuf, nfrequency = 4,\n          FUN = mean)\n\n          Qtr1      Qtr2      Qtr3      Qtr4\n2015  99.36667 100.06667 100.03333 100.46667\n2016 100.90000  99.86667 100.60000 101.06667\n2017 101.30000 102.83333 103.83333 105.66667\n2018 103.43333 103.50000 104.00000 103.76667\n2019 105.03333 104.66667 103.70000          \n\n\nCette fonction fait ici une somme sur 4 périodes consécutives mais ne reconnait pas les différents mois des trimestres :\n\nstats::aggregate.ts(window(ipi_fr_manuf, start = c(2015,2)), nfrequency = 4,\n          FUN = mean)\n\nTime Series:\nStart = 2015.08333333333 \nEnd = 2019.58333333333 \nFrequency = 4 \n [1]  99.50000  99.83333 100.66667 101.06667 100.33333  99.56667 100.46667\n [8] 101.33333 101.83333 103.43333 104.50000 105.00000 103.50000 103.56667\n[15] 104.06667 104.00000 104.83333 104.60000 103.80000\n\n\nUne autre possibilité est d’utiliser la fonction rjd3toolkit::aggregate() (mais dont les fonctions d’agrégation sont limitées) :\n\nrjd3toolkit::aggregate(window(ipi_fr_manuf, start = c(2015,2)),\n                       nfreq = 4)\n\n      Qtr1  Qtr2  Qtr3  Qtr4\n2015       300.2 300.1 301.4\n2016 302.7 299.6 301.8 303.2\n2017 303.9 308.5 311.5 317.0\n2018 310.3 310.5 312.0 311.3\n2019 315.1 314.0 311.1"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-zoo",
    "href": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-zoo",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "2.2 Utilisation de zoo",
    "text": "2.2 Utilisation de zoo\nLe package zoo donne un ensemble d’outils qui permettent de manipuler les séries-temporelles. De nombreux packages (dont xts) sont d’ailleurs basés sur ce format. Il permet notamment de faire des imputations de données manquantes selon différentes fonctions (toutes les fonctions commençant par na.) et de mieux gérer le format des dates associées aux séries temporelles (ce qui permet de faire des manipulations avec la fonction format, ce qui permet par exemple plus facilement exporter des séries temporelles sous Excel). Le calcul de l’évolution trimestrielle aurait par exemple pu être faite avec ce package :\n\nsomme_trim &lt;- aggregate(as.zoo(ipi_fr_manuf_prolonge), yearqtr, sum)\nsomme_trim &lt;- as.ts(somme_trim) #La conversion en ts est plus simple depuis un objet zoo\nevol_trim &lt;- ev(somme_trim)\nevol_trim\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015              0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n\n\nPour le prochain exercice, utiliser la série suivante :\n\nserie_avec_NA &lt;- ts(c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, \n  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA), start = 2000, frequency = 12)\n\n\n\n\n\n\n\nExercice\n\n\n\nSur la série serie_avec_NA, utiliser les différentes fonctions du package zoo pour :\n\nEnlever les valeurs manquantes au début de la série ;\n\nRemplacer les valeurs manquantes à la fin de la série par la dernière valeur observée.\n\nInterpoler de manière linéaire les valeurs manquantes entre les 0 et les 1.\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nLes trois fonctions à utiliser sont : na.trim(), na.locf() et na.approx(). Il faudra peut-être inverser deux étapes pour que cela marche.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nD’abord on enlève les valeurs manquantes au début de la série\n\netape_1 &lt;- na.trim(serie_avec_NA, sides = \"left\")\netape_1\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2004  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2005   1   1   1   1   1   1   1   1   1   1   1   1\n2006   1   1   1   1   1   1   1   1   1   1   1   1\n2007  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n\n\nEnsuite on interpole\n\netape_2 &lt;- na.approx(etape_1, na.rm = FALSE)\netape_2\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n\n\nEnfin on remplace les valeurs à la fin de la série\n\netape_3 &lt;- na.locf(etape_2)\netape_3\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nÀ l’aide des fonctions as.yearmon() et format(), créer un data.frame contenant une colonne “date” qui contient les dates au format JJ/MM/YYYY et une deuxième colonnes avec les valeurs de ipi_fr_manuf.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nLa fonction as.yearmon() doit être appliquée sur time(ipi_fr_manuf). Pour la fonction format regarder l’aide ?format.Date.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndates &lt;- as.yearmon(time(ipi_fr_manuf))\ndates &lt;- format(dates, \"%d/%m/%Y\")\ndonnees_formatees &lt;- data.frame(date = dates, ipi = ipi_fr_manuf)\nhead(donnees_formatees)\n\n        date   ipi\n1 01/01/2015  99.0\n2 01/02/2015  99.4\n3 01/03/2015  99.7\n4 01/04/2015  99.4\n5 01/05/2015 100.8\n6 01/06/2015 100.0\n\n\n\n\n\nIl peut également être utile d’exporter un objet R ts ou mts vers un fichier Excel, tout en rajoutant une colonne “date” qui sera au format date. Ci-dessous un exemple en utilisant le package XLConnect :\n\nlibrary(XLConnect)\nts2xls &lt;- function(x, file, sheet=\"Feuille 1\", format = \"dd/mm/yyyy\"){\n  wb &lt;- loadWorkbook(file, create = TRUE)\n  createSheet(wb, sheet)\n  if(is.mts(x)){\n    col &lt;- c(\"date\", colnames(x))\n  }else{\n    col &lt;- c(\"date\", \"x\")\n  }\n  # Le titre\n  writeWorksheet(wb,matrix(col,nrow = 1),\n                 sheet = sheet,startCol = 1,startRow =1,\n                 header = FALSE)\n\n  # Petit trick pour que la colonne date soit au format date d'Excel\n  csDate &lt;- getOrCreateCellStyle(wb, name = \"date\")\n  setDataFormat(csDate, format = format)\n  date &lt;- as.Date(format(zoo::as.Date((time(x))), \"%d/%m/%Y\"),\n                  \"%d/%m/%Y\")\n  writeWorksheet(wb,date,sheet = sheet,\n                 startCol = 1,startRow = 2,\n                 header = FALSE)\n  setCellStyle(wb, sheet = sheet, row = seq_along(date)+1,\n               col = 1,\n               cellstyle = csDate)\n  # Fin colonne date\n\n  # Autres colonnes\n  writeWorksheet(wb,x,sheet = sheet,startCol = 2,startRow = 2,\n                 header = FALSE)\n  setColumnWidth(wb, sheet, column = seq_along(col), width = -1)\n  saveWorkbook(wb, file)\n}"
  },
  {
    "objectID": "TP/R_2_CJO.html",
    "href": "TP/R_2_CJO.html",
    "title": "2 - Correction des jours ouvrables",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à créer des régresseurs jours ouvrables personnalisés, à les utiliser dans RJDemetra/JDemetra+ et à vérifier la qualité de la correction.\nPour créer des régresseurs jours ouvrables personnalisés, deux solutions :\nCe package n’étant pas sur le CRAN, pour les installer on peut par exemple utiliser la fonction remotes::install_github() :\n# # Configurer si besoin le proxy\n# proxy &lt;- \"proxy_a_definir\"\n# Sys.setenv(HTTPS_PROXY = proxy)\nremotes::install_github(\"rjdemetra/rjd3toolkit\",\n                        INSTALL_opts = \"--no-multiarch\")\nDans ce TP, nous nous intéresserons uniquement à la seconde option. En effet, le package R est plus flexible et permet de créer des régresseurs moins classiques que les working days et trading days.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\"RJDemetra\", \"remotes\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}"
  },
  {
    "objectID": "TP/R_2_CJO.html#création-dun-calendrier",
    "href": "TP/R_2_CJO.html#création-dun-calendrier",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.1 Création d’un calendrier",
    "text": "1.1 Création d’un calendrier\nPar défaut, les régresseurs jours ouvrables de JDemetra+ ne prennent pas en compte les spécificité calendaires des pays : on ne prend pas en compte les jours fériés. Pour les prendre en compte, il faut créer son propre calendrier où l’on supposera qu’un jour férié de plus dans le mois a le même effet qu’un dimanche.\n\nlibrary(rjd3toolkit)\n\nTrois fonctions peuvent être utilisées pour ajouter des jours fériés :\n\nfixed_day() pour ajouter un jour férié qui tombe à date fixe. Par exemple, pour ajouter le 8 mai :\n\n\nfixed_day(month =  5, day = 8)\n\n\neaster_day() pour ajouter un jour férié dont le jour dépend de Pâques : le paramètre offset permet de spécifier le nombre de jours avant (si négatif) ou après Pâques (si positif). Par exemple, pour ajouter la Pentecôte qui a lieu 60 jours après Pâques :\n\n\neaster_day(offset = 60)\n\n\nsingle_day() pour ajouter un jour ferié qui n’a eu lieu qu’une seule fois.\n\n\nsingle_day(\"1993-01-15\")\n\n\nfixed_week_day() qui permet d’ajouter des jours fériés qui apparaissent certaines semaines de certains mois (par exemple le premier lundi du mois de septembre aux USA)\n\n\nfixed_week_day(9, 1, 1) # first Monday(1) of September.\n\n\nspecial_day() qui permet d’ajouter des jours fériés par rapport à des dates déjà connues dans JDemetra+ (voir tableau ci-dessous). Comme pour la fonction easter_day(), le paramètre offset permet de spécifier la position du jour voulu par rapport rapport à la fête pré-spécifié (par défaut offset = 0, le jour férié coïncide avec le jour pré-spécifié). Par exemple, pour ajouter le nouvel an :\n\n\nspecial_day(\"NEWYEAR\")\n\n\n\n\n\nJours pré-spécifiés\n\n\nEvent\nDéfinition\n\n\n\n\nNEWYEAR\nFête fixe, 1er janvier.\n\n\nSHROVEMONDAY\nFête mobile, lundi avant le mecredi des cendres (48 jours avant pâques).\n\n\nSHROVETUESDAY\nFête mobile, mardi avant le mecredi des cendres (47 jours avant pâques).\n\n\nASHWEDNESDAY\nFête mobile, 46 jours avant Pâques.\n\n\nEASTER\nFête mobile, Pâques, varie entre le 22 mars et le 25 avril.\n\n\nMAUNDYTHURSDAY\nFête mobile, le jeudi avant Pâques.\n\n\nGOODFRIDAY\nFête mobile, le vendredi avant Pâques.\n\n\nEASTERMONDAY\nFête mobile, le lendemain de Pâques.\n\n\nASCENSION\nFête mobile, célébrée un jeudi, 40 jours après Pâques.\n\n\nPENTECOST\nFête mobile, 50 jours après Pâques.\n\n\nCORPUSCHRISTI\nFête mobile, 60 jours après Pâques.\n\n\nWHITMONDAY\nFête mobile, le jour après la Pentecôte.\n\n\nMAYDAY\nFête fixe, 1er mai.\n\n\nASSUMPTION\nFête fixe, 15 août.\n\n\nHALLOWEEN\nFête fixe, 31 octobre.\n\n\nALLSAINTSDAY\nFête fixe, 1er novembre.\n\n\nARMISTICE\nFête fixe, 11 novembre.\n\n\nCHRISTMAS\nFête fixe, 25 décembre.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCréer un calendrier qui contient tous les jours fériés de la France.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFR &lt;- national_calendar(list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n))"
  },
  {
    "objectID": "TP/R_2_CJO.html#création-de-régresseurs-jo",
    "href": "TP/R_2_CJO.html#création-de-régresseurs-jo",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.2 Création de régresseurs JO",
    "text": "1.2 Création de régresseurs JO\nLe modèle général de correction de jours ouvrables peut s’écrire de la façon suivante : \\[\nX_t = \\sum_{i=1}^{7} \\alpha_i N_{it} + \\varepsilon_t\n\\] Avec :\n\n\\(N_{it}\\) le nombre de jours de lundis (\\(i=1\\)), …, dimanches et jours fériés (\\(i=7\\))\n\\(\\alpha_i\\) l’effet d’un jour de type \\(i\\)\n\nPour éviter les problèmes de multi-colinéarité, on réécrit le modèle en utilisant une modalité de référence (ici dimanche). On désaisonnalise également les régresseurs en enlevant la moyenne de long-terme : \\[X_t =  \\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +\n\\bar{\\alpha} \\underbrace{(N_t - \\bar{N}_t)}_{LY_t} +  \\varepsilon_t\\] Ce modèle peut être simplifié si en faisant des hypothèses sur les effets des jours ouvrés :\n\nL’hypothèse working days correspond au cas où l’on suppose que tous les jours de la semaine (lundi à vendredi) ont le même effet (\\(\\alpha_1=\\dots=\\alpha_5\\)), les samedis et les dimanches (et jours fériés) ont le même effet (\\(\\alpha_6=\\alpha_7\\)) et sont utilisés en tant que variable de contraste.\nL’hypothèse trading days correspond au cas où l’on suppose que tous les jours ont un effet différent et les dimanches (et jours fériés) sont utilisés en tant que variable de constrate.\n\nSous JDemetra+ on ne peut utiliser que ces deux hypothèses mais rjd3toolkit permet de construire d’autres types de JO.\nDe manière plus générale, lorsque l’on utilise une variable de contraste, les régresseurs \\(CJO_{t,i}\\) associé au groupe \\(i\\) est calculé de la façon suivante : \\[\nCJO_{t,i} = \\underbrace{\\sum_{j\\in\\text{groupe }i}N_{jt}}_{\n\\text{nb de jours du groupe }i\n} -\n\\frac{\\sum_{j\\in\\text{groupe }i}1}{\\sum_{j\\in\\text{groupe }0}1}\n\\times\n\\underbrace{\\sum_{j\\in\\text{groupe }0}N_{jt}}_{\n\\text{nb de jours du groupe contraste}\n}\n\\] Dans le cas working days, il y a 2 jours dans le groupe contraste (samedi et dimanche, \\(\\sum_{j\\in\\text{groupe }0}1=2\\)) et 5 jours dans le groupe 1 (lundi à vendredi, \\(\\sum_{j\\in\\text{groupe }1}1=5\\)). Au mois \\(t\\), le régresseurs JO type de jours est donc égal au nombre de jours de la semaine dans le mois, mois \\(5/2\\times\\) nombre de jours de week-end.\nLes régresseurs JO peuvent être créés à partir de 2 fonctions : htd() qui permet de les créer à partir d’un calendrier spécifique et td(). Dans ces fonctions, le paramètre le plus important est groups pour permet de faire des hypothèses sur les jours. C’est un vecteur de longueur 7 (le nombre de jours de la semaine) dont chaque élément indique à quel groupe le jour de la semaine associé correspond. La variable de contraste est associé au groupe 0.\nPar exemple, groups = c(1,2,3,4,5,6,0) correspond au trading days et groups = c(1,1,1,1,1,0,0) correspond au working days.\nPar exemple :\n\ngroups &lt;- c(1, 2, 3, 4, 5, 6, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(FR, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd &lt;- ts(wkd, start = start, frequency = frequency)\n\n\n\n\n\n\n\nExercice\n\n\n\nComparer le régresseurs JO working days créé avec le calendrier français et celui sans hypothèse sur les jours fériés (fonction td()).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngroups &lt;- c(1, 1, 1, 1, 1, 0, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(FR, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd &lt;- ts(wkd, start = start, frequency = frequency)\nwkd_def &lt;- td(frequency = frequency, start = start, length = 12*35,\n              groups = groups)\nwkd_def &lt;- ts(wkd_def, start = start, frequency = frequency)\ndata &lt;- ts.union(wkd, wkd_def)\nplot(data, col = c(\"orange\",\"black\"),\n     plot.type = \"single\")"
  },
  {
    "objectID": "TP/R_2_CJO.html#régresseur-leap-year",
    "href": "TP/R_2_CJO.html#régresseur-leap-year",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.3 Régresseur leap year",
    "text": "1.3 Régresseur leap year\nLe régresseur année bissextile (leap year), \\(LY_t\\) doit être créé à la main. Il est égal à la différence entre le nombre de jours dans le mois \\(t\\) et le nombre de jours moyens dans le mois \\(t\\), \\(\\bar N_t\\). Tous les mois ont le même nombre de jours, sauf le mois de février qui est de 29 jours tous les 4 ans. \\(\\bar N_t\\) est donc égal à 30 ou 31 si le mois considéré n’est pas un mois de février (et donc \\(N_t - \\bar N_t=0\\)) à 28,25 en février1. \\[\nLY_{t} =\n\\begin{cases}\n0,75 & \\mbox{si } t \\mbox{ est un mois de février bissextil } \\\\\n-0,25 & \\mbox{si } t \\mbox{ est un mois de février non bissextil } \\\\\n0 & \\mbox{sinon}\n\\end{cases}\n\\]\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction leap_year qui permet de générer le régresseur leap year.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nleap_year &lt;- function(start = 1990, end = 2030, frequency = 12){\n    ly &lt;- ts(0, start = start, end = end, frequency = 12)\n    mois_feb &lt;- cycle(ly) == 2\n    annees &lt;- trunc(round(time(ly), 3)) # arrondi car parfois des pbs avec fonction time\n    # On utilise la définition exacte\n    is_ly &lt;- (annees %% 400 == 0) |\n        ((annees %% 4 == 0) & (annees %% 100 != 0))\n    ly[mois_feb] &lt;- 28 - 28.2425\n    ly[mois_feb & is_ly] &lt;- 29 - 28.2425\n    # on change si besoin la fréquence\n    stats::aggregate(ly, nfrequency = frequency) \n}\nleap_year(frequency = 12)\n\n         Jan     Feb     Mar     Apr     May     Jun     Jul     Aug     Sep\n1990  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1991  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1992  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1993  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1994  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1995  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1996  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1997  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1998  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1999  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2000  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2001  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2002  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2003  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2004  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2005  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2006  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2007  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2008  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2009  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2010  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2011  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2012  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2013  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2014  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2015  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2016  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2017  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2018  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2019  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2020  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2021  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2022  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2023  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2024  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2025  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2026  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2027  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2028  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2029  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2030  0.0000                                                                \n         Oct     Nov     Dec\n1990  0.0000  0.0000  0.0000\n1991  0.0000  0.0000  0.0000\n1992  0.0000  0.0000  0.0000\n1993  0.0000  0.0000  0.0000\n1994  0.0000  0.0000  0.0000\n1995  0.0000  0.0000  0.0000\n1996  0.0000  0.0000  0.0000\n1997  0.0000  0.0000  0.0000\n1998  0.0000  0.0000  0.0000\n1999  0.0000  0.0000  0.0000\n2000  0.0000  0.0000  0.0000\n2001  0.0000  0.0000  0.0000\n2002  0.0000  0.0000  0.0000\n2003  0.0000  0.0000  0.0000\n2004  0.0000  0.0000  0.0000\n2005  0.0000  0.0000  0.0000\n2006  0.0000  0.0000  0.0000\n2007  0.0000  0.0000  0.0000\n2008  0.0000  0.0000  0.0000\n2009  0.0000  0.0000  0.0000\n2010  0.0000  0.0000  0.0000\n2011  0.0000  0.0000  0.0000\n2012  0.0000  0.0000  0.0000\n2013  0.0000  0.0000  0.0000\n2014  0.0000  0.0000  0.0000\n2015  0.0000  0.0000  0.0000\n2016  0.0000  0.0000  0.0000\n2017  0.0000  0.0000  0.0000\n2018  0.0000  0.0000  0.0000\n2019  0.0000  0.0000  0.0000\n2020  0.0000  0.0000  0.0000\n2021  0.0000  0.0000  0.0000\n2022  0.0000  0.0000  0.0000\n2023  0.0000  0.0000  0.0000\n2024  0.0000  0.0000  0.0000\n2025  0.0000  0.0000  0.0000\n2026  0.0000  0.0000  0.0000\n2027  0.0000  0.0000  0.0000\n2028  0.0000  0.0000  0.0000\n2029  0.0000  0.0000  0.0000\n2030                        \n\n# ou rjd3toolkit::lp_variable()\n\nOn peut également uiliser la fonction rjd3toolkit::ts_adjust() pour préajuster de l’effet année bissextile."
  },
  {
    "objectID": "TP/R_2_CJO.html#exercice-bilan",
    "href": "TP/R_2_CJO.html#exercice-bilan",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.4 Exercice bilan",
    "text": "1.4 Exercice bilan\n\n\n\n\n\n\nExercice\n\n\n\nCréer un objet regresseurs_JO qui contiendra tous les jeux de régresseurs plausibles. Par exemple :\n\nle régresseur leap year\nle jeu de régresseur trading days (TD7, lundi à samedi, dimanche = contraste)\nle jeu de régresseur working days (TD2, lundi =… = vendredi, samedi=dimanche=contraste)\nle jeu TD3 : lundi = … = vendredi, samedi et dimanche = contraste\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLa solution montre comment créer tous les régresseurs de JDemetra+ 3.0.0\n\nfrequency &lt;- 12\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votre !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\nregresseurs_JO &lt;- gen_calendrier(FR, frequency = 12)"
  },
  {
    "objectID": "TP/R_2_CJO.html#effet-graduel-de-pâques",
    "href": "TP/R_2_CJO.html#effet-graduel-de-pâques",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.5 Effet graduel de Pâques",
    "text": "1.5 Effet graduel de Pâques\nPrenons l’exemple de la vente de chocolats. Il est assez commun d’offrir des chocolats à Pâques : il y a donc une hausse des ventes autour du lundi de Pâques. Toutefois, ces ventes ne se font pas le jour de Pâques mais plusieurs jours avant, et plus on se rapproche du jour J, plus ces ventes sont importantes. C’est ce que l’on appel l’effet graduel de Pâques. Sous JDemetra+ on peut définir le nombre de jours avant Pâques pour lequel on considère qu’il y a un effet (easter_day.duration, entre 1 et 20) ou laisser ce choix à JDemetra+.\n\n\n\n\n\n\nExercice\n\n\n\nSerait-il pertinent de considérer un effet graduel de Noël dans le modèle Reg-ARIMA ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNon car l’effet graduel de Noël est en fait saisonnier car c’est un jour fixe ! Pour Pâques, comme c’est une fête mobile, les jours précédents peuvent être dans des mois différents en fonction de l’année considérée. Je ne suis pas entré dans les détails mais le régresseur utilisé pour la correction de l’effet graduel de Pâques est désaisonnalisé pour ne prendre en compte que l’effet voulu\n\n\n\nLe régresseur associé à l’effet graduel de Pâques peut être généré en utilisant la fonction rjd3toolkit::easter_variable()."
  },
  {
    "objectID": "TP/R_2_CJO.html#footnotes",
    "href": "TP/R_2_CJO.html#footnotes",
    "title": "2 - Correction des jours ouvrables",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\n En réalité, la vraie valeur est 28,2425. En effet, une année bissextile est une année divisible par 4 mais pas par 100, sauf si elle est divisible par 400 : 1900 n’était pas une année bissextile mais 2000 l’était !↩︎\n Vous remarquerez que le résultat est différent de celui affiché dans JDemetra+ : cela vient de la méthode d’estimation utilisée !↩︎\n Vous pouvez également utiliser le code vu dans les sections 2 et 3 pour estimer un modèle automatique.↩︎"
  },
  {
    "objectID": "TP/R_4_X11.html",
    "href": "TP/R_4_X11.html",
    "title": "4 - Qualité de la décomposition sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à étudier la qualité de la décomposition depuis RJDemetra.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\"RJDemetra\", \"remotes\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}\nDans ce TP nous allons voir différentes façon de vérifier la qualité de la décomposition. Tout d’abord, on peut commencer par regarder les statistiques m dont les définitions sont rappelées ci-dessous\nPoids\nDescription\nSi problème\n\n\n\n\nM1\n10\nContribution de l’irrégulier à la variance totale (stationnarisation par différence d’ordre 3). Si trop élevé, difficile d’extraire la saisonnalité.\nPoints atypiques ou taille des filtres\n\n\nM2\n11\nContribution de l’irrégulier à la variance totale (stationnarisation par une droite).\nPoints atypiques ou taille des filtres\n\n\nM3\n10\nMesuré à partir du ratio I/C. Si trop grand on aura du mal à séparer les deux composantes.\nPoints atypiques ou taille des filtres\n\n\nM4\n8\nTest autocorrélation sur l’irrégulier (réduire le filtre saisonnier).\nFiltre saisonnier plus court\n\n\nM5\n11\nMesuré à partir du MCD (nombre de mois nécessaires pour que les variations absolues de la TC l’emporte sur I).\nPoints atypiques\n\n\nM6\n10\nVérifie si la moyenne mobile M3x5 est appropriée (\\(1.5 &lt; I/S &lt; 6.5\\)).\nPrendre filtre plus long\n\n\nM7\n18\nPermet de voir si la saisonnalité est identifiable (compare part relative de la saisonnalité stable et mobile).\nSchéma multiplicatif ?\n\n\nM8\n7\nMesure l’évolution de la S de court terme.\nChanger filtre saisonnier\n\n\nM9\n7\nMesure l’évolution de la S de long terme.\nChanger filtre saisonnier\n\n\nM10\n4\nM8 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier\n\n\nM11\n4\nM9 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier"
  },
  {
    "objectID": "TP/R_4_X11.html#footnotes",
    "href": "TP/R_4_X11.html#footnotes",
    "title": "4 - Qualité de la décomposition sous R",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nEntre JDemetra+ 2.x et JDemetra+ 3.x la spécification du f-test a été changée↩︎"
  },
  {
    "objectID": "TP/R_6_cvs_hf.html",
    "href": "TP/R_6_cvs_hf.html",
    "title": "6 - Désaisonnalisation à haute-fréquence",
    "section": "",
    "text": "L’objectif de ce TP est de montrer un exemple de désaisonnalisation de séries haute-fréquence.\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\npackages_to_install &lt;- c(\"forecast\", \"ggplot2\", \"plotly\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\npackages_to_install_git &lt;- c(\"rjd3toolkit\", \"rjd3highfreq\", \"rjd3filters\", \"rjd3x11plus\")\npackages_git &lt;- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) &gt; 0) {\n    # # Configurer si besoin le proxy\n    # proxy &lt;- \"proxy_a_definir\"\n    # Sys.setenv(HTTPS_PROXY = proxy)\n    remotes::install_github(\n        sprintf(\"rjdemetra/%s\", packages_git),\n        # option utile dans certaines installations portables de Java :\n        INSTALL_opts = \"--no-multiarch\")\n}\nif (! \"ggdemetra3\" %in% installed.packages()[,\"Package\"])\n    remotes::install_github(\"AQLT/ggdemetra3\")\n\nNous utiliserons la base forecast::taylor de demande d’électricité par demi-heure en Angleterre et au Pays de Galles du lundi 5 juin 2000 au dimanche 27 août 2000.\n\nlibrary(rjd3highfreq)\nlibrary(forecast)\nlibrary(plotly)\nlibrary(ggplot2)\ntrace_ch &lt;- function(x, p0, p1, np= p1 - p0 + 1, original = TRUE, interactive = FALSE) {\n    sa_tests &lt;- rjd3toolkit::seasonality_canovahansen(\n        x,\n        p0 = p0, p1 = p1, np = np,\n        original = original)\n    x &lt;- seq.int(from = p0, length.out = length(sa_tests))\n    if (interactive) {\n        plot_ly() |&gt;\n            add_trace(\n                type = \"scatter\",\n                mode = \"lines\",\n                x = x,\n                y = sa_tests\n            )\n    } else {\n        plot(x, sa_tests, type = \"l\")\n    }\n}\ngraph_comp &lt;- function(data) {\n    dataGraph &lt;- reshape2::melt(data, id=\"x\")\n    ggplot(data = dataGraph, aes(x = x, y = value, color = variable)) +\n        geom_line()\n}\nx &lt;- seq(as.POSIXct(\"2020-06-05 00:00:00\"), as.POSIXct(\"2020-08-27 23:30:00\"), by=\"30 min\")\n\nLa saisonnalité est clairement identifiable sur la série brute :\n\nplot(x, taylor, type = \"l\")\n\n\n\n\n\n\n\n\nOn peut effectuer un test pour Canova-Hansen pour le vérifier :\n\ntrace_ch(taylor, p0 = 2, p1 = 2*24*7, np = 2*24*7-1)\n\n\n\n\n\n\n\n\nOn observe deux pics, pour des périodicités faibles (horaire ? cela ne s’explique pas) et autour de 48 (saisonnalité journalière). En faisant une différenciation journalière, on remarque qu’il reste de la saisonnalité qui est hebdomadaire (\\(2\\times24\\times7\\)) :\n\nplot(x[-(1:48)], rjd3toolkit::differences(taylor, 48), type = \"l\")\nlines(x[-(1:48)][-(1:(2*24*7))], rjd3toolkit::differences(taylor, c(48, 2*24*7)), col = \"red\")\n\n\n\n\n\n\n\n\nLa première méthode que nous utiliserons est la méthode mSTL. Elle prend en entrée des objets msts qui peuvent être créés avec la fonction forecast::msts() pour spécifier les différentes saisonnalités. Ici la base taylor est déjà au bon format mais on aurait pu la créer avec le code msts(taylor, seasonal.periods = c(2 * 24, 2*24*7)).\n\nmstl_mod &lt;- mstl(taylor,)\nautoplot(mstl_mod)\n\n\n\n\n\n\n\n\nPar défaut, une moyenne mobile de longueur 11 est utilisée pour la saisonnalité journalière et de longueur 15 pour la saisonnalité hebdomadaire (paramètre s.window) mais cette hypothèse peut être changée.\nOn pourrait également estimer le modèle avec TBATS mais le temps de calcul est long et les résultats n’étaient pas satisfaisants. Ci-dessous le code qui pourrait être utilisé :\n\ntbats_mod &lt;- tbats(taylor, seasonal.periods = c(2 * 24, 2*24*7))\n\nUtilisons maintenant les méthodes de rjd3highfreq. La série brute est très peu bruitée donc le préajustement n’est pas nécessaire. Par ailleurs pas de tendance marquée et le schéma additif parait adapté :\n\npre_pro &lt;- fractionalAirlineEstimation(\n    y = taylor,\n    periods = c(2*24, 2*24*7),\n    # pas utile de faire de détection des LS\n    outliers = c(\"ao\", \"wo\"),\n    log = FALSE, y_time = x)\npre_pro\n\nNumber of observations:  4032\nStart: 2020-06-05 \nEnd: 2020-08-27 23:30:00 \n\nEstimate MA parameters:\n        MA_parameter       Coef     Coef_SE      Tstat\n            Theta(1) -0.8100819 0.007010398 -115.55433\n  Theta(period = 48)  0.3883132 0.020280074   19.14752\n Theta(period = 336)  0.7760373 0.018278218   42.45694\n\nNumber of calendar regressors: 0 , Number of outliers : 1\n\nOutliers coefficients:\n               Variable     Coef  Coef_SE   Tstat\n AO.2020-06-12 21:00:00 -1234.44 139.3048 -8.8614\n\nSum of square residuals: 3.063e+08 on 3643 degrees of freedom\nLog likelihood = -2.602e+04, \n    aic = 5.204e+04, \n    aicc = 5.204e+04, \n    bic(corrected for length) = 11.35\nHannan–Quinn information criterion = 5.205e+04\n\n\nIl n’y a que 1 point atypique détecté. On va désaisonnaliser la série linéarisée de plusieurs façons : - Désaisonnalisation en deux étapes (journalière puis hebdomadaire) avec rjd3highfreq::fractionalAirlineDecomposition()\n\nDésaisonnalisation en une étape des deux saisonnalités en une étape avec rjd3highfreq::multiAirlineDecomposition().\nDésaisonnalisation uniquement de la saisonnalité hebdomadaire.\n\n\namb.p1 &lt;- rjd3highfreq::fractionalAirlineDecomposition(\n    y = pre_pro$model$linearized, # linearized series from preprocessing\n    period = 2 * 24,\n    log = FALSE)\n# Il reste de la saisonnalité\n# plot(ggdemetra3::seasonaladj(amb.p1), type = \"l\")\n\n# On ajuste maintenant la saisonnalité hebdomadaire :\namb.p2 &lt;- rjd3highfreq::fractionalAirlineDecomposition(\n    y = amb.p1$decomposition$sa,\n    period = 2*24*7,\n    log = FALSE,)\nplot(ggdemetra3::seasonaladj(amb.p2), type = \"l\")\n\n\n\n\n\n\n\n# Si on estime directement la saisonnalité hebdo le résultat semble proche\namb.sem &lt;- rjd3highfreq::fractionalAirlineDecomposition(\n    y = pre_pro$model$linearized,\n    period = 2*24*7,\n    log = FALSE)\n\namb.multi &lt;- rjd3highfreq::multiAirlineDecomposition(\n    y = pre_pro$model$linearized,\n    periods = c(2 * 24, 2*24*7),\n    log = FALSE, ndiff = 2, y_time = x)\n\nNous allons maintenant construire des tables pour comparer les méthodes. Dans les désaisonnalisations avec rjd3highfreq il faut ajouter les points atypiques du préajustement (pre_pro$model$component_outliers) :\n\npreaj &lt;- pre_pro$model$component_outliers\ndata_sa &lt;- data.frame(x = x,\n                      # on utilise c() pour enlever le type \"msts\"\n                      mstl = c(forecast::seasadj(mstl_mod)), \n                      amb_sem = ggdemetra3::seasonaladj(amb.sem) + preaj,\n                      amb_2step = ggdemetra3::seasonaladj(amb.p2) + preaj,\n                      amb_multi = ggdemetra3::seasonaladj(amb.multi) + preaj)\ndata_t &lt;- data.frame(x = x,\n                     mstl = c(forecast::trendcycle(mstl_mod)),\n                     amb_sem = ggdemetra3::trendcycle(amb.sem),\n                     amb_2step = ggdemetra3::trendcycle(amb.p2),\n                     amb_multi = ggdemetra3::trendcycle(amb.multi))\ndata_i &lt;- data.frame(x = x,\n                     mstl = c(forecast::remainder(mstl_mod)),\n                     amb_sem = ggdemetra3::irregular(amb.sem) + preaj,\n                     amb_2step = ggdemetra3::irregular(amb.p2) + preaj,\n                     # Ici on récupère i d'une autre façon car petit bug sur la version actuelle\n                     amb_multi = amb.multi$decomposition[[length(amb.multi$decomposition)]] + preaj)\ndata_s &lt;- data.frame(x = x,\n                     mstl = c(mstl_mod[, \"Seasonal48\"] + mstl_mod[, \"Seasonal336\"]),\n                     amb_sem = ggdemetra3::seasonal(amb.sem) ,\n                     amb_2step = ggdemetra3::seasonal(amb.p1) + ggdemetra3::seasonal(amb.p2),\n                     amb_multi = amb.multi$decomposition$s_48 +  amb.multi$decomposition$s_336)\n\nLes composantes saisonnières sont toutes proches :\n\ngraph_comp(data_s)\n\n\n\n\n\n\n\n\nMais plus de différences sur la tendance et l’irrégulier. La tendance est très erratique avec l’estimation en deux étapes et l’estimation de la saisonnalité hebdomadaire (amb_sem et amb_2step) :\n\nggplotly(graph_comp(data_t))\n\n\n\n\n\nÀ part pour le modèle amb_multi, les séries désaisonnalisées semblent proches. On observent notamment plusieurs pics à des fréquences qui semblent journalières ce qui peut amener à penser qu’il faudrait changer les paramètres.\n\nggplotly(graph_comp(data_sa))"
  },
  {
    "objectID": "manuel_installation.html",
    "href": "manuel_installation.html",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "",
    "text": "Pour utiliser JDemetra+ il faut deux logiciels : JDemetra+ et Java.\n\n\nJDemetra+ est téléchargeable depuis le lien github de l’application : https://github.com/jdemetra/jdemetra-app/releases (et la version 3 est disponible https://github.com/jdemetra/jdplus-main/releases). Deux solutions pour l’installer : télécharger le fichier .exe qui nécessite des droits d’administrateur ou télécharger le .zip qui permet d’avoir une version portable du logiciel.\nAttention : pour la seconde option ne pas télécharger le fichier Source code (zip) mais le fichier jdemetra+-2.2.2-bin.zip (pour la version 2.2.2) :\n\nUne fois le fichier téléchargé, il suffit de le dézipper : le logiciel se trouve alors dans le dossier \\nbdemetra\\bin\\, ce sont les fichiers nbdemetra.exe (version 32-bit) et nbdemetra64.exe (version 64-bit).\n\n\n\nPour utiliser la version 2.2.4 de JDemetra+ (et les packages R associés) il faut avoir la version 8 de Java (ou une version supérieure). Pour la version 3.0 de JDemetra+ (et les packages R associés) il faut avoir la version 17 de Java (ou une version supérieure) : nous utiliserons donc la version 17 de Java pour s’assurer une compatibilité avec tous les logiciels Si l’on a pas cette version d’installée et que l’on n’a pas les droits d’administrateur pour installer Java il faut alors installer une version portable de Java et lancer JDemetra+ avec cette version de java.\nPour installer une version portable de java, vous pouvez aller ici :\n\nZulu JDK\nAdoptOpenJDK\nAmazon Corretto\nOracle\n\nPour lancer JDemetra+ avec cette nouvelle version de Java il faut :\n\ncréer un raccourci vers l’application\n\nfaire un clique-droit sur le raccourci et ensuite cliquer sur « Propriétés ». Il reste alors à modifier la variable « Cible » en ajoutant le paramètre suivant : --jdkhome \"[chemin du dossier Java17]\".\n\nPar exemple, si JDemetra+ et Java sont installés sous D:\\Programmes\\, la variable Cible contiendra l’adresse D:\\Programmes\\nbdemetra\\bin\\nbdemetra64.exe --jdkhome \"D:\\Programmes\\Java17\".\nAttention : le chemin du raccourci est absolu, il doit donc être modifié à chaque fois qu’un des répertoires racines de JDemetra+ ou Java est déplacé."
  },
  {
    "objectID": "manuel_installation.html#installation-de-jdemetra-1",
    "href": "manuel_installation.html#installation-de-jdemetra-1",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "",
    "text": "JDemetra+ est téléchargeable depuis le lien github de l’application : https://github.com/jdemetra/jdemetra-app/releases (et la version 3 est disponible https://github.com/jdemetra/jdplus-main/releases). Deux solutions pour l’installer : télécharger le fichier .exe qui nécessite des droits d’administrateur ou télécharger le .zip qui permet d’avoir une version portable du logiciel.\nAttention : pour la seconde option ne pas télécharger le fichier Source code (zip) mais le fichier jdemetra+-2.2.2-bin.zip (pour la version 2.2.2) :\n\nUne fois le fichier téléchargé, il suffit de le dézipper : le logiciel se trouve alors dans le dossier \\nbdemetra\\bin\\, ce sont les fichiers nbdemetra.exe (version 32-bit) et nbdemetra64.exe (version 64-bit)."
  },
  {
    "objectID": "manuel_installation.html#jPort",
    "href": "manuel_installation.html#jPort",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "",
    "text": "Pour utiliser la version 2.2.4 de JDemetra+ (et les packages R associés) il faut avoir la version 8 de Java (ou une version supérieure). Pour la version 3.0 de JDemetra+ (et les packages R associés) il faut avoir la version 17 de Java (ou une version supérieure) : nous utiliserons donc la version 17 de Java pour s’assurer une compatibilité avec tous les logiciels Si l’on a pas cette version d’installée et que l’on n’a pas les droits d’administrateur pour installer Java il faut alors installer une version portable de Java et lancer JDemetra+ avec cette version de java.\nPour installer une version portable de java, vous pouvez aller ici :\n\nZulu JDK\nAdoptOpenJDK\nAmazon Corretto\nOracle\n\nPour lancer JDemetra+ avec cette nouvelle version de Java il faut :\n\ncréer un raccourci vers l’application\n\nfaire un clique-droit sur le raccourci et ensuite cliquer sur « Propriétés ». Il reste alors à modifier la variable « Cible » en ajoutant le paramètre suivant : --jdkhome \"[chemin du dossier Java17]\".\n\nPar exemple, si JDemetra+ et Java sont installés sous D:\\Programmes\\, la variable Cible contiendra l’adresse D:\\Programmes\\nbdemetra\\bin\\nbdemetra64.exe --jdkhome \"D:\\Programmes\\Java17\".\nAttention : le chemin du raccourci est absolu, il doit donc être modifié à chaque fois qu’un des répertoires racines de JDemetra+ ou Java est déplacé."
  }
]