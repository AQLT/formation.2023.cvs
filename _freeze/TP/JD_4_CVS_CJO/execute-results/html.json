{
  "hash": "6c4a4912ed5110311191ba93ba5f3a8f",
  "result": {
    "markdown": "---\ntitle: \"4 - Désaisonnalisation avec correction des jours ouvrables\"\neval: false\necho: true\n---\n\n\n# Importer les jeux de régresseurs « Jours Ouvrables » sous JDemetra+\n\n-   Cliquer sur l'onglet `Providers`\n\n-   Clic-droit sur `Spreadsheets`\n\n-   Cliquer sur `Open`\n\n-   Cliquer sur le bouton `…`\n\n-   Sélectionner le fichier Excel « [regcjo.xlsx](data/regcjo.xlsx) » contenant les régresseurs « Jours Ouvrables ».\n\n-   Cliquer sur `OK`\n\n-   Cliquer sur l'onglet `Workspace`\n\n-   Cliquer sur le `+` à côté d'`Utilities`\n\n-   Clic-droit sur `Variables`\n\n-   Cliquer sur `New`\n\n-   Cliquer sur le `+` à côté de `Variables`\n\n-   Double cliquer sur l'icône `Vars-1`\n\n-   Que se passe-t-il ?\n\n-   Retourner dans l'onglet `Providers`\n\n-   Faire glisser l'ensemble des séries du fichier « regcjo.xls » dans l'onglet `Vars-1`\n\n-   Renommer les séries en reprenant leur nom d'origine dans le fichier excel « regcjo.xls ».\n\nCe travail peut être très fastidieux... \nHeureusement depuis R il existe une solution plus automatique !\n\nIl existe deux façons de faire, en fonction de si l'on utilise une version 2.x.y ou 3.x.y de JDemetra+.\nRepartons déjà des régresseurs jours ouvrables (pour leur création, voir le [TP R associé](R_2_CJO.qmd)) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjd3toolkit)\nFR <- national_calendar(list(\n\tspecial_day(\"NEWYEAR\"),\n\tspecial_day(\"EASTERMONDAY\"), # Lundi de Pâques\n\tspecial_day(\"MAYDAY\"), # 1er mai\n\tspecial_day(\"ASCENSION\"), # Jour de l'Ascension\n\tfixed_day(5, 8),\n\tspecial_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n\tfixed_day(7, 14),\n\tspecial_day(\"ASSUMPTION\"), # Assomption\n\tspecial_day(\"ALLSAINTSDAY\"), # Toussaint\n\tspecial_day(\"ARMISTICE\")\n))\n\ngen_calendrier <- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n\tlength = (end[1] - start[1]) * frequency + end[2] - start[2]\n\tly <- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n\t\t\t\t\t\t\t\t   length = length)\n\t# N'hésitez pas à ajouter les votre !\n\tTD7 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 2, 3, 4, 5, 6, 0))\n\tTD4 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 2, 3, 0))\n\tTD3 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 1, 2, 0))\n\tTD3c <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t\tgroups = c(1, 1, 1, 1, 2, 2, 0))\n\tTD2 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 1, 0, 0))\n\tTD2c <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t\tgroups = c(1, 1, 1, 1, 1, 1, 0))\n\t\n\treg_jo <- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n\t\t\t\t start = start, frequency = frequency)\n\treg_jo <- ts.intersect(reg_jo,\n\t\t\t\t\t\t   ly)\n\tcolnames(reg_jo) <- c(\n\t\t\"TD2_semaine\",\n\t\t\"TD2c_lundi_samedi\",\n\t\tsprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n\t\tsprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n\t\tsprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n\t\tsprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n\t\t\"leap_year\")\n\treg_jo\n}\nregresseurs_JO_trim <- gen_calendrier(FR, frequency = 4)\nregresseurs_JO_mens <- gen_calendrier(FR, frequency = 12)\n\ncolnames(regresseurs_JO_trim) <- paste0(colnames(regresseurs_JO_trim), \"_trim\")\ncolnames(regresseurs_JO_mens) <- paste0(colnames(regresseurs_JO_mens), \"_mens\")\n```\n:::\n\n\n\n## JDemetra+ 2.x.y\n\nCi-dessous un code pour vous éviter de faire le travail manuel.\nIl est un peu peu compliqué mais une fois le code écrit, vous pouvez l'utiliser tel quel !\nVous pourrez ensuite repartir du workspace créé pour y ajouter vos propres séries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables <- function(liste_var, workspace){\n\tif(!is.mts(liste_var))\n\t\tstop(\"liste_var doit être de type mts\")\n\tcontext_dictionary <- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n\tts_variable_managers <- context_dictionary$getTsVariableManagers()\n\tts_variables <- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n\tjd_r_variables <- ts_variable_managers$get(\"r\")\n\tif (is.null(jd_r_variables)) {\n\t\tts_variable_managers$set(\"r\",\n\t\t\t\t\t\t\t\t .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n\t\tjd_r_variables <- ts_variable_managers$get(\"r\")\n\t}\n\tjd_var_names <- jd_r_variables$getNames()\n\t\n\tmodel_var_names <- colnames(liste_var)\n\t\n\tfor (i in seq_along(model_var_names)) {\n\t\tname <- model_var_names[i]\n\t\tdictionary_var <- jd_r_variables$get(name)\n\t\ttsvar <- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n\t\t\t\t\t   name, RJDemetra:::ts_r2jd(liste_var[, i]))\n\t\tif (is.null(dictionary_var)) {\n\t\t\tjd_r_variables$set(name, tsvar)\n\t\t} else {\n\t\t\twarning(sprintf(\"La variable %s existe déjà\", name))\n\t\t}\n\t}\n}\n\n# Création d'un nouveaux\njws <- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO_mens, jws)\ncomplete_variables(regresseurs_JO_trim, jws)\nsave_workspace(jws,\"workspace_CJO.xml\")\n```\n:::\n\n\n## JDemetra+ 3.x.y\n\nPour la version 3 de JDemetra+, le code est plus simple.\nVous pouvez également ajouter les calendriers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On va créer deux groupes de variables, on peut donc simplifier les noms\ncolnames(regresseurs_JO_mens) <- \n\tcolnames(regresseurs_JO_trim) <- \n\tgsub(\"_mens\", \"\", colnames(regresseurs_JO_mens))\nctxt <- rjd3toolkit::modelling_context(\n\t# on appelle \"FR\" le calendrier\n\tcalendars = list(FR = FR), \n\t# on crée un groupe de variables \"cjo_mens\" contenant les régresseurs mensuels\n\t# et un groupe de variables \"cjo_trim\" contenant les régresseurs trimestriels\n\tvariables = list(cjo_mens = regresseurs_JO_mens,\n\t\t\t\t\t cjo_trim = regresseurs_JO_trim)\n) \n\njws <- rjdemetra3::.jws_new(ctxt)\n# On peut également ajouter les calendriers et les variables avec les fonctions :\n# rjdemetra3:::add_variable()\n# rjdemetra3:::add_calendar()\nrjdemetra3::save_workspace(jws, \"workspace_CJO_v3.xml\")\n```\n:::\n\n\n# Créer une spécification incluant les jeux de régresseurs « jours ouvrables » personnalisés\n\n-   Cliquer sur l'onglet `Workspace`\n\n-   Double cliquer sur `Seasonal adjustment`\n\n-   Double cliquer sur `specifications`\n\n-   Double cliquer sur `x13`\n\n-   Clic-droit sur `RSA5c`\n\n-   Cliquer sur `Clone`\n\n-   Que se passe-t-il ?\n\n-   Double-cliquer sur `X13Spec-1`\n\n-   Cliquer sur le `+` à côté de `Calendar`\n\n-   Cliquer sur le `+` à côté de `tradingDays`\n\n-   Cliquer sur `Default` à côté de option\n\n-   Que se passe-t-il ?.\n\n-   Cliquer sur `UserDefined`\n\n-   Cliquer sur `Unused` à côté de `userVariables`\n\n-   Que se passe-t-il ?\n\n-   Faire passer les 6 régresseurs du jeu de régresseurs TD6 + leap_year de la gauche vers la droite\n\n-   Cliquer sur le bouton `Done`\n\n-   Cliquer sur `OK`\n\n# Réaliser une désaisonnalisation automatique de vos séries en utilisant la spécification X13Spec-1\n\nVoir [TP1](JD_1_Premiere_manipulation_JD.qmd).\n\n# Analyser les diagnostics relatifs à la correction des effets de calendrier\n\nPour chaque série, répondez aux questions suivantes :\n\n-   Y a-t-il eu une correction des effets de calendrier ?\n\n-   Si oui, est-ce que tous les coefficients associés aux régresseurs « JO » sont significativement différents de 0 ?\n\n-   Si non, essayer d'autres jeux de régresseurs « JO »\n\n-   Y a-t-il eu une correction de l'effet Pâques ?\n\n-   La série CVS-CJO présente-t-elle des effets « Jours Ouvrables » résiduels ?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}