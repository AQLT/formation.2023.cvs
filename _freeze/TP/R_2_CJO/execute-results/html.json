{
  "hash": "180f1ddb2828d698dbc62c13a85e14a8",
  "result": {
    "markdown": "---\ntitle: \"2 - Correction des jours ouvrables\"\n---\n\n\n\n\n\n> L'objectif de ce TP est d'apprendre à créer des régresseurs jours ouvrables personnalisés, à les utiliser dans RJDemetra/JDemetra+ et à vérifier la qualité de la correction.\n\nPour créer des régresseurs jours ouvrables personnalisés, deux solutions :\n\n1. Le faire depuis JDemetra+, en créant un calendrier personnalisé puis en exportant les régresseurs. \nVoir par exemple la documentation de JDemetra+ [ici](https://jdemetradocumentation.github.io/JDemetra-documentation/pages/case-studies/calendars-main.html) et [là](https://jdemetradocumentation.github.io/JDemetra-documentation/pages/case-studies/calendars-national.html).\n\n2. Créer le calendrier depuis R à l'aide du package [`rjd3toolkit`](https://github.com/rjdemetra/rjd3toolkit).\n\n\nCe package n'étant pas sur le CRAN, pour les installer on peut par exemple utiliser la fonction `remotes::install_github()` :\n\n::: {.cell}\n\n```{.r .cell-code}\n# # Configurer si besoin le proxy\n# proxy <- \"proxy_a_definir\"\n# Sys.setenv(HTTPS_PROXY = proxy)\nremotes::install_github(\"rjdemetra/rjd3toolkit\",\n\t\t\t\t\t\tINSTALL_opts = \"--no-multiarch\")\n```\n:::\n\n\nDans ce TP, nous nous intéresserons uniquement à la seconde option. \nEn effet, le package R est plus flexible et permet de créer des régresseurs moins classiques que les *working days* et *trading days*. \n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages_to_install <- c(\"RJDemetra\", \"remotes\")\n\npackages <- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) > 0) {\n\tinstall.packages(packages)\n}\npackages_to_install_git <- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git <- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) > 0) {\n\t# # Configurer si besoin le proxy\n\t# proxy <- \"proxy_a_definir\"\n\t# Sys.setenv(HTTPS_PROXY = proxy)\n\tremotes::install_github(\n\t\tsprintf(\"rjdemetra/%s\", packages_git),\n\t\t# option utile dans certaines installations portables de Java :\n\t\tINSTALL_opts = \"--no-multiarch\")\n}\n```\n:::\n\n\n\n# Création de régresseurs JO avec `rjd3toolkit`\n\n## Création d'un calendrier \n\nPar défaut, les régresseurs jours ouvrables de JDemetra+ ne prennent pas en compte les spécificité calendaires des pays : on ne prend pas en compte les jours fériés. \nPour les prendre en compte, il faut créer son propre calendrier où l'on supposera qu'un jour férié de plus dans le mois a le même effet qu'un dimanche.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjd3toolkit)\n```\n:::\n\n\nTrois fonctions peuvent être utilisées pour ajouter des jours fériés :\n\n1. `fixed_day()` pour ajouter un jour férié qui tombe à date fixe. Par exemple, pour ajouter le 8 mai :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_day(month =  5, day = 8)\n```\n:::\n\n\n2. `easter_day()` pour ajouter un jour férié dont le jour dépend de Pâques : le paramètre `offset` permet de spécifier le nombre de jours avant (si négatif) ou après Pâques (si positif). Par exemple, pour ajouter la Pentecôte qui a lieu 60 jours après Pâques :\n\n\n::: {.cell}\n\n```{.r .cell-code}\neaster_day(offset = 60)\n```\n:::\n\n\n3. `single_day()` pour ajouter un jour ferié qui n'a eu lieu qu'une seule fois.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsingle_day(\"1993-01-15\")\n```\n:::\n\n\n4. `fixed_week_day()` qui permet d'ajouter des jours fériés qui apparaissent certaines semaines de certains mois (par exemple le premier lundi du mois de septembre aux USA)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_week_day(9, 1, 1) # first Monday(1) of September.\n```\n:::\n\n\n\n5. `special_day()` qui permet d'ajouter des jours fériés par rapport à des dates déjà connues dans JDemetra+ (voir tableau ci-dessous). Comme pour la fonction `easter_day()`, le paramètre `offset` permet de spécifier la position du jour voulu par rapport rapport à la fête pré-spécifié (par défaut `offset = 0`, le jour férié coïncide avec le jour pré-spécifié). Par exemple, pour ajouter le nouvel an :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecial_day(\"NEWYEAR\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-paper lightable-hover\" style='font-family: \"Arial Narrow\", arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n<caption>Jours pré-spécifiés</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Event </th>\n   <th style=\"text-align:left;\"> Définition </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> NEWYEAR </td>\n   <td style=\"text-align:left;\"> Fête fixe, 1er janvier. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SHROVEMONDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, lundi avant le mecredi des cendres (48 jours avant pâques). </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SHROVETUESDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, mardi avant le mecredi des cendres (47 jours avant pâques). </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ASHWEDNESDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, 46 jours avant Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> EASTER </td>\n   <td style=\"text-align:left;\"> Fête mobile, Pâques, varie entre le 22 mars et le 25 avril. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MAUNDYTHURSDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, le jeudi avant Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> GOODFRIDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, le vendredi avant Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> EASTERMONDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, le lendemain de Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ASCENSION </td>\n   <td style=\"text-align:left;\"> Fête mobile, célébrée un jeudi, 40 jours après Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PENTECOST </td>\n   <td style=\"text-align:left;\"> Fête mobile, 50 jours après Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CORPUSCHRISTI </td>\n   <td style=\"text-align:left;\"> Fête mobile, 60 jours après Pâques. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> WHITMONDAY </td>\n   <td style=\"text-align:left;\"> Fête mobile, le jour après la Pentecôte. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MAYDAY </td>\n   <td style=\"text-align:left;\"> Fête fixe, 1er mai. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ASSUMPTION </td>\n   <td style=\"text-align:left;\"> Fête fixe, 15 août. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> HALLOWEEN </td>\n   <td style=\"text-align:left;\"> Fête fixe, 31 octobre. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ALLSAINTSDAY </td>\n   <td style=\"text-align:left;\"> Fête fixe, 1er novembre. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ARMISTICE </td>\n   <td style=\"text-align:left;\"> Fête fixe, 11 novembre. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CHRISTMAS </td>\n   <td style=\"text-align:left;\"> Fête fixe, 25 décembre. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n::: callout-note\n## Exercice\nCréer un calendrier qui contient tous les jours fériés de la France.\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nFR <- national_calendar(list(\n\tspecial_day(\"NEWYEAR\"),\n\tspecial_day(\"EASTERMONDAY\"), # Lundi de Pâques\n\tspecial_day(\"MAYDAY\"), # 1er mai\n\tspecial_day(\"ASCENSION\"), # Jour de l'Ascension\n\tfixed_day(5, 8),\n\tspecial_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n\tfixed_day(7, 14),\n\tspecial_day(\"ASSUMPTION\"), # Assomption\n\tspecial_day(\"ALLSAINTSDAY\"), # Toussaint\n\tspecial_day(\"ARMISTICE\")\n))\n```\n:::\n\n:::\n\n\n\n## Création de régresseurs JO\n\nLe modèle général de correction de jours ouvrables peut s'écrire de la façon suivante :\n$$\nX_t = \\sum_{i=1}^{7} \\alpha_i N_{it} + \\varepsilon_t\n$$\nAvec : \n\n- $N_{it}$ le nombre de jours de lundis ($i=1$), ..., dimanches et jours fériés ($i=7$)\n\n- $\\alpha_i$ l'effet d'un jour de type $i$\n\nPour éviter les problèmes de multi-colinéarité, on réécrit le modèle en utilisant une modalité de référence (ici dimanche). On désaisonnalise également les régresseurs en enlevant la moyenne de long-terme :\n$$X_t =  \\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) + \n\\bar{\\alpha} \\underbrace{(N_t - \\bar{N}_t)}_{LY_t} +  \\varepsilon_t$$\nCe modèle peut être simplifié si en faisant des hypothèses sur les effets des jours ouvrés :\n\n- L'hypothèse *working days* correspond au cas où l'on suppose que tous les jours de la semaine (lundi à vendredi) ont le même effet ($\\alpha_1=\\dots=\\alpha_5$), les samedis et les dimanches (et jours fériés) ont le même effet ($\\alpha_6=\\alpha_7$) et sont utilisés en tant que variable de contraste.\n\n- L'hypothèse *trading days* correspond au cas où l'on suppose que tous les jours ont un effet différent et les dimanches (et jours fériés) sont utilisés en tant que variable de constrate.\n\nSous JDemetra+ on ne peut utiliser que ces deux hypothèses mais `rjd3toolkit` permet de construire d'autres types de JO.\n\n\nDe manière plus générale, lorsque l'on utilise une variable de contraste, les régresseurs $CJO_{t,i}$ associé au groupe $i$ est calculé de la façon suivante :\n$$\nCJO_{t,i} = \\underbrace{\\sum_{j\\in\\text{groupe }i}N_{jt}}_{\n\\text{nb de jours du groupe }i\n} - \n\\frac{\\sum_{j\\in\\text{groupe }i}1}{\\sum_{j\\in\\text{groupe }0}1}\n\\times\n\\underbrace{\\sum_{j\\in\\text{groupe }0}N_{jt}}_{\n\\text{nb de jours du groupe contraste}\n}\n$$\nDans le cas *working days*, il y a 2 jours dans le groupe contraste (samedi et dimanche, $\\sum_{j\\in\\text{groupe }0}1=2$) et 5 jours dans le groupe 1 (lundi à vendredi, $\\sum_{j\\in\\text{groupe }1}1=5$). \nAu mois $t$, le régresseurs JO type de jours est donc égal au nombre de jours de la semaine dans le mois, mois $5/2\\times$ nombre de jours de week-end.\n\n\nLes régresseurs JO peuvent être créés à partir de 2 fonctions : `htd()` qui permet de les créer à partir d'un calendrier spécifique et `td()`. \nDans ces fonctions, le paramètre le plus important est `groups` pour permet de faire des hypothèses sur les jours. \nC'est un vecteur de longueur 7 (le nombre de jours de la semaine) dont chaque élément indique à quel groupe le jour de la semaine associé correspond. \nLa variable de contraste est associé au groupe 0.  \nPar exemple, `groups = c(1,2,3,4,5,6,0)` correspond au *trading days* et `groups = c(1,1,1,1,1,0,0)` correspond au *working days*.\n\nPar exemple :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- c(1, 2, 3, 4, 5, 6, 0)\nfrequency <- 12\nstart <- c(2000,1)\nwkd <- calendar_td(FR, frequency = frequency, start = start, length = 12*35,\n\t\t\t\t   groups = groups)\nwkd <- ts(wkd, start = start, frequency = frequency)\n```\n:::\n\n\n\n::: callout-note\n## Exercice\nComparer le régresseurs JO *working days* créé avec le calendrier français et celui sans hypothèse sur les jours fériés (fonction `td()`).\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- c(1, 1, 1, 1, 1, 0, 0)\nfrequency <- 12\nstart <- c(2000,1)\nwkd <- calendar_td(FR, frequency = frequency, start = start, length = 12*35,\n\t\t\t\t   groups = groups)\nwkd <- ts(wkd, start = start, frequency = frequency)\nwkd_def <- td(frequency = frequency, start = start, length = 12*35,\n\t\t\t  groups = groups)\nwkd_def <- ts(wkd_def, start = start, frequency = frequency)\ndata <- ts.union(wkd, wkd_def)\nplot(data, col = c(\"orange\",\"black\"),\n\t plot.type = \"single\")\n```\n\n::: {.cell-output-display}\n![](R_2_CJO_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n:::\n\n\n## Régresseur *leap year*\n\n\nLe régresseur année bissextile (*leap year*), $LY_t$ doit être créé à la main. \nIl est égal à la différence entre le nombre de jours dans le mois $t$ et le nombre de jours moyens dans le mois $t$, $\\bar N_t$. \nTous les mois ont le même nombre de jours, sauf le mois de février qui est de 29 jours tous les 4 ans. \n$\\bar N_t$ est donc égal à 30 ou 31 si le mois considéré n'est pas un mois de février (et donc $N_t - \\bar N_t=0$) à 28,25 en février^[\nEn réalité, la vraie valeur est 28,2425. En effet, une année bissextile est une année divisible par 4 mais pas par 100, sauf si elle est divisible par 400 : 1900 n'était pas une année bissextile mais 2000 l'était !\n].\n$$\nLY_{t} =\n\\begin{cases}\n0,75 & \\mbox{si } t \\mbox{ est un mois de février bissextil } \\\\\n-0,25 & \\mbox{si } t \\mbox{ est un mois de février non bissextil } \\\\\n0 & \\mbox{sinon}\n\\end{cases}\n$$\n\n\n::: callout-note\n## Exercice\nCréer une fonction `leap_year` qui permet de générer le régresseur *leap year*.\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nleap_year <- function(start = 1990, end = 2030, frequency = 12){\n\tly <- ts(0, start = start, end = end, frequency = 12)\n\tmois_feb <- cycle(ly) == 2\n\tannees <- trunc(round(time(ly), 3)) # arrondi car parfois des pbs avec fonction time\n\t# On utilise la définition exacte\n\tis_ly <- (annees %% 400 == 0) |\n\t\t((annees %% 4 == 0) & (annees %% 100 != 0))\n\tly[mois_feb] <- 28 - 28.2425\n\tly[mois_feb & is_ly] <- 29 - 28.2425\n\t# on change si besoin la fréquence\n\tstats::aggregate(ly, nfrequency = frequency) \n}\nleap_year(frequency = 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Jan     Feb     Mar     Apr     May     Jun     Jul     Aug     Sep\n1990  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1991  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1992  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1993  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1994  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1995  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1996  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1997  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1998  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1999  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2000  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2001  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2002  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2003  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2004  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2005  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2006  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2007  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2008  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2009  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2010  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2011  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2012  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2013  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2014  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2015  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2016  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2017  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2018  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2019  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2020  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2021  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2022  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2023  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2024  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2025  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2026  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2027  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2028  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2029  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2030  0.0000                                                                \n         Oct     Nov     Dec\n1990  0.0000  0.0000  0.0000\n1991  0.0000  0.0000  0.0000\n1992  0.0000  0.0000  0.0000\n1993  0.0000  0.0000  0.0000\n1994  0.0000  0.0000  0.0000\n1995  0.0000  0.0000  0.0000\n1996  0.0000  0.0000  0.0000\n1997  0.0000  0.0000  0.0000\n1998  0.0000  0.0000  0.0000\n1999  0.0000  0.0000  0.0000\n2000  0.0000  0.0000  0.0000\n2001  0.0000  0.0000  0.0000\n2002  0.0000  0.0000  0.0000\n2003  0.0000  0.0000  0.0000\n2004  0.0000  0.0000  0.0000\n2005  0.0000  0.0000  0.0000\n2006  0.0000  0.0000  0.0000\n2007  0.0000  0.0000  0.0000\n2008  0.0000  0.0000  0.0000\n2009  0.0000  0.0000  0.0000\n2010  0.0000  0.0000  0.0000\n2011  0.0000  0.0000  0.0000\n2012  0.0000  0.0000  0.0000\n2013  0.0000  0.0000  0.0000\n2014  0.0000  0.0000  0.0000\n2015  0.0000  0.0000  0.0000\n2016  0.0000  0.0000  0.0000\n2017  0.0000  0.0000  0.0000\n2018  0.0000  0.0000  0.0000\n2019  0.0000  0.0000  0.0000\n2020  0.0000  0.0000  0.0000\n2021  0.0000  0.0000  0.0000\n2022  0.0000  0.0000  0.0000\n2023  0.0000  0.0000  0.0000\n2024  0.0000  0.0000  0.0000\n2025  0.0000  0.0000  0.0000\n2026  0.0000  0.0000  0.0000\n2027  0.0000  0.0000  0.0000\n2028  0.0000  0.0000  0.0000\n2029  0.0000  0.0000  0.0000\n2030                        \n```\n:::\n\n```{.r .cell-code}\n# ou rjd3toolkit::lp_variable()\n```\n:::\n\nOn peut également uiliser la fonction `rjd3toolkit::ts_adjust()` pour préajuster de l'effet année bissextile.\n:::\n\n## Exercice bilan\n\n::: callout-note\n## Exercice\nCréer un objet `regresseurs_JO` qui contiendra tous les jeux de régresseurs plausibles. Par exemple :\n\n- le régresseur *leap year*\n\n- le jeu de régresseur *trading days* (`TD7`, lundi à samedi, dimanche = contraste)\n\n- le jeu de régresseur *working days* (`TD2`, lundi =... = vendredi, samedi=dimanche=contraste)\n\n- le jeu `TD3` : lundi = ... = vendredi, samedi et dimanche = contraste\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\nLa solution montre comment créer tous les régresseurs de JDemetra+ 3.0.0\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency <- 12\n\ngen_calendrier <- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n\tlength = (end[1] - start[1]) * frequency + end[2] - start[2]\n\tly <- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n\t\t\t\t\t\t\t\t   length = length)\n\t# N'hésitez pas à ajouter les votre !\n\tTD7 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 2, 3, 4, 5, 6, 0))\n\tTD4 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 2, 3, 0))\n\tTD3 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 1, 2, 0))\n\tTD3c <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t\tgroups = c(1, 1, 1, 1, 2, 2, 0))\n\tTD2 <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t   groups = c(1, 1, 1, 1, 1, 0, 0))\n\tTD2c <- calendar_td(cal, frequency = frequency, start = start, length = length,\n\t\t\t\t\t\tgroups = c(1, 1, 1, 1, 1, 1, 0))\n\t\n\treg_jo <- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n\t\t\t\t start = start, frequency = frequency)\n\treg_jo <- ts.intersect(reg_jo,\n\t\t\t\t\t\t   ly)\n\tcolnames(reg_jo) <- c(\n\t\t\"TD2_semaine\",\n\t\t\"TD2c_lundi_samedi\",\n\t\tsprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n\t\tsprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n\t\tsprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n\t\tsprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n\t\t\"leap_year\")\n\treg_jo\n}\nregresseurs_JO <- gen_calendrier(FR, frequency = 12)\n```\n:::\n\n:::\n\n\n## Effet graduel de Pâques\n\nPrenons l'exemple de la vente de chocolats. \nIl est assez commun d'offrir des chocolats à Pâques\\ : il y a donc une hausse des ventes autour du lundi de Pâques. \nToutefois, ces ventes ne se font pas le jour de Pâques mais plusieurs jours avant, et plus on se rapproche du jour J, plus ces ventes sont importantes. \nC'est ce que l'on appel l'**effet graduel de Pâques**. \nSous JDemetra+ on peut définir le nombre de jours avant Pâques pour lequel on considère qu'il y a un effet (`easter_day.duration`, entre 1 et 20) ou laisser ce choix à JDemetra+. \n\n\n::: callout-note\n## Exercice\nSerait-il pertinent de considérer un effet graduel de Noël dans le modèle Reg-ARIMA ?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nNon car l'effet graduel de Noël est en fait saisonnier car c'est un jour fixe ! \nPour Pâques, comme c'est une fête mobile, les jours précédents peuvent être dans des mois différents en fonction de l'année considérée. \nJe ne suis pas entré dans les détails mais le régresseur utilisé pour la correction de l'effet graduel de Pâques est désaisonnalisé pour ne prendre en compte que l'effet voulu\n:::\n\nLe régresseur associé à l'effet graduel de Pâques peut être généré en utilisant la fonction `rjd3toolkit::easter_variable()`.\n\n\n# Utilisation des régresseurs dans `RJDemetra` {#sec-rjd}\n\nDans `RJDemetra`, pour utiliser nos régresseurs jours ouvrables personnalisés, il faut créer sa propre spécification (fonctions `x13_spec()` ou `regarima_spec_x13()`) en utilisant l'option `usrdef.varEnabled = TRUE`, en spécifiant les régresseurs dans `usrdef.var` et indiquant que les régresseurs sont des régresseurs calendaires avec l'option `usrdef.varType = \"Calendar\"`. \nPar exemple : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RJDemetra)\nipi_fr <- ipi_c_eu[, \"FR\"]\n# On arrête la série en décembre 2019 pour éviter les changements de résultats\n# liés aux futures actualisation des données de RJDemetra\nipi_fr <- window(ipi_fr, end = c(2019, 12))\n# on garde le jeu reg6\nwkd <- regresseurs_JO[,c(grep(\"TD7\", colnames(regresseurs_JO), value = TRUE),\n\t\t\t\t\t\t \"leap_year\")]\n# Pour simplifier l'output, on enlève le \"TD7_\"\n# mais ce n'est pas obligatoire\ncolnames(wkd) <- gsub(\"TD7_\", \"\", colnames(wkd))\nmyspec1 <- regarima_spec_x13(spec = \"RG5c\",\n\t\t\t\t\t\t\t usrdef.varEnabled = TRUE,\n\t\t\t\t\t\t\t usrdef.var = wkd,\n\t\t\t\t\t\t\t usrdef.varType = \"Calendar\",\n\t\t\t\t\t\t\t easter.enabled = FALSE)\nmyreg1 <- regarima(ipi_fr, myspec1)\nsummary(myreg1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2019\nLog-transformation: yes\nRegression model: no mean, trading days effect(7), no leap year effect, no Easter effect, outliers(2)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(>|t|)    \nTheta(1)  -0.49684    0.04765 -10.43   <2e-16 ***\nBTheta(1) -0.63951    0.04259 -15.01   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n              Estimate Std. Error  T-stat Pr(>|t|)    \nlundi         0.003597   0.001232   2.920 0.003727 ** \nmardi         0.009278   0.001378   6.735 6.82e-11 ***\nmercredi      0.005957   0.001403   4.246 2.80e-05 ***\njeudi         0.011928   0.001463   8.154 6.66e-15 ***\nvendredi      0.005258   0.001427   3.686 0.000264 ***\nsamedi       -0.014409   0.001289 -11.176  < 2e-16 ***\nleap_year     0.020025   0.005427   3.690 0.000260 ***\nLS (11-2008) -0.080465   0.014119  -5.699 2.58e-08 ***\nLS (1-2009)  -0.070533   0.014138  -4.989 9.62e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 0.01707 on 335 degrees of freedom\nLog likelihood = 916.7, aic =  1396, aicc =  1397, bic(corrected for length) = -7.955\n```\n:::\n:::\n\n\n::: {.callout-warning}\n## Pour information\nPour ne pas repartir de zéro et avoir des modèles, il y a sous JDemetra+ 13 spécifications pré-définies décrites [ici](/PDF/Predefined_specifications.pdf) ou dans l'aide des fonction RJDemetra associés (`?regarima`, `?x13` ou `?tramoseats`).\n:::\n\nPour faire des tests multiples sur les régresseurs jours ouvrables, on peut utiliser la fonction `car::linearHypothesis()`. \nDans le modèle précédent, il parait clair que les régresseurs jours ouvrables sont significatifs. \nToutefois, on peut se demander, si par parcimonie on peut simplifier le modèle en regroupant les jours de la semaine :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(car)\nlinearHypothesis(myreg1,\n\t\t\t\t c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"),\n\t\t\t\t c(0, 0, 0, 0, 0, 0), test = \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear hypothesis test\n\nHypothesis:\nlundi = 0\nmardi = 0\nmercredi = 0\njeudi = 0\nvendredi = 0\nsamedi = 0\n\nModel 1: restricted model\nModel 2: myreg1\n\n  Res.Df Df      F    Pr(>F)    \n1    341                        \n2    335  6 207.82 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\nlinearHypothesis(myreg1,\n\t\t\t\t c(\"lundi = mardi\",\"mardi = mercredi\",\"mercredi = jeudi\",\"jeudi = vendredi\"), test = \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear hypothesis test\n\nHypothesis:\nlundi - mardi = 0\nmardi - mercredi = 0\nmercredi - jeudi = 0\njeudi - vendredi = 0\n\nModel 1: restricted model\nModel 2: myreg1\n\n  Res.Df Df      F    Pr(>F)    \n1    339                        \n2    335  4 4.9866 0.0006461 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\n::: callout-note\n## Exercice\nEssayez maintenant sur vos propres séries.\nTester de laisser ou non l'effet graduel de Pâques (`easter.enabled = TRUE`).\n:::\n\n# Utilisation des régresseurs dans `rjdemetra3` {#sec-rjd2}\n\nDans `rjdemetra3`, pour utiliser nos régresseurs jours ouvrables personnalisés, il faut :\n\n1. créer sa propre spécification (fonctions `rjd3x13::x13_spec()` ou `rjd3x13::regarima_spec`)\n\n2. ajouter les régresseurs dans le contexte grâce au paramètre `context` de `rjd3x13::x13()` et avec la fonction `rjd3toolkit::modelling_context()`\n\n3. modifier la spécification avec la fonction `rjd3toolkit::set_tradingdays()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr <- RJDemetra::ipi_c_eu[, \"FR\"]\nctxt <- rjd3toolkit::modelling_context(\n\t# on crée un groupe de variables \"cjo\" contenant les régresseurs\n\tvariables = list(cjo = regresseurs_JO)\n) \n\nspec1_jd3 <- rjd3x13::spec_regarima(\"rg5c\") |> \n\trjd3toolkit::set_tradingdays(\n\t\toption = \"UserDefined\",\n\t\tuservariable = paste0(\"cjo.\", c(grep(\"TD7\", colnames(regresseurs_JO), value = TRUE),\n\t\t\t\t\t\t\t\t\t\t\"leap_year\"))\n\t)\nreg1_jd3 <- rjd3x13::regarima(ipi_fr, spec1_jd3, ctxt)\nsummary(reg1_jd3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog-transformation: no \nSARIMA model:  (0,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error T-stat Pr(>|t|)    \ntheta(1)  -0.51202    0.04678 -10.95   <2e-16 ***\nbtheta(1) -0.55596    0.05261 -10.57   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                 Estimate Std. Error  T-stat Pr(>|t|)    \ncjo.TD7_lundi      0.3291     0.1342   2.453 0.014659 *  \ncjo.TD7_mardi      0.9651     0.1423   6.781 5.21e-11 ***\ncjo.TD7_mercredi   0.5998     0.1454   4.125 4.65e-05 ***\ncjo.TD7_jeudi      1.1245     0.1533   7.334 1.60e-12 ***\ncjo.TD7_vendredi   0.5439     0.1478   3.681 0.000270 ***\ncjo.TD7_samedi    -1.4565     0.1335 -10.913  < 2e-16 ***\ncjo.leap_year      1.9840     0.5456   3.637 0.000318 ***\neaster            -1.1814     0.3735  -3.164 0.001697 ** \nLS (2008-11-01)   -8.8340     1.4826  -5.958 6.29e-09 ***\nLS (2009-01-01)   -7.0031     1.4846  -4.717 3.48e-06 ***\nAO (2020-03-01)  -20.8423     1.8064 -11.538  < 2e-16 ***\nTC (2020-04-01)  -37.3780     1.8870 -19.809  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations:  372 , Number of effective observations:  359 , Number of parameters:  15 \nLoglikelihood:  -731.5383\nStandard error of the regression (ML estimate):  1.844427 \nAIC:  1493.077 , AICc:  1494.476 , BIC:  1551.326 \n```\n:::\n:::\n\n\nUne autre façon de faire est d'ajouter le calendrier de la France comme calendrier par défaut, ce qui permet de garder les options de JDemetra+ comme le préajustement de l'effet *leap-year* ou la sélection automatique des jeux de régresseurs.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctxt <- rjd3toolkit::modelling_context(\n\t# on appelle \"FR\" le calendrier\n\tcalendars = list(FR = FR), \n\t# on crée un groupe de variables \"cjo\" contenant les régresseurs\n\tvariables = list(cjo = regresseurs_JO)\n) \n\nspec2_jd3 <- rjd3x13::spec_regarima(\"rg5c\") |> \n\trjd3toolkit::set_tradingdays(\n\t\tcalendar.name = \"FR\"\n\t)\nreg2_jd3 <- rjd3x13::regarima(ipi_fr, spec2_jd3, ctxt)\nsummary(reg2_jd3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog-transformation: no \nSARIMA model:  (0,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error T-stat Pr(>|t|)    \ntheta(1)  -0.51202    0.04678 -10.95   <2e-16 ***\nbtheta(1) -0.55596    0.05261 -10.57   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                Estimate Std. Error  T-stat Pr(>|t|)    \nmonday            0.3291     0.1342   2.453 0.014659 *  \ntuesday           0.9651     0.1423   6.781 5.21e-11 ***\nwednesday         0.5998     0.1454   4.125 4.65e-05 ***\nthursday          1.1245     0.1533   7.334 1.60e-12 ***\nfriday            0.5439     0.1478   3.681 0.000270 ***\nsaturday         -1.4565     0.1335 -10.913  < 2e-16 ***\nlp                1.9840     0.5456   3.637 0.000318 ***\neaster           -1.1814     0.3735  -3.164 0.001697 ** \nLS (2008-11-01)  -8.8340     1.4826  -5.958 6.29e-09 ***\nLS (2009-01-01)  -7.0031     1.4846  -4.717 3.48e-06 ***\nAO (2020-03-01) -20.8423     1.8064 -11.538  < 2e-16 ***\nTC (2020-04-01) -37.3780     1.8870 -19.809  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations:  372 , Number of effective observations:  359 , Number of parameters:  15 \nLoglikelihood:  -731.5383\nStandard error of the regression (ML estimate):  1.844427 \nAIC:  1493.077 , AICc:  1494.476 , BIC:  1551.326 \n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nPourquoi les deux modèles sont différents ?\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nLe modèle étant multiplicatif, la série est pré-ajustée de l'effet année bissextile, ce qui fait que le régresseur n'est pas utilisé !\n:::\n\nPour faire des tests multiples sur les régresseurs jours ouvrables, on peut utiliser la fonction `car::linearHypothesis()`. \nDans le modèle précédent, il parait clair que les régresseurs jours ouvrables sont significatifs. \nToutefois, on peut se demander, si par parcimonie on peut simplifier le modèle en regroupant les jours de la semaine :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(car)\nlinearHypothesis(reg2_jd3,\n\t\t\t\t c(\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"),\n\t\t\t\t c(0, 0, 0, 0, 0, 0), test = \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear hypothesis test\n\nHypothesis:\nmonday = 0\ntuesday = 0\nwednesday = 0\nthursday = 0\nfriday = 0\nsaturday = 0\n\nModel 1: restricted model\nModel 2: reg2_jd3\n\n  Res.Df Df      F    Pr(>F)    \n1    350                        \n2    344  6 172.69 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\n\n# Test de la présence de jours ouvrables résiduels\n\nUn point important lorsque le fait de la correction de jours ouvrables est de tester s'il reste un effet jour ouvrable après la correction.\nLa fonction `rjd3toolkit::td_f()` peut aider à le faire.\n\nGénéralement ce test est effectué après la décomposition, sur la composante désaisonnalisée ou sur l'irrégulier. \nPlutôt que la fonction `regarima` on va utiliser la fonction `x13` qui effectue la décomposition sur la série linéarisée. \nCes tests sont disponibles dans le sous-objet `.$diagnostics` (`\"f-test on sa (td)\"` et `\"f-test on i (td)\"`) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyspec1_sa <- x13_spec(spec = \"RSA5c\",\n\t\t\t\t\t   usrdef.varEnabled = TRUE,\n\t\t\t\t\t   usrdef.var = wkd,\n\t\t\t\t\t   usrdef.varType = \"Calendar\",\n\t\t\t\t\t   easter.enabled = FALSE)\nmysa <- x13(ipi_fr, myspec1_sa)\n# On retrouve d'ailleurs la partie regarima\n# summary(mysa$regarima)\nmysa$diagnostics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.931\n Seasonal     51.386\n Irregular     0.564\n TD & Hol.     2.828\n Others       43.502\n Total       100.212\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.021\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          1.000\n qs test on i                           1.000\n f-test on sa (seasonal dummies)        0.999\n f-test on i (seasonal dummies)         0.997\n Residual seasonality (entire series)   1.000\n Residual seasonality (last 3 years)    0.999\n f-test on sa (td)                      0.001\n f-test on i (td)                       0.001\n```\n:::\n:::\n\n\nSous JDemetra+, les tests affichés portent sur les 8 dernières années et dans RJDemetra sur la série entière ! Pour reproduire les résultats de JDemetra+, utiliser la fonction `rjd3toolkit::td_f()`. \nPour le test, six spécifications différentes sont possibles :\n\n1. Par défaut sous JDemetra+ et `model = \"R100\"` sous `rjd3toolkit`\n$$\ny_t=c + \\alpha y_{t-1} + \\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +  \\varepsilon_t\n$$\n\n2. `model = \"D1\"` \n$$\n\\Delta y_t - \\overline{\\Delta y}  =\\sum_{i=1}^{6} \\beta_i \\Delta(N_{it} - N_{7t}) +  \\varepsilon_t\n$$\n\n3. `model = \"DY\"` \n$$\n\\Delta_s y_t - \\overline{\\Delta_s y}  =\\sum_{i=1}^{6} \\beta_i \\Delta_s(N_{it} - N_{7t}) +  \\varepsilon_t\n$$\n\n4. `model = \"D1DY\"` \n$$\n\\Delta_s \\Delta y_t - \\overline{\\Delta_s \\Delta y}  =\\sum_{i=1}^{6} \\beta_i \\Delta_s\\Delta(N_{it} - N_{7t}) +  \\varepsilon_t\n$$\n5. `model = \"AIRLINE\"`\n$$\ny_t =\\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +  \\varepsilon_t\\text{ avec }\\varepsilon_t\\sim ARIMA(0,1,1)(0,1,1)\n$$\n\n6. `model = \"R011\"`\n$$\ny_t =\\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +  \\varepsilon_t\\text{ avec }\\varepsilon_t\\sim ARIMA(0,1,1)\n$$\n\n7. `model = \"WN\"`\n$$\ny_t - \\bar y =\\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +  \\varepsilon_t\n$$\n\navec $y_t$ pris en logarithme si le schéma est multiplicatif. \nDans tous les cas $(H_0):\\beta_1=\\dots = \\beta_6=0$ et les régresseurs utilisés ne prennent pas en compte le calendrier personnalisé que l'on a créé !\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjd3toolkit)\nsa <- mysa$final$series[,\"sa\"]\ni <- mysa$final$series[,\"i\"]\nif (mysa$regarima$model$spec_rslt[,\"Log transformation\"]) {\n\tsa <- log(sa)\n\ti <- log(i)\n}\nrjd3toolkit::td_f(sa, nyears = 8, model = \"R100\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue:  1.279144 \nP-Value:  0.2751 \n```\n:::\n\n```{.r .cell-code}\nrjd3toolkit::td_f(i, nyears = 8, model = \"R100\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue:  1.210807 \nP-Value:  0.3084 \n```\n:::\n\n```{.r .cell-code}\n# Résultats différents sur l'ensemble de la série\nrjd3toolkit::td_f(sa, nyears = 0, model = \"R100\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue:  3.229296 \nP-Value:  0.0042 \n```\n:::\n\n```{.r .cell-code}\nrjd3toolkit::td_f(i, nyears = 0, model = \"R100\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue:  2.703662 \nP-Value:  0.0140 \n```\n:::\n:::\n\n\nEn réalité les tests affichés dans JDemetra+ et RJDemetra ne sont pas effectuées sur les composantes \"finales\" de l'irrégulier et la série désaisonnalisée, mais sur les composantes issues de X-11 avant ajout des points atypiques du préajustement.\nPour X-13-ARIMA ces séries ne pour l'instant pas facilement exportables (et ce n'est sûrement pas possible de l'exporter depuis JDemetra+), mais heureusement pour vous, il existe une \"solution\"^[\nVous remarquerez que le résultat est différent de celui affiché dans JDemetra+ : cela vient de la méthode d'estimation utilisée !\n] :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract_sa_cmp <- function(x, comp = \"sa\", forecast = FALSE){\n\t# valeurs possibles pour comp : y, t, sa, s, i\n\tjmodel <- suppressWarnings(jx13(get_ts(x), x13_spec(x)))\n\tjres <- jmodel$result@internal$getResults()\n\tjres <- new(Class = \"X13_java\", internal = jres)\n\tif (forecast) {\n\t\ts_forecast = \"_f\"\n\t} else {\n\t\ts_forecast = \"\"\n\t}\n\tRJDemetra:::result(jres,\n\t\t\t\t\t   sprintf(\"decomposition.%s_cmp%s\",\n\t\t\t\t\t   \t\tcomp,\n\t\t\t\t\t   \t\ts_forecast))\n}\nsa <- extract_sa_cmp(mysa, \"sa\")\ni <- extract_sa_cmp(mysa, \"i\")\nif (mysa$regarima$model$spec_rslt[,\"Log transformation\"]) {\n\tsa <- log(sa)\n\ti <- log(i)\n}\n# Pour mettre tous les résultats sous forme de matrice :\nt(simplify2array(\n\tlist(\n\t\trjd3toolkit::td_f(sa, nyears = 0, model = \"R100\"),\n\t\trjd3toolkit::td_f(sa, nyears = 8, model = \"R100\"),\n\t\trjd3toolkit::td_f(i, nyears = 0, model = \"R100\"),\n\t\trjd3toolkit::td_f(i, nyears = 8, model = \"R100\"))\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     value    pvalue      \n[1,] 4.748905 0.000112579 \n[2,] 5.20653  0.0001260325\n[3,] 3.970278 0.000732039 \n[4,] 3.639568 0.002840268 \n```\n:::\n:::\n\n\nAvec `rjdemetra3` ces composantes sont directement exportables :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx13_jd3 <- rjd3x13::x13(\n\tipi_fr, \n\trjd3x13::x13_spec(\"rsa5c\") |> \n\t\trjd3toolkit::set_tradingdays(\n\t\t\tcalendar.name = \"FR\"\n\t\t), \n\tctxt)\nsa <- x13_jd3$result$decomposition$d11\ni <- x13_jd3$result$decomposition$d13\nif (x13_jd3$result$preprocessing$description$log) {\n\tsa <- log(sa)\n\ti <- log(i)\n}\nsa <- window(sa, start = start(ipi_fr), end = end(ipi_fr))\ni <- window(i, start = start(ipi_fr), end = end(ipi_fr))\n```\n:::\n\n\nEn utilisant la fonction `rjd3toolkit::sarima_estimate()` et le package `car`, vous pouvez aussi construire vous-même le test^[\nVous pouvez également utiliser le code vu dans les sections [-@sec-rjd] et [-@sec-rjd2] pour estimer un modèle automatique.\n] :\n\n::: {.cell}\n\n```{.r .cell-code}\ncar::linearHypothesis(\n\trjd3toolkit::sarima_estimate(\n\t\tsa,\n\t\torder = c(0, 1, 1),\n\t\tseasonal = c(0, 0, 0),\n\t\tmean = FALSE,\n\t\txreg = rjd3toolkit::td(s = sa)\n\t),\n\tc(\"group_1 = 0\", \"group_2 = 0\", \"group_3 = 0\", \n\t  \"group_4 = 0\", \"group_5 = 0\", \"group_6 = 0\"),\n\ttest = \"F\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear hypothesis test\n\nHypothesis:\ngroup_1 = 0\ngroup_2 = 0\ngroup_3 = 0\ngroup_4 = 0\ngroup_5 = 0\ngroup_6 = 0\n\nModel 1: restricted model\nModel 2: rjd3toolkit::sarima_estimate(sa, order = c(0, 1, 1), seasonal = c(0, \n    0, 0), mean = FALSE, xreg = rjd3toolkit::td(s = sa))\n\n  Res.Df Df      F  Pr(>F)   \n1    369                     \n2    363  6 3.5528 0.00197 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\nUne autre solution est de passer par les objets `jSA` et d'exporter les indicateurs `\"diagnostics.td-i-last\"` et `\"diagnostics.td-sa-last\"`, ou bien de rajouter ces indicateurs dans le paramètre `userdefined` de `x13()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njsa <- jx13(get_ts(mysa), x13_spec(mysa))\nget_indicators(jsa,\"diagnostics.td-sa-last\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`diagnostics.td-sa-last`\n[1] 3.23497794 0.00641261\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n```\n:::\n\n```{.r .cell-code}\nget_indicators(jsa,\"diagnostics.td-i-last\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`diagnostics.td-i-last`\n[1] 3.284855968 0.005800128\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n```\n:::\n\n```{.r .cell-code}\nmysa <- x13(ipi_fr, myspec1_sa, userdefined = c(\"diagnostics.td-sa-last\", \"diagnostics.td-i-last\"))\nmysa$user_defined$`diagnostics.td-sa-last`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.23497794 0.00641261\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n```\n:::\n\n```{.r .cell-code}\nmysa$user_defined$`diagnostics.td-i-last`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.284855968 0.005800128\nattr(,\"description\")\n[1] \"F with 6 degrees of freedom in the nominator and 88 degrees of freedom in the denominator\"\n```\n:::\n\n```{.r .cell-code}\n# # ou :\n# t(simplify2array(\n#   mysa$user_defined\n# ))\n```\n:::\n\nPrivilégier plutôt ces deux dernières solutions, cela évite se regarder le schéma de décomposition (mais on ne peut pas personnaliser le test).\n\n\n\n::: callout-note\n## Exercice\nEssayez de corriger l'effet JO résiduel sur cette série.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLa spécification parait bonne, les régresseurs sont tous significatifs mais le modèle ARIMA est estimé sur 30 ans, ce qui peut paraître beaucoup. \n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Une option serait de couper les régresseurs JO en deux\ntd_reg_post_2003 <- td_reg_pre_2003  <- \n\tregresseurs_JO[,grep(\"TD7\", colnames(regresseurs_JO))]\nwindow(td_reg_pre_2003, end = c(2002, 12)) <- 0\nwindow(td_reg_post_2003, start = c(2003, 1)) <- 0\nwkd2 <- ts.union(td_reg_pre_2003, td_reg_post_2003,\n\t\t\t\t leap_year(frequency = 12))\ncolnames(wkd2) <- c(paste0(c(\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\n\t\t\t\t\t\t\t \"samedi\"),\"_av2003\"),\n\t\t\t\t\tpaste0(c(\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\n\t\t\t\t\t\t\t \"samedi\"),\"_ap2003\"),\"leap_year\")\n\nmyspec2_sa <- x13_spec(spec = \"RSA5c\",\n\t\t\t\t\t   usrdef.varEnabled = TRUE,\n\t\t\t\t\t   usrdef.var = wkd2,\n\t\t\t\t\t   usrdef.varType = \"Calendar\",\n\t\t\t\t\t   easter.enabled = FALSE)\nmysa2 <- x13(ipi_fr, myspec2_sa,\n\t\t\t userdefined = c(\"diagnostics.td-sa-last\", \"diagnostics.td-i-last\"))\nsummary(mysa2$regarima)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny = regression model + arima (0, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2020\nLog-transformation: no\nRegression model: no mean, trading days effect(13), no leap year effect, no Easter effect, outliers(4)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(>|t|)    \nTheta(1)  -0.49203    0.04773 -10.31   <2e-16 ***\nBTheta(1) -0.54474    0.04704 -11.58   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n                Estimate Std. Error  T-stat Pr(>|t|)    \nlundi_av2003      0.5617     0.1626   3.454 0.000617 ***\nmardi_av2003      1.1308     0.1855   6.097 2.80e-09 ***\nmercredi_av2003   0.5341     0.1906   2.802 0.005355 ** \njeudi_av2003      1.3022     0.1969   6.613 1.37e-10 ***\nvendredi_av2003   0.5584     0.1908   2.926 0.003650 ** \nsamedi_av2003    -1.7750     0.1762 -10.074  < 2e-16 ***\nlundi_ap2003      0.3172     0.2138   1.484 0.138814    \nmardi_ap2003      0.5908     0.2131   2.772 0.005862 ** \nmercredi_ap2003   0.8161     0.2235   3.652 0.000299 ***\njeudi_ap2003      0.7963     0.2374   3.354 0.000881 ***\nvendredi_ap2003   0.5458     0.2311   2.362 0.018725 *  \nsamedi_ap2003    -1.0733     0.1967  -5.455 9.12e-08 ***\nleap_year         2.0353     0.5391   3.775 0.000187 ***\nTC (4-2020)     -37.7719     1.8876 -20.010  < 2e-16 ***\nAO (3-2020)     -21.0048     1.7922 -11.720  < 2e-16 ***\nLS (11-2008)     -8.4349     1.4769  -5.711 2.35e-08 ***\nLS (1-2009)      -6.8261     1.4803  -4.611 5.57e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 1.811 on 339 degrees of freedom\nLog likelihood = -724.9, aic =  1490, aicc =  1492, bic(corrected for length) =   1.5\n```\n:::\n\n```{.r .cell-code}\nt(simplify2array(\n\tmysa2$user_defined\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                           [,1]       [,2]\ndiagnostics.td-sa-last 2.179743 0.05236055\ndiagnostics.td-i-last  2.675582 0.01968899\n```\n:::\n:::\n\n:::\n\n",
    "supporting": [
      "R_2_CJO_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}