{
  "hash": "fa3af3af89a1848f513dffc47b40b1cb",
  "result": {
    "markdown": "---\ntitle: \"0 - Traitement des séries temporelles sous {{< fa brands r-project >}}\"\n---\n\n\n\n\n> L'objectif de ce TP est d'apprendre à manipuler les séries temporelles sous R en utilisant les packages de bases.\n\nDans R il existe de nombreux packages qui permettent de manipuler les séries temporelles.\nPour n'en citer que quelques-uns :\\\n- Les objets `ts` peuvent être créés à partir du package `stats` ;\\\n- Les objets `zoo` peuvent être créés à partir du package [zoo](https://CRAN.R-project.org/package=zoo) ;\\\n- Les objets `xts` peuvent être créés à partir du package [xts](https://CRAN.R-project.org/package=xts) ;\\\n- Les objets `tis` peuvent être créés à partir du package [tseries](https://CRAN.R-project.org/package=tseries) ;\\\n- Les objets `tsibble` peuvent être créés à partir du package [tsibble](https://CRAN.R-project.org/package=tsibble).\n\n[tsbox](https://CRAN.R-project.org/package=tsbox) permet quand à lui de facilement passer d'une classe à l'autre.\n\nIci nous nous concentrerons essentiellement sur les trois premiers : `ts` stocker les séries temporelles, `zoo` et `xts` pour effectuer certaines manipulations supplémentaires.\n\nLes packages suivants seront utilisés :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages_to_install <- c(\"zoo\", \"xts\", \"dplyr\", \"XLConnect\", \"remotes\")\n\npackages <- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) > 0) {\n\tinstall.packages(packages)\n}\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"])\n\tremotes::install_github(\"rjdemetra/rjd3toolkit\")\n```\n:::\n\n\n# Manipulation des séries temporelles avec `ts()`\n\n## Création d'une série temporelle\n\nLa fonction `ts()` permet de créer des objets séries-temporelles à partir un vecteur (ou une matrice).\nLa syntaxe de base est `ts(vector, start=, end=, frequency=)` où `start` et `end` sont la première et la dernière observation, `frequency` est le nombre d'observations par unité de temps (1=annuelle, 2=semestrielle, 4=trimestrielle, 6=bi-mestrielle, 12=mensuelle, etc.).\n\nPar exemple pour créer une série trimestrielle ayant les valeurs de 1 à 10 et commençant en 1959Q2 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2)) # 2ème trimestre de 1959\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n\n```{.r .cell-code}\n# Équivalent à \nts(1:10, frequency = 4, start = 1959 + 1/4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n:::\n\n\nOn peut aussi définir l'objet à partir de sa date de fin :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, end = c(1959, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1957    1    2    3    4\n1958    5    6    7    8\n1959    9   10          \n```\n:::\n:::\n\n\nSi l'on directement extraire un sous-ensemble de la série on peut spécifier les paramètres `end` et `start`.\nPar exemple pour ne garder que les valeurs jusqu'en 1960 inclus :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2), end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOu alors utiliser la fonction `window` une fois l'objet créé :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object <- ts(1:10, frequency = 4, start = c(1959, 2))\nwindow(ts_object, end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOn peut récupérer les différents attributs avec les fonctions `start()`, `end()` et `frequency()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1959    2\n```\n:::\n\n```{.r .cell-code}\nend(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1961    3\n```\n:::\n\n```{.r .cell-code}\nfrequency(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nDeux autres fonctions peuvent aussi être utiles : `time()` crée un série-temporelle à partir des dates de notre série-temporelle et `cycle()` donne la position dans le cycle de chaque observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Qtr1    Qtr2    Qtr3    Qtr4\n1959         1959.25 1959.50 1959.75\n1960 1960.00 1960.25 1960.50 1960.75\n1961 1961.00 1961.25 1961.50        \n```\n:::\n\n```{.r .cell-code}\ncycle(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         2    3    4\n1960    1    2    3    4\n1961    1    2    3     \n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nExtraire toutes les données du 2ème trimestre de l'objet `ts_object`\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object[cycle(ts_object) == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5 9\n```\n:::\n:::\n\n\nAutre option : utiliser la fonction `window()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwindow(ts_object, frequency = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n```\n:::\n:::\n\n\nExplication : lorsque l'on spécifie le paramètre `frequency` dans la fonction `window()`, on change la fréquence de la série. \nDans notre cas, on veut extraire les valeurs du deuxième trimestre : on veut donc une série annuelle qui contient toutes les valeurs des deuxièmes trimestres. \nLa première observation de `ts_object` étant un deuxième trimestre, cela donne ce que l'on veut. \nPour extraire les valeurs des troisièmes trimestres il faut en plus changer la date de début :\n\n::: {.cell}\n\n```{.r .cell-code}\nwindow(ts_object, start = c(1950, 3), frequency = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nCréer une série temporelle mensuelle qui commence en 2000, qui se termine en janvier 2020, qui vaut 1 en avril 2009 et 0 à toutes les autres dates.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nOption 1 : utiliser la fonction `window()`\n\n::: {.cell}\n\n```{.r .cell-code}\nindicatrice <- ts(0, start = 2000, end = 2020, frequency = 12)\nwindow(indicatrice, start = c(2009, 4), end = c(2009, 4)) <- 1\nindicatrice\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n```\n:::\n:::\n\nOption 2 : utiliser `time()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindicatrice <- ts(0, start = 2000, end = 2020, frequency = 12)\n# Donne un vecteur de booléens\n(time(indicatrice) == 2009 + 3/12) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2000 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2001 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2002 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2003 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2004 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2005 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2006 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2007 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2008 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2009 FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2010 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2011 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2012 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2013 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2014 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2015 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2016 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2017 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2018 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2019 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2020 FALSE                                                                  \n```\n:::\n\n```{.r .cell-code}\n# on ajoute + 0 pour forcer la convertion en numérique\n(time(indicatrice) == 2009 + 3/12) + 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n```\n:::\n:::\n\n:::\n\nPour tracer un graphique il suffit maintenant d'utiliser les fonctions `plot()` et `lines()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ts_object * 2)\nlines(ts_object, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](R_0_Manipulation_series_temporelles_files/figure-html/plot-ts-example-1.png){width=672}\n:::\n:::\n\n\n## Séries multivariées\n\nDe la même façon que précédemment on peut créer une série temporelle multivariée.\nCette fois-ci l'objet créé est à la fois `mts`, `ts` et `matrix`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n# On génère 300 observations d'une loi normale (0, 1)\nloi_normale <- rnorm(300)\nmts <- ts(matrix(loi_normale, nrow = 100, ncol = 3),\n\t\t  start = c(1961, 1), frequency = 12)\n```\n:::\n\n\nOn peut accéder à la première variable de la même façon que dans une matrice : par son nom ou son numéro de colonne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Series 1\" \"Series 2\" \"Series 3\"\n```\n:::\n\n```{.r .cell-code}\n# mts[,1] # ou de façon équivalente :\nmts[, \"Series 1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Jan          Feb          Mar          Apr          May\n1961 -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772\n1962 -0.621240581 -2.214699887  1.124930918 -0.044933609 -0.016190263\n1963  0.619825748 -0.056128740 -0.155795507 -1.470752384 -0.478150055\n1964 -0.394289954 -0.059313397  1.100025372  0.763175748 -0.164523596\n1965 -0.112346212  0.881107726  0.398105880 -0.612026393  0.341119691\n1966  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209\n1967  0.610726353 -0.934097632 -1.253633400  0.291446236 -0.443291873\n1968  0.593946188  0.332950371  1.063099837 -0.304183924  0.370018810\n1969 -1.276592208 -0.573265414 -1.224612615 -0.473400636             \n              Jun          Jul          Aug          Sep          Oct\n1961 -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387\n1962  0.943836211  0.821221195  0.593901321  0.918977372  0.782136301\n1963  0.417941560  1.358679552 -0.102787727  0.387671612 -0.053805041\n1964 -0.253361680  0.696963375  0.556663199 -0.688755695 -0.707495157\n1965 -1.129363096  1.433023702  1.980399899 -0.367221476 -1.044134626\n1966  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670\n1967  0.001105352  0.074341324 -0.589520946 -0.568668733 -0.135178615\n1968  0.267098791 -0.542520031  1.207867806  1.160402616  0.700213650\n1969                                                                 \n              Nov          Dec\n1961  1.511781168  0.389843236\n1962  0.074564983 -1.989351696\n1963 -1.377059557 -0.414994563\n1964  0.364581962  0.768532925\n1965  0.569719627 -0.135054604\n1966  0.475509529 -0.709946431\n1967  1.178086997 -1.523566800\n1968  1.586833455  0.558486426\n1969                          \n```\n:::\n:::\n\n\nEt avec les même fonctions que pour les matrices on peut récupérer les noms des colonnes (`colnames`), le nombre de variables (`ncol`), etc.\n\n::: {.callout-important}\n## Attention\nUne source classique d'erreur est de manipuler des séries-temporelles uni et multivariées et de vouloir utiliser les fonctions liées aux matrices sur les séries univariées. Par exemple, `colnames(ts_object)` renverra toujours l'objet `NULL`. Une solution est de tester si l'objet est multivarié avec la fonction `is.mts()`.\n:::\n\n## Manipulation basiques\n\nPour concaténer plusieurs séries temporelles, les fonctions deux fonctions suivantes peuvent `ts.union()` et `ts.intersect()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object2 <- ts(1:10, frequency = 4, start = c(1960, 1))\nts.union(ts_object, ts_object2) # on garde toute la couverture temporelle en rajoutant des NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1959 Q2         1         NA\n1959 Q3         2         NA\n1959 Q4         3         NA\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n1961 Q4        NA          8\n1962 Q1        NA          9\n1962 Q2        NA         10\n```\n:::\n\n```{.r .cell-code}\nts.intersect(ts_object, ts_object2) # on ne garde que les périodes communes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n```\n:::\n:::\n\n\nOn va maintenant utiliser la série d'indice de production industrielle de la France (CVS-CJO) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr_manuf <- ts(c(99, 99.4, 99.7, 99.4, 100.8, 100, 98.7, 100.2, 101.2, \n100.6, 99.9, 100.9, 102.4, 100.8, 99.5, 100.7, 99.8, 99.1, 99.8, \n101.6, 100.4, 99.4, 102.8, 101, 100.2, 101.1, 102.6, 101.8, 103.7, \n103, 103.6, 103.5, 104.4, 105.6, 105.5, 105.9, 103.6, 102.9, \n103.8, 103.8, 102.5, 104.2, 104, 104.6, 103.4, 104.2, 103.4, \n103.7, 104.9, 105.8, 104.4, 104.3, 106, 103.7, 104.1, 103.1, \n103.9, 104.4), start = 2015, frequency = 12)\n```\n:::\n\n\nPour calculer la série retardée/avancée, il suffit d'utiliser la fonction `lag()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# série retardée d'un mois : en février 2010 on a la valeur de janvier 2010\nlag(ipi_fr_manuf, k = -1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2015        99.0  99.4  99.7  99.4 100.8 100.0  98.7 100.2 101.2 100.6  99.9\n2016 100.9 102.4 100.8  99.5 100.7  99.8  99.1  99.8 101.6 100.4  99.4 102.8\n2017 101.0 100.2 101.1 102.6 101.8 103.7 103.0 103.6 103.5 104.4 105.6 105.5\n2018 105.9 103.6 102.9 103.8 103.8 102.5 104.2 104.0 104.6 103.4 104.2 103.4\n2019 103.7 104.9 105.8 104.4 104.3 106.0 103.7 104.1 103.1 103.9 104.4      \n```\n:::\n:::\n\n\nLa fonction `diff` permet de calculer la différence entre deux périodes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff(ipi_fr_manuf, lag = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2015       0.4  0.3 -0.3  1.4 -0.8 -1.3  1.5  1.0 -0.6 -0.7  1.0\n2016  1.5 -1.6 -1.3  1.2 -0.9 -0.7  0.7  1.8 -1.2 -1.0  3.4 -1.8\n2017 -0.8  0.9  1.5 -0.8  1.9 -0.7  0.6 -0.1  0.9  1.2 -0.1  0.4\n2018 -2.3 -0.7  0.9  0.0 -1.3  1.7 -0.2  0.6 -1.2  0.8 -0.8  0.3\n2019  1.2  0.9 -1.4 -0.1  1.7 -2.3  0.4 -1.0  0.8  0.5          \n```\n:::\n:::\n\n\nEn revanche, le paramètre `lag` ne peut prendre que une valeur.\nLa fonction `rjd3toolkit::differences()` permet d'effectuer plusieurs différences et a également un paramètre `mean` pour centrer la série.\nPar exemple, pour effectuer à la fois une différenciation régulière et saisonnière (d'ordre 12) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrjd3toolkit::differences(ipi_fr_manuf, lags = c(1, 12))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Jan         Feb         Mar         Apr         May         Jun\n2016             -1.92888889 -1.52888889  1.57111111 -2.22888889  0.17111111\n2017 -2.22888889  2.57111111  2.87111111 -1.92888889  2.87111111  0.07111111\n2018 -1.42888889 -1.52888889 -0.52888889  0.87111111 -3.12888889  2.47111111\n2019  3.57111111  1.67111111 -2.22888889 -0.02888889  3.07111111 -3.92888889\n             Jul         Aug         Sep         Oct         Nov         Dec\n2016  2.07111111  0.37111111 -2.12888889 -0.32888889  4.17111111 -2.72888889\n2017 -0.02888889 -1.82888889  2.17111111  2.27111111 -3.42888889  2.27111111\n2018 -0.72888889  0.77111111 -2.02888889 -0.32888889 -0.62888889 -0.02888889\n2019  0.67111111 -1.52888889  2.07111111 -0.22888889                        \n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nÉcrire une fonction `ev()` qui calcule l'évolution mensuelle si la série en entrée est mensuelle, l'évolution trimestrielle si la série en entrée est trimestrielle, etc.\n\nLa fonction `ev()` transformera donc toute série $X_t$ en :\n$$\nY_t=\\frac{X_t-X_{t-1}}{\nX_{t-1}\n}=\\frac{X_t}{\nX_{t-1}\n} - 1.\n$$\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nev <- function(x){\n  result <- (x/stats::lag(x, k = -1) - 1) * 100\n  return(result)\n}\n# Ou de manière équivalente :\nev2 <- function(x){\n  # Attention ici c'est bien k = 1 dans la fonction diff\n  # et k = -1 dans la fonction lag\n  result <- (diff(x, lag = 1) /lag(x, k = -1)) * 100\n  return(result)\n}\n```\n:::\n\n\nRemarque : pour des raisons informatiques ces deux fonctions ne donnent pas exactement\nle même résultat. \nC'est un problème récurrent lorsque l'on souhaite tester l'égalité entre deux séries temporelles :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(ev(ipi_fr_manuf) == ev2(ipi_fr_manuf))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nUne solution est plutôt d'utiliser la fonction `all.equal()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(ev(ipi_fr_manuf), ev2(ipi_fr_manuf)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n# Utilisation de `xts` et `zoo`\n\n## Utilisation de `xts`\n\nUn des avantages du package `xts` est qu'il permet d'appliquer une fonction à chaque période d'une série temporelle (par exemple à toutes les données trimestrielles, annuelles, etc.).\nIl s'agit des fonctions `apply.monthly()`, `apply.quarterly()`, `apply.yearly()`, etc.\nPour cela il faut auparavant convertir les données au format `xts`.\n\nPar exemple pour calculer la moyenne annuelle :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts)\nmoy_an <- apply.yearly(as.xts(ipi_fr_manuf), mean)\nmoy_an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              [,1]\nDec 2015  99.98333\nDec 2016 100.60833\nDec 2017 103.40833\nDec 2018 103.67500\nOct 2019 104.46000\n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nCalculer l'évolution trimestrielle de `ipi_fr_manuf`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nTout d'abord on prolonge l'IPI par des valeurs manquantes jusqu'à la fin de l'année, sinon la dernière somme sur le trimestre est fausse.\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr_manuf_prolonge <- window(ipi_fr_manuf, end = c(2019, 12), extend = TRUE)\nsomme_trim <- apply.quarterly(as.xts(ipi_fr_manuf_prolonge), sum)\n```\n:::\n\n\nAttention la fonction lag n'agit pas pareil pour les objets xts et ts : il faut ici utiliser l'option `k = 1`.\nVoir l'aide associée à `?lag.xts`.\nPour garder la même convention entre `lag.ts()` et `lag.xts()` on peut utiliser l'option `options(xts.compat.zoo.lag=TRUE)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevol_trim <- (somme_trim/lag(somme_trim, k = 1) - 1) * 100\n```\n:::\n\n\nOn peut utiliser la fonction `format()` si l'on veut convertir automatiquement en un objet ts :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_year <- as.numeric(format(start(evol_trim), \"%Y\"))\nstart_quarter <- as.numeric(substr(quarters(start(evol_trim)), 2, 2))\nts(evol_trim, start = c(start_year, start_quarter), frequency = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015          NA  0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n```\n:::\n:::\n\nOn peut aussi directement utiliser le package `ts_box` et la fonction `ts_ts()` :\n\n::: {.cell}\n\n```{.r .cell-code}\ntsbox::ts_ts(evol_trim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015                      NA  0.70446159 -0.03331113\n2016  0.43318894  0.43132050 -1.02411629  0.73431242\n2017  0.46388337  0.23087071  1.51365581  0.97244733\n2018  1.76565008 -2.11356467  0.06445375  0.48309179\n2019 -0.22435897  1.22068744 -0.34909553 -0.92356688\n2020          NA                                    \n```\n:::\n:::\n\n:::\n\nOn aurait en fait pu le faire directement avec les fonctions de base R !\nPar contre la situation aurait été plus compliquée avec des données haute fréquence (du type journalières) non correctement gérées par `ts` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats::aggregate.ts(ipi_fr_manuf, nfrequency = 4,\n\t\t  FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Qtr1      Qtr2      Qtr3      Qtr4\n2015  99.36667 100.06667 100.03333 100.46667\n2016 100.90000  99.86667 100.60000 101.06667\n2017 101.30000 102.83333 103.83333 105.66667\n2018 103.43333 103.50000 104.00000 103.76667\n2019 105.03333 104.66667 103.70000          \n```\n:::\n:::\n\nCette fonction fait ici une somme sur 4 périodes consécutives mais ne reconnait pas les différents mois des trimestres :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats::aggregate.ts(window(ipi_fr_manuf, start = c(2015,2)), nfrequency = 4,\n\t\t  FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime Series:\nStart = 2015.08333333333 \nEnd = 2019.58333333333 \nFrequency = 4 \n [1]  99.50000  99.83333 100.66667 101.06667 100.33333  99.56667 100.46667\n [8] 101.33333 101.83333 103.43333 104.50000 105.00000 103.50000 103.56667\n[15] 104.06667 104.00000 104.83333 104.60000 103.80000\n```\n:::\n:::\n\n\nUne autre possibilité est d'utiliser la fonction `rjd3toolkit::aggregate()` (mais dont les fonctions d'agrégation sont limitées) :\n\n::: {.cell}\n\n```{.r .cell-code}\nrjd3toolkit::aggregate(window(ipi_fr_manuf, start = c(2015,2)),\n\t\t\t\t\t   nfreq = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Qtr1  Qtr2  Qtr3  Qtr4\n2015       300.2 300.1 301.4\n2016 302.7 299.6 301.8 303.2\n2017 303.9 308.5 311.5 317.0\n2018 310.3 310.5 312.0 311.3\n2019 315.1 314.0 311.1      \n```\n:::\n:::\n\n\n## Utilisation de `zoo`\n\nLe package `zoo` donne un ensemble d'outils qui permettent de manipuler les séries-temporelles.\nDe nombreux packages (dont `xts`) sont d'ailleurs basés sur ce format.\nIl permet notamment de faire des imputations de données manquantes selon différentes fonctions (toutes les fonctions commençant par `na.`) et de mieux gérer le format des dates associées aux séries temporelles (ce qui permet de faire des manipulations avec la fonction `format`, ce qui permet par exemple plus facilement exporter des séries temporelles sous Excel).\nLe calcul de l'évolution trimestrielle aurait par exemple pu être faite avec ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomme_trim <- aggregate(as.zoo(ipi_fr_manuf_prolonge), yearqtr, sum)\nsomme_trim <- as.ts(somme_trim) #La conversion en ts est plus simple depuis un objet zoo\nevol_trim <- ev(somme_trim)\nevol_trim\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015              0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n```\n:::\n:::\n\n\nPour le prochain exercice, utiliser la série suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserie_avec_NA <- ts(c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, \n  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA), start = 2000, frequency = 12)\n```\n:::\n\n\n::: callout-note\n## Exercice\nSur la série `serie_avec_NA`, utiliser les différentes fonctions du package `zoo` pour :\n\n1. Enlever les valeurs manquantes au début de la série ;  \n2. Remplacer les valeurs manquantes à la fin de la série par la dernière valeur observée.  \n3. Interpoler de manière linéaire les valeurs manquantes entre les 0 et les 1.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLes trois fonctions à utiliser sont : `na.trim()`, `na.locf()` et `na.approx()`. \nIl faudra peut-être inverser deux étapes pour que cela marche.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nD'abord on enlève les valeurs manquantes au début de la série\n\n::: {.cell}\n\n```{.r .cell-code}\netape_1 <- na.trim(serie_avec_NA, sides = \"left\")\netape_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2004  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2005   1   1   1   1   1   1   1   1   1   1   1   1\n2006   1   1   1   1   1   1   1   1   1   1   1   1\n2007  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n```\n:::\n:::\n\n\nEnsuite on interpole\n\n\n::: {.cell}\n\n```{.r .cell-code}\netape_2 <- na.approx(etape_1, na.rm = FALSE)\netape_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n```\n:::\n:::\n\n\nEnfin on remplace les valeurs à la fin de la série\n\n\n::: {.cell}\n\n```{.r .cell-code}\netape_3 <- na.locf(etape_2)\netape_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nÀ l'aide des fonctions `as.yearmon()` et `format()`, créer un data.frame contenant une colonne \"date\" qui contient les dates au format JJ/MM/YYYY et une deuxième colonnes avec les valeurs de `ipi_fr_manuf`.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLa fonction `as.yearmon()` doit être appliquée sur `time(ipi_fr_manuf)`. Pour la fonction `format` regarder l'aide `?format.Date`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.yearmon(time(ipi_fr_manuf))\ndates <- format(dates, \"%d/%m/%Y\")\ndonnees_formatees <- data.frame(date = dates, ipi = ipi_fr_manuf)\nhead(donnees_formatees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date   ipi\n1 01/01/2015  99.0\n2 01/02/2015  99.4\n3 01/03/2015  99.7\n4 01/04/2015  99.4\n5 01/05/2015 100.8\n6 01/06/2015 100.0\n```\n:::\n:::\n\n:::\n\nIl peut également être utile d'exporter un objet R `ts` ou `mts` vers un fichier Excel, tout en rajoutant une colonne \"date\" qui sera au format date.\nCi-dessous un exemple en utilisant le package XLConnect :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(XLConnect)\nts2xls <- function(x, file, sheet=\"Feuille 1\", format = \"dd/mm/yyyy\"){\n  wb <- loadWorkbook(file, create = TRUE)\n  createSheet(wb, sheet)\n  if(is.mts(x)){\n    col <- c(\"date\", colnames(x))\n  }else{\n    col <- c(\"date\", \"x\")\n  }\n  # Le titre\n  writeWorksheet(wb,matrix(col,nrow = 1),\n                 sheet = sheet,startCol = 1,startRow =1,\n                 header = FALSE)\n\n  # Petit trick pour que la colonne date soit au format date d'Excel\n  csDate <- getOrCreateCellStyle(wb, name = \"date\")\n  setDataFormat(csDate, format = format)\n  date <- as.Date(format(zoo::as.Date((time(x))), \"%d/%m/%Y\"),\n                  \"%d/%m/%Y\")\n  writeWorksheet(wb,date,sheet = sheet,\n                 startCol = 1,startRow = 2,\n                 header = FALSE)\n  setCellStyle(wb, sheet = sheet, row = seq_along(date)+1,\n               col = 1,\n               cellstyle = csDate)\n  # Fin colonne date\n\n  # Autres colonnes\n  writeWorksheet(wb,x,sheet = sheet,startCol = 2,startRow = 2,\n                 header = FALSE)\n  setColumnWidth(wb, sheet, column = seq_along(col), width = -1)\n  saveWorkbook(wb, file)\n}\n```\n:::\n",
    "supporting": [
      "R_0_Manipulation_series_temporelles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}