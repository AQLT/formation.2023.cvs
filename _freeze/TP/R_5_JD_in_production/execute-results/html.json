{
  "hash": "0594ab657647f3d83e4aad343846ebfb",
  "result": {
    "markdown": "---\ntitle: \"5 - JDemetra+ en production\"\n---\n\n\n\n\n> L'objectif de ce TP est d'apprendre à manipuler des workspaces pour une mise en production.\n\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages_to_install <- c(\"RJDemetra\", \"remotes\", \"rjdqa\", \"ggdemetra\", \"rjdmarkdown\", \"rjwsacruncher\")\n\npackages <- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) > 0) {\n\tinstall.packages(packages)\n}\npackages_to_install_git <- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjdemetra3\")\npackages_git <- packages_to_install_git[! packages_to_install_git %in% installed.packages()[,\"Package\"]]\n\nif (length(packages_git) > 0) {\n\t# # Configurer si besoin le proxy\n\t# proxy <- \"proxy_a_definir\"\n\t# Sys.setenv(HTTPS_PROXY = proxy)\n\tremotes::install_github(\n\t\tsprintf(\"rjdemetra/%s\", packages_git),\n\t\t# option utile dans certaines installations portables de Java :\n\t\tINSTALL_opts = \"--no-multiarch\")\n}\nif (! \"rjdworkspace\" %in% installed.packages()[,\"Package\"])\n    remotes::install_github(\"InseeFrLab/rjdworkspace\",\n    \t\t\t\t\t\tINSTALL_opts = \"--no-multiarch\")\n```\n:::\n\n\n\nLors de la mise en production, le plus simple est de manipuler des workspaces et de mettre à jour les modèles, lors de l'arrivée de nouvelles données à travers le [JWSACruncher](https://github.com/jdemetra/jwsacruncher). \nPour faciliter son utilisation depuis R, le package `rjwsacruncher` peut être utilisé.\n\nLorsque les workspaces sont créés depuis R, on perd toutes les métadonnées (lien vers les fichiers, commentaires, etc.), une solution pour cela : utiliser [`rjdworkspace`](https://github.com/InseeFrLab/rjdworkspace) (package non publié sur le CRAN) pour récupérer ces données depuis un autre workspace.\nPour la version 3, `rjdemetra3` contient toutes les fonctionnalités de `rjdworkspace`.\n\nDans ce TP on utilisera les données du package `RJDemetra` mais n'hésitez pas à utiliser vos propres séries.\n\n# JWSACruncher et `rjwsacruncher` {#sec:jwsacruncher}\n\n## Configuration du JWSACruncher {#sec:installation}\n\nLe JWSACruncher est téléchargeable ici : <https://github.com/jdemetra/jwsacruncher/releases>.\n\nPour utiliser les dernières versions il faut avoir une version de Java supérieure à la 8, si ce n'est pas le cas, il faut télécharger une version portable de Java et configurer le JWSACruncher en conséquence (voir [manuel d'installation](/manuel_installation.qmd)). \nCette opération n'est pas utile si l'on utilise une version 3.x.y de JDemetra+ (une version portable de Java est \"embarquée\" avec le JWSACruncher).\nCes manipulations peuvent aussi se faire à partir de `rjwsacruncher` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"rjwsacruncher\") # Si pas déjà installé\nlibrary(rjwsacruncher)\n# Télécharge l'archive du JWSACruncher et la met sur le D:/\ndownload_cruncher(\n\t\"D:/\",\n\t# Par défaut on télécharge la dernière version du cruncher en V2\t\n\tv3 = FALSE)  \n# Dézipper l'archive configurer avec une version portable de Java :\njwsacruncher_path <- \"D:/jwsacruncher-2.2.4-bin/bin/jwsacruncher.bat\" \n# Lien vers le fichier java.exe de la version portable de Java :\njava_path <- \"D:/Java8/bin/java.exe\" \nconfigure_jwsacruncher(jwsacruncher_path, java_path)\n```\n:::\n\n\nPour indiquer à `rjwsacruncher` où se trouve le JWSACruncher, le plus simple est de mettre à jour l'option `cruncher_bin_directory` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chemin vers le dossier bin du JWSACruncher\n# Remplacer \"jwsacruncher-2.2.4/bin\" par votre propre chemin.\noptions(cruncher_bin_directory =\n\t\t\t\"jwsacruncher-2.2.4/bin\") \ngetOption(\"cruncher_bin_directory\") # Pour afficher la valeur actuelle\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"jwsacruncher-2.2.4/bin\"\n```\n:::\n:::\n\n\n\n## Utilisation du JWSACruncher\n\nPour éviter que le package `rjwsacruncher` soit trop volumineux, il ne contient pas le JWSAcruncher de JDemetra+. Ce dernier peut être téléchargé à l'adresse suivante : <https://github.com/jdemetra/jdemetra-app/releases> ou en utilisant la fonction `rjwsacruncher::download_cruncher()`. Pour sa configuration avec une version portable, voir le [manuel d'installation](/manuel_installation.qmd).\n\nPour lancer le JWSACruncher il faut trois fichiers :\n\n- un fichier contenant les paramètres sur la méthode de rafraîchissement à utilisée pour mettre à jour le workspace (créé à partir de la fonction `create_param_file()` ou `list2param_file()`) ;  \n- un workspace valide de JDemetra+ ;  \n- l'adresse vers le JWSACruncher (option `cruncher_bin_directory`).\n\nDans le package `rjwsacruncher`, les principales fonctions associées au lancement du JWSACruncher sont :  \n\n- `create_param_file()` ou `list2param_file()` qui permet de créer le fichier de paramètres ;  \n- `cruncher()` qui permet de lancer le JWSACruncher sur un workspace à partir d'un fichier de paramètres ;  \n- `cruncher_and_param()` qui permet de lancer le JWSACruncher tout en créant le fichier de paramètres et de personnaliser certaines sorties du JWSACruncher.\n\n\n### Création du fichier de paramètres avec `create_param_file()`\n\nLes paramètres de la fonction `create_param_file()` sont les mêmes que ceux décrits dans le wiki du JWSACruncher de JDemetra+ (<https://github.com/jdemetra/jwsacruncher/wiki>). \nLes trois paramètres les plus importants de `create_param_file()` sont :  \n\n1. `policy` qui est la méthode de rafraîchissement utilisée (voir tableau ci-dessous).\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Les différentes politiques de rafraîchissement</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Option sous JDemetra+ </th>\n   <th style=\"text-align:left;\"> Option du cruncher </th>\n   <th style=\"text-align:left;\"> Signification </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Fixed model </td>\n   <td style=\"text-align:left;\"> current </td>\n   <td style=\"text-align:left;\"> Le modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Estimate regression coefficients </td>\n   <td style=\"text-align:left;\"> fixedparameters (ou fixed) </td>\n   <td style=\"text-align:left;\"> Le modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients du modèle ARIMA sont fixés et les autres paramètres du modèle de régression sont ré-estimés. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Estimate regression coefficients + Arima parameters </td>\n   <td style=\"text-align:left;\"> parameters (paramètre par défaut) </td>\n   <td style=\"text-align:left;\"> Le modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Estimate regression coefficients + Last outliers </td>\n   <td style=\"text-align:left;\"> lastoutliers </td>\n   <td style=\"text-align:left;\"> Le modèle ARIMA, les outliers (sauf ceux de la dernière année) et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Les outliers de la dernière année sont ré-identifiés. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Estimate regression coefficients + all outliers </td>\n   <td style=\"text-align:left;\"> outliers </td>\n   <td style=\"text-align:left;\"> Le modèle ARIMA et les paramètres du modèle regARIMA autres que les outliers ne sont pas ré-identifiés mais ré-estimés. Tous les outliers sont ré-identifiés. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Partial concurrent adjustment -&gt; Estimate regression coefficients + Arima model </td>\n   <td style=\"text-align:left;\"> stochastic </td>\n   <td style=\"text-align:left;\"> Ré-identification de tous les paramètres du modèle regARIMA hormis les variables calendaires. Le schéma de décomposition est inchangé. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Concurrent </td>\n   <td style=\"text-align:left;\"> complete ou concurrent </td>\n   <td style=\"text-align:left;\"> Ré-identification de tout le modèle regARIMA. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n2. `matrix_item` qui est une chaîne de caractères contenant les noms des paramètres à exporter. \nPar défaut, ce sont ceux de l'option [`default_matrix_item`](/PDF/output_jd.pdf). \nOn peut donc au choix modifier l'option `default_matrix_item` ou le paramètre `matrix_item` :\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjwsacruncher)\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_matrix_item\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple\n# que les critères d'information :\noptions(default_matrix_item = c(\"likelihood.aic\",\n\t\t\t\t\t\t\t\t\"likelihood.aicc\",\n\t\t\t\t\t\t\t\t\"likelihood.bic\",\n\t\t\t\t\t\t\t\t\"likelihood.bicc\"))\n```\n:::\n\n\n3. `tsmatrix_series` qui est une chaîne de caractères contenant les noms des paramètres à exporter. \nPar défaut, ce sont ceux de l'option [`default_tsmatrix_series`](/PDF/output_jd.pdf). \nOn peut donc au choix modifier l'option `default_tsmatrix_series` ou le paramètre `tsmatrix_series` :\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_tsmatrix_series\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple que\n# la série désaisonnalisée et ses prévisions :\noptions(default_tsmatrix_series = c(\"sa\", \"sa_f\"))\n```\n:::\n\n\n\nPour voir l'ensemble des paramètres, il suffit d'utiliser sous R la commande `?create_param_file`.\n\nAprès cela, il ne reste plus qu'à créer le fichier de paramètres.\nLe fichier de paramètre est différent entre la version 3.0.0 de JDemetra+ et les versions antérieures.\nLes fonctions de création des fichiers de paramètres ont un paramètre `v3` qui permet de spécifier si l'on veut que le fichier soit compatible avec la version 3.0.0.\nSa valeur par défaut est `getOption(\"is_cruncher_v3\")` : si l'on utilise la version 3.0.0 ou plus, le plus simple est donc de changer cette option `options(is_cruncher_v3 = TRUE)`.\nCi-dessous quelques exemples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Un fichier parametres.param sera créé sous D:/ \n# avec la politique de rafraîchissement \"lastoutliers\" \n# et les autres paramètres par défaut\ncreate_param_file(dir_file_param = \"D:/\",\n\t\t\t\t  policy = \"lastoutliers\")\n# Si l'on a modifié les options \"default_matrix_item\" et \"default_tsmatrix_series\" pour\n# n'exporter que les critères d'information, la série désaisonnalisée et ses\n# prévisions, la commande précédente est équivalent à : \ncreate_param_file(dir_file_param = \"D:/\",\n\t\t\t\t  policy = \"lastoutliers\",\n\t\t\t\t  matrix_item = c(\"likelihood.aic\", \"likelihood.aicc\",\n\t\t\t\t  \t\t\t\t\"likelihood.bic\", \"likelihood.bicc\"),\n\t\t\t\t  tsmatrix_series = c(\"sa\", \"sa_f\"))\n```\n:::\n\n\n\n::: callout-note\n## Exercice\nUtiliser la fonction `create_param_file()` pour créé un fichier de paramètres permettant de mettre à jour un workspace :\n\n- En reestimant le modèle ARIMA, les outliers et les autres paramètres du modèle de régression et en re-identifiant les outliers uniquement sur la dernière année.\n- En exportant la statistique M7, la statistique Q-M2 et les tests de jours ouvrables résiduels ;\n- En exportant La série brute, la série désaisonnalisée et la tendance (de manière verticale).\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nPour voir les noms des paramètres, utiliser la fonction `default_param_file()` ou bien aller sur la page <https://github.com/jdemetra/jwsacruncher/wiki/Output-dictionaries>.\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ndir <- tempdir()\ncreate_param_file(\n\tdir_file_param = dir,\n\tpolicy = \"lastoutliers\",\n\tmatrix_item = c(\n\t\t\"m-statistics.m7\",\n\t\t\"m-statistics.q-m2\",\n\t\t\"diagnostics.residual trading days tests.f-test on sa (td):2\",\n\t\t\"diagnostics.residual trading days tests.f-test on i (td):2\"\n\t),\n\ttsmatrix_series = c(\"y\", \"sa\", \"t\"),\n\tcsv_layout = \"vtable\" \n)\n```\n:::\n\n:::\nLes fichiers de paramètres peuvent être lus avec `read_param_file()` qui renvoie une liste qui peut être modifiée et exportée avec `list2param_file()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam_f <- read_param_file(file.path(dir, \"parameters.param\"))\nstr(param_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 7\n $ config         :List of 4\n  ..$ bundle       : chr \"10000\"\n  ..$ csv_layout   : chr \"vtable\"\n  ..$ csv_separator: chr \";\"\n  ..$ ndecs        : chr \"6\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"m-statistics.m7\" \"m-statistics.q-m2\" \"diagnostics.residual trading days tests.f-test on sa (td):2\" \"diagnostics.residual trading days tests.f-test on i (td):2\"\n $ tsmatrix_series: chr [1:3] \"y\" \"sa\" \"t\"\n $ paths_path     : NULL\n```\n:::\n:::\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction `default_param_file()`.\n\n### Lancement du JWSACruncher\n\nPour lancer le JWSACruncher avec `cruncher()` ou `cruncher_and_param()`, il faut spécifier le chemin d'accès au dossier contenant le JWSACruncher (paramètre `cruncher_bin_directory`) ainsi que celui du workspace à traiter (paramètre `workspace`).\nSi cela a déjà été fait dans la section [-sec:installation@], ne pas prendre en compte le paragraphe suivant\n\nPar défaut, le chemin d'accès au dossier du JWSACruncher est celui contenu dans le paramètre `cruncher_bin_directory` : il suffit donc de modifier une seule fois cette option afin qu'elle s'applique à toutes les exécutions du JWSACruncher. \nLe chemin à indiquer est celui du dossier contenant le fichier *jwsacruncher.bat*, situé dans le dossier \"Bin\" du dossier d'installation du JWSACruncher. \nAinsi, s'il a été installé sous `D:\\jdemetra-cli-2.2.4`, le fichier *jwsacruncher.bat* sera présent sous `D:\\jdemetra-cli-2.2.4\\bin`. \nIl faut donc modifier l'option `cruncher_bin_directory` de la façon suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(cruncher_bin_directory = \"D:/jdemetra-cli-2.2.4/bin/\")\n```\n:::\n\n\nSi aucun chemin de workspace n'est renseigné, une fenêtre s'ouvre, invitant à sélectionner le workspace sur lequel on souhaite lancer le JWSACruncher.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remplacer ici \"workspace.xml\" par le chemin vers votre workspace\ncruncher(workspace = \"workspace.xml\",\n# Remplacer ici \"parameters.param\" par le chemin vers votre fichier de paramètres\n\t\t param_file_path = \"parameters.param\"\n)\n```\n:::\n\n\nSi vous n'avez pas de workspace vous pouvez utiliser le code suivant pour en générer un :\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RJDemetra)\nspec_x13 <- x13_spec(spec = \"RSA5c\")\njws <- new_workspace()\nnew_multiprocessing(jws, \"sa1\")\n\nfor (nom_series in colnames(ipi_c_eu)){\n\tmodel <- jx13(ipi_c_eu[,nom_series], spec_x13)\n\tadd_sa_item(jws, \"sa1\", model, nom_series)\n}\n\nsave_workspace(jws, \"workspace.xml\")\n```\n:::\n\n\nSi non spécifié dans le fichier des paramètres, les résultats sont exportés dans le sous dossier `\"Output\"` du workspace (pour le `workspace.xml`, les résultats seront donc sous `workspace/Output/`). \nOn peut aussi créer le fichier des paramètres et lancer le JWSAcruncher avec la fonction `cruncher_and_param`. \nCette fonction permet aussi de renommer les dossiers exportées avec les noms des multi-processings utilisés dans JDemetra+ (évite d'avoir des dossiers du type `SAProcessing-1`)^[\nUne autre façon de faire est d'importer le workspace `jws <- load_workspace(\"workspace.xml\")` et de le sauvegarder sans rien faire `save_workspace(\"workspace.xml\")`.\nL'export va renommer les noms des fichiers des multi-processings en utilisant leur nom, ce qui évitera cette opération de renommage.\n].\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncruncher_and_param(\n\tworkspace = \"workspace.xml\",\n\tpolicy = \"lastoutliers\",\n\tmatrix_item = c(\n\t\t\"m-statistics.m7\",\n\t\t\"m-statistics.q-m2\",\n\t\t\"diagnostics.residual trading days tests.f-test on sa (td):2\",\n\t\t\"diagnostics.residual trading days tests.f-test on i (td):2\"\n\t),\n\ttsmatrix_series = c(\"y\", \"sa\", \"t\"),\n\tcsv_layout = \"vtable\"\n)\n```\n:::\n\n\n\n# Mise à jour des données avec `rjdemetra3`\n\n\nAvec les packages de `rjdemetra3` vous pouvez également directement rafraîchir les spécifications depuis R, la chaîne de production peut donc être entièrement codée en R !\nPour cela il faut utiliser la fonction `rjd3x13::x13_refresh()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- ipi_c_eu[,\"FR\"]\ny_est <- window(y, end = 2019)\nmod <- rjd3x13::x13(y_est)\nmod$result$preprocessing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)    -0.01262    0.10670  -0.118\nphi(2)     0.15483    0.07314   2.117\ntheta(1)  -0.53470    0.09811  -5.450\nbtheta(1) -0.69469    0.04642 -14.965\n\nRegression model:\n                  Estimate Std. Error T-stat\ntd               0.0069229  0.0002921 23.703\neaster          -0.0225158  0.0041277 -5.455\nLS (2008-11-01) -0.0855201  0.0168275 -5.082\nLS (2009-01-01) -0.0720329  0.0168047 -4.286\nAO (2011-05-01)  0.1292294  0.0167144  7.732\nNumber of observations:  349 \nNumber of effective observations:  336 \nNumber of parameters:  10 \n\nLoglikelihood:  827.5883 \nAdjusted loglikelihood:  -724.056 \n\nStandard error of the regression (ML estimate):  0.02035457 \nAIC:  1468.112 \nAICC:  1468.789 \nBIC:  1506.283 \n```\n:::\n\n```{.r .cell-code}\nspec_x13_ref <- rjd3x13::x13_refresh(\n  # Point spec: la specification de laquelle on part\n\tspec = mod$result_spec,\n  # Domain spec: Specification utilisée pour l'estimation \n  # permet de définir les contraintes (CJO, valeurs possibles ARIMA...)\n\trefspec = mod$estimation_spec,\n  # Politique de rafraîchissement\n\tpolicy = \"Outliers\",\n  # Période où les outliers sont figés :\n  period = 12,\n  start = start(y_est),\n  end = end(y_est) - c(1, 0)\n)\nmod_ref <- rjd3x13::x13(y, spec_x13_ref)\nmod_ref$result$preprocessing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog-transformation: yes \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)    -0.05032    0.11064  -0.455\nphi(2)     0.12922    0.07407   1.745\ntheta(1)  -0.56250    0.10270  -5.477\nbtheta(1) -0.70607    0.04405 -16.030\n\nRegression model:\n                  Estimate Std. Error  T-stat\ntd               0.0070469  0.0002873  24.529\neaster          -0.0226977  0.0041604  -5.456\nLS (2008-11-01) -0.0852825  0.0174225  -4.895\nLS (2009-01-01) -0.0716876  0.0173995  -4.120\nAO (2011-05-01)  0.1290416  0.0171996   7.503\nTC (2020-03-01) -0.2046281  0.0202037 -10.128\nTC (2020-04-01) -0.2804802  0.0203271 -13.798\nNumber of observations:  372 \nNumber of effective observations:  359 \nNumber of parameters:  12 \n\nLoglikelihood:  875.4961 \nAdjusted loglikelihood:  -781.4164 \n\nStandard error of the regression (ML estimate):  0.02086258 \nAIC:  1586.833 \nAICC:  1587.735 \nBIC:  1633.433 \n```\n:::\n\n```{.r .cell-code}\n# Le modèle est différent de celui obtenu en réestimant\n# avec la spécification par défaut\nrjd3x13::x13(y)$result$preprocessing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog-transformation: no \nSARIMA model:  (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat\nphi(1)     0.05291    0.10635   0.497\nphi(2)     0.18672    0.07339   2.544\ntheta(1)  -0.52138    0.10129  -5.147\nbtheta(1) -0.66132    0.05065 -13.056\n\nRegression model:\n                 Estimate Std. Error  T-stat\ntd                0.69265    0.03143  22.039\nlp                2.09031    0.69411   3.012\neaster           -2.54757    0.44179  -5.766\nLS (2008-11-01)  -9.27443    1.75769  -5.276\nLS (2009-01-01)  -7.28376    1.75607  -4.148\nAO (2011-05-01)  13.18697    1.80957   7.287\nAO (2020-03-01) -21.14917    2.12203  -9.966\nTC (2020-04-01) -35.64811    2.09187 -17.041\nNumber of observations:  372 \nNumber of effective observations:  359 \nNumber of parameters:  13 \n\nLoglikelihood:  -795.0695 \nStandard error of the regression (ML estimate):  2.193228 \nAIC:  1616.139 \nAICC:  1617.194 \nBIC:  1666.622 \n```\n:::\n:::\n\n\n\n# Mise à jour des metadonnées avec `rjdworkspace` {#sec:rjdworkspace}\n\nLorsque l'on manipule des objets depuis RJDemetra, plusieurs informations sont perdues par rapport à JDemetra+, dont :\n\n- le lien vers les données d'origine\n\n- les éventuels commentaires que l'on peut faire\n\nToutes ces informations sont les *metadata*. \nLorsque vous créer un workspace depuis JDemetra+, vous pouvez par exemple voir ces données en ouvrant le fichier `SAProcessing/SAProcessing-1.xml` associé au dossier de votre workspace.\nDans l'exemple ci-dessous, dans les premières lignes de ce fichier Excel on peut voir les données utilisées, le nom de la série et dans la partie \"metaData\" le chemin vers le fichier Excel contenant les données :\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n<item name=\"sa1\">\n        <subset>\n            <item name=\"ts\">\n                <ts name=\"IPI&#10;BE\">\n                    <freq>12</freq>\n                    <firstYear>2000</firstYear>\n                    <firstPeriod>1</firstPeriod>\n                    <data>...</data>\n                    <metaData>\n                        <property name=\"@timestamp\" value=\"Sun Oct 08 17:19:31 CEST 2023\"/>\n                        <property name=\"@source\" value=\"XCLPRVDR\"/>\n                        <property name=\"@id\" value=\"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2Fdata.xlsx#seriesName=BE&amp;sheetName=IPI\"/>\n                    </metaData>\n                </ts>\n            </item>\n            ....\n```\n:::\n\n\n\nSupposons que ce soit le workspace utilisé en production (i.e. : le workspace sur lequel vous lancez `rjwsacruncher`). \nOn va se placer dans le cas où l'on souhaite modifier ce workspace depuis R.\nOn repartira du workspace `ws_prod.xml` qui est dans le `.zip` disponible sous [/data/data_prod.zip](data/data_prod.zip).\nPour le télécharger depuis R :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_dl <- \".\"\ndownload.file(\"https://AQLT.github.io/formation.2023.cvs/data/data_prod.zip\",\n              file.path(dir_dl, \"data_prod.zip\"))\nunzip(file.path(dir_dl, \"data_prod.zip\"),\n      exdir = dir_dl)\n```\n:::\n\n\n\n\n\n::: callout-note\n## Exercice\nCréer un nouveau workspace `ws_prod_tmp.xml` où l'on a modifié toutes les spécifications de votre workspace en rajoutant un AO en janvier 2020.\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RJDemetra)\n# Chargement du workspace\njws <- load_workspace(file.path(dir_dl, \"ws_prod.xml\"))\ncompute(jws)\n# Import de tous les modèles\n# On a une liste qui contient autant d'éléments que de multiprocessings\n# et chaque élément est une liste qui contient autant d'éléments que de modèle\n# dans le multiprocessing considéré\nall_models <- get_model(jws, progress_bar = FALSE)\n\njws2 <- new_workspace()\nfor(sa_name in names(all_models)){\n\tnew_multiprocessing(jws2, sa_name)\n\tfor (series_name in names(all_models[[sa_name]])){\n\t\tnew_spec <- x13_spec(all_models[[sa_name]][[series_name]],\n\t\t\t\t\t\t\t usrdef.outliersEnabled = TRUE,\n\t\t\t\t\t\t\t usrdef.outliersType = c(\"AO\"),\n\t\t\t\t\t\t\t usrdef.outliersDate = c(\"2020-01-01\"))\n\t\tnew_jmod <- jx13(get_ts(all_models[[sa_name]][[series_name]]),\n\t\t\t\t\t\t new_spec)\n\t\tadd_sa_item(workspace = jws2, multiprocessing = sa_name,\n\t\t\t\t\tsa_obj = new_jmod,\n\t\t\t\t\tname = series_name)\n\t}\n}\nsave_workspace(jws2, file.path(dir_dl, \"ws_prod_tmp.xml\"))\n```\n:::\n\n:::\n\nSi vous ouvrez maintenant le fichier `ws_prod_tmp/SAProcessing/SAProcessing-1.xml` vous remarquez donc qu'il n'y a plus les parties `metaData` !\n\nPour les mettre à jour il existe deux fonctions dans `rjdworkspace` :\n\n1. `update_medata` qui, à partir d'un workspace de référence, met à jour un workspace (`ws_prod_tmp.xml`) en faisant un matching sur le nom des séries (il y a donc potentiellement un problème si on a plusieurs séries avec le même nom)\n\n2. `update_metadata_roughly()`, à partir d'un workspace de référence, met à jour un workspace (`ws_prod_tmp.xml`) en fonction de l'ordre de la série dans le modèle (le premier modèle de `ws_prod_tmp.xml` est mis à jour avec les informations du premier modèle de l'autre workspace, etc.).\n\nDans notre cas, `update_metadata_roughly()` suffit :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjdworkspace)\njws3 <- update_metadata_roughly(\n\tjws, # D'abord le workspace qui contient les metadata \n\tjws2 # Ensuite le workspace à mettre à jour\n)\n# Il reste à sauvegarder le nouveau workspace\nsave_workspace(jws3, file.path(dir_dl, \"ws_prod_tmp2.xml\"))\n```\n:::\n\n\n\n# Mise à jour des metadonnées avec `rjdemetra3` {#sec:rjd3}\n\nDans `rjdemetra3` il existe différentes fonctions pour modifier les métadonnées des SAItems : `rjdemetra3::set_comment()`, `rjdemetra3::set_context()`, `rjdemetra3::set_domain_specification()`, `rjdemetra3::set_name()`, `rjdemetra3::set_priority()`, `rjdemetra3::set_raw_data()`, `rjdemetra3::set_specification()`, `rjdemetra3::set_ts_metadata()`, `rjdemetra3::put_ts_metadata()`, `rjdemetra3::set_ts()`.\nLe package `rjd3providers` permet également, grâce à `rjdemetra3`, de mettre à jour les providers depuis R (i.e. : les chemins vers les données).\n\nLes informations sur les metadata associés à la série temporelle peut être lue en utilisant la fonction `get_ts()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njws_prod <- rjdemetra3::.jws_load(file.path(dir_dl, \"ws_prod.xml\"))\njws_prod_tmp <- rjdemetra3::.jws_load(file.path(dir_dl, \"ws_prod_tmp.xml\"))\njsa1 <- rjdemetra3::.jsap_sa(rjdemetra3::.jws_sap(jws_prod, 1), 1)\njsa1_tmp <- rjdemetra3::.jsap_sa(rjdemetra3::.jws_sap(jws_prod_tmp, 1), 1)\nrjdemetra3::get_ts(jsa1)[1:3] # 4e élément est la série brute \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n[1] \"IPI\\nBE\"\n\n$moniker\n$source\n[1] \"\"\n\n$id\n[1] \"003ac569-8f52-4bb2-8a34-0f4f1f87f3fd\"\n\nattr(,\"class\")\n[1] \"JD3_TSMONIKER\"\n\n$metadata\n$metadata$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$metadata$`@source`\n[1] \"XCLPRVDR\"\n\n$metadata$`@id`\n[1] \"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2Fdata.xlsx#seriesName=BE&sheetName=IPI\"\n```\n:::\n\n```{.r .cell-code}\nrjdemetra3::get_ts(jsa1_tmp)[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n[1] \"BE\"\n\n$moniker\n$source\n[1] \"\"\n\n$id\n[1] \"02bc776a-ac72-4270-8888-830307577b23\"\n\nattr(,\"class\")\n[1] \"JD3_TSMONIKER\"\n\n$metadata\nNULL\n```\n:::\n:::\n\n\n\n\n::: callout-note\n## Exercice\nEn utilisant la fonction `rjdemetra3::set_ts_metadata()`, reproduire la fonction `rjdworkspace::update_metadata_roughly()`.\nIl faut pour cela parcourir tous les SAProcessing et tous les SAItems avec les fonctions vues dans les précédents TP.\nVérifier le résultat.\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_metadata_roughly2 <- function(jws1, jws2) {\n\tfor (i_mp in seq_len(rjdemetra3:::.jws_sap_count(jws1))) {\n\t\tjmp_ws1 <- rjdemetra3::.jws_sap(jws1, i_mp)\n\t\tjmp_ws2 <- rjdemetra3::.jws_sap(jws2, i_mp)\n\t\tfor (i_sa in seq_len(rjdemetra3::.jsap_sa_count(jmp_ws1))) {\n\t\t\trjdemetra3::set_ts_metadata(jmp_ws2, i_sa,\n\t\t\t\t\t\t\t\t\t\trjdemetra3::.jsap_sa(jmp_ws1, i_sa))\n\t\t}\n\t}\n\treturn(invisible(TRUE))\n}\nupdate_metadata_roughly2(jws_prod,\n\t\t\t\t\t\t jws_prod_tmp)\njsa1_tmp <- rjdemetra3::.jsap_sa(rjdemetra3::.jws_sap(jws_prod_tmp, 1), 1)\nrjdemetra3::get_ts(jsa1_tmp)[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n[1] \"BE\"\n\n$moniker\n$source\n[1] \"\"\n\n$id\n[1] \"003ac569-8f52-4bb2-8a34-0f4f1f87f3fd\"\n\nattr(,\"class\")\n[1] \"JD3_TSMONIKER\"\n\n$metadata\n$metadata$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$metadata$`@source`\n[1] \"XCLPRVDR\"\n\n$metadata$`@id`\n[1] \"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2Fdata.xlsx#seriesName=BE&sheetName=IPI\"\n```\n:::\n:::\n\n:::\n\nComme vous le remarquez, le chemin absolu vers les données est inscrit dans le workspace.\nSi vous lancer le JWSACruncher sur ce workspace vous devriez avoir une erreur puisque le fichier n'est pas au même endroit chez vous !\nCe fichier est dans l'archive [data_prod.zip](/data/data_prod.zip).\nLe chemin peut également être mis à jour grâce à `rjd3providers` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njsap <- rjdemetra3::.jws_sap(jws_prod_tmp, 1)\njsa <-  rjdemetra3::.jsap_sa(jsap, 1)\n# Il faut changer le paramètre @id\nrjdemetra3::get_ts(jsa)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$`@source`\n[1] \"XCLPRVDR\"\n\n$`@id`\n[1] \"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2Fdata.xlsx#seriesName=BE&sheetName=IPI\"\n```\n:::\n\n```{.r .cell-code}\n# On extrait l'objet java\njsa_id <- rjdemetra3::.jsa_ts_metadata(jsa, \"@id\")\nfull_path_f <- base::normalizePath(file.path(dir_dl, \"data_ws_prod.xlsx\"))\nnid <- rjd3providers::spreadsheet_change_file(jsa_id,\n\t\t\t\t\t\t\t\t\t\t\t  full_path_f)\nrjdemetra3::put_ts_metadata(jsap, 1, \"@id\", nid)\njsa <-  rjdemetra3::.jsap_sa(jsap, 1)\nrjdemetra3::get_ts(jsa)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$`@id`\n[1] \"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2FLogiciels%2Fformation.cvs.2023%2FTP%2Fdata_ws_prod.xlsx#seriesName=BE&sheetName=IPI\"\n\n$`@source`\n[1] \"XCLPRVDR\"\n```\n:::\n:::\n\n\nOn peut aussi passer d'un fichier Excel à un fichier CSV :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njsap <- rjdemetra3::.jws_sap(jws_prod_tmp, 1)\ni_serie <- 2\njsa <- rjdemetra3::.jsap_sa(jsap, i_serie)\nname_series <- rjdemetra3::.jsa_name(jsa)\nname_series\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"BG\"\n```\n:::\n\n```{.r .cell-code}\n# On importe le fichier CSV :\nfull_path_f <- base::normalizePath(file.path(dir_dl, \"data_ws_prod.csv\"))\ntxt_data = rjd3providers::txt_series(\n\tfull_path_f, series = i_serie, delimiter = \"SEMICOLON\",\n\tgathering.includeMissing = FALSE, \n\ttxtQualifier = \"DOUBLE_QUOTE\", gathering.period = 12\n\t)\nrjdemetra3::get_ts(jsa)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$`@source`\n[1] \"XCLPRVDR\"\n\n$`@id`\n[1] \"demetra://tsprovider/XCLPRVDR/20111201/SERIES?file=%2FUsers%2Falainquartierlatente%2FDesktop%2Fdata.xlsx#seriesName=BG&sheetName=IPI\"\n```\n:::\n\n```{.r .cell-code}\nrjdemetra3::put_ts_metadata(jsap, i_serie, \"@source\", txt_data$moniker$source)\nrjdemetra3::put_ts_metadata(jsap, i_serie, \"@id\", txt_data$moniker$id)\njsa <-  rjdemetra3::.jsap_sa(jsap, 2)\nrjdemetra3::get_ts(jsa)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`@timestamp`\n[1] \"Sun Oct 08 17:19:31 CEST 2023\"\n\n$`@id`\n[1] \"demetra://tsprovider/Txt/20111201/SERIES?datePattern=&delimiter=SEMICOLON&file=%2FUsers%2Falainquartierlatente%2FDesktop%2FLogiciels%2Fformation.cvs.2023%2FTP%2Fdata_ws_prod.csv&frequency=Monthly&ignoreNumberGrouping=true&locale=&textQualifier=DOUBLE_QUOTE#seriesIndex=1\"\n\n$`@source`\n[1] \"Txt\"\n```\n:::\n:::\n\n\n\n\n\n# Améliorer le suivi de la production\n\nLors de la production courante, on a généralement peu de temps pour étudier tous les modèles de désaisonnalisation.\n{{< fa brands r-project >}} peut grandement vous aider, en faisant des graphiques automatiques, des rapports, des tableaux de bord...\n\nPlusieurs packages peuvent vous aider à faire cela dont :\n\n- [ggdemetra](https://github.com/AQLT/ggdemetra) pour créer facilement des graphiques ggplot2 à partir des modèles de RJDemetra ;\n\n- [rjdqa](https://github.com/AQLT/rjdqa) pour créer des tableaux de bord ;\n\n- [rjdmarkdown](https://github.com/AQLT/rjdmarkdown) pour un meilleur rendu avec rmarkdown des modèles de RJDemetra.\n\n\nPour les packages liés à la version 3 :\n\n- [ggdemetra3](https://github.com/AQLT/ggdemetra3)\n\n- [rjd3report](https://github.com/AQLT/rjd3report) : devrait rassembler `rjdqa` et `rjdmarkdown` (pour l'instant il n'y a que `rjd3report::simple_dashboard()`).\n\n## ggdemetra\n\n[ggdemetra](https://github.com/AQLT/ggdemetra) permet de faire de la désaisonnalisation comme une couche supplémentaire de ggplot2.\n\n- `geom_sa()` : pour ajouter une série temporelle associée à la désaisonnalisation (tendance, série désaisonnalisée, etc.) ;\n- `geom_outlier()` : pour ajouter les points atypiques corrigés dans le pre-ajustement ;\n- `geom_arima()` : pour ajouter le modèle ARIMA ;\n- `geom_diagnostics()` : pour ajouter un tableau avec des diagnostics.\n\nPar exemple, pour tracer les séries désaisonnalisées d'un ensemble de séries temporelles :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdemetra)\ndataGraph <- ts2df(na.omit(ipi_c_eu[,c(\"FR\", \"UK\", \"IT\")]))\ndataGraph <- reshape2::melt(dataGraph, id = \"date\")\nggplot(data = dataGraph, aes (x = date, y = value, color = variable)) +\n\tgeom_sa(component = \"sa\", frequency = 12, spec = x13_spec(\"RSA4c\"))\n```\n\n::: {.cell-output-display}\n![Désaisonnalisation de plusieurs séries avec `ggplot2` grâce à `ggdemetra`.](R_5_JD_in_production_files/figure-html/fig-multiplot-1.png){#fig-multiplot width=672}\n:::\n:::\n\n\nSi vous avez déjà estimé un modèle avec RJDemetra, vous pouvez directement initialiser votre graphique grâce à la fonction `init_ggplot` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- x13(window(ipi_c_eu[,\"FR\"], end = 2019))\ndiagnostics <- c(`Combined test` = \"diagnostics.combined.all.summary\",\n                 `Residual qs-test (p-value)` = \"diagnostics.qs\",\n                 `Residual f-test (p-value)` = \"diagnostics.ftest\")\np_sa <- init_ggplot(mod) +\n\tgeom_line(color =  \"#F0B400\") +\n\tgeom_sa(component = \"y_f\", linetype = 2,\n\t\t\tcolor =  \"#F0B400\") + \n\tgeom_sa(component = \"sa\", color = \"#155692\") +\n\tgeom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2) + \n\tgeom_outlier(geom = \"label_repel\",\n\t\t\t\t coefficients = TRUE,\n\t\t\t\t ylim = c(NA, 65), \n\t\t\t\t arrow = arrow(length = unit(0.03, \"npc\"),\n\t\t\t\t \t\t\t  type = \"closed\", ends = \"last\"),\n\t\t\t\t digits = 2) + \n\tgeom_arima(geom = \"label\",\n\t\t\t   x_arima = -Inf, y_arima = Inf, \n\t\t\t   vjust = 1.2, hjust = -0.1)\np_sa +   \n\tgeom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 6),\n\t\t\t\t\t ymin = 115, ymax = 130, xmin = 2010,\n                     message = FALSE)\n```\n\n::: {.cell-output-display}\n![Exemple des différentes fonctionnalités de `ggdemetra`.](R_5_JD_in_production_files/figure-html/fig-ggdemetra-ex-1.png){#fig-ggdemetra-ex width=672}\n:::\n:::\n\n\nPour combiner plusieurs graphiques on peut également utiliser le package patchwork :\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\np_diag <- init_ggplot(mod)  + \n\tgeom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 8),\n                     message = FALSE) +\n    theme_void()\np_sa / p_diag + \n  plot_layout(heights = unit(c(4, 1.5), \"null\"))\n```\n\n::: {.cell-output-display}\n![Combinaison de plusieurs graphiques de `ggdemetra` avec `patchwork`.](R_5_JD_in_production_files/figure-html/fig-patchwork-1.png){#fig-patchwork width=672}\n:::\n:::\n\n\nLa fonction `ggsiratioplot()` permet de tracer les SI ratios avec ggplot2 :\n\n::: {.cell}\n\n```{.r .cell-code}\nggsiratioplot(mod)\n```\n\n::: {.cell-output-display}\n![S-I ratio avec `ggplot2` et `ggdemetra::ggsiratioplot()`.](R_5_JD_in_production_files/figure-html/fig-ggsiratioplot-1.png){#fig-ggsiratioplot width=672}\n:::\n:::\n\n\nLes différentes composantes du modèle (ainsi que leurs prévisions) peuvent être facilement extraites via les fonctions  `calendar()`, `calendaradj()`, `irregular()`, `trendcycle()`, `seasonal()`, `seasonaladj()`, `trendcycle()` and `raw()`.\n\n::: callout-note\n## Exercice\nCréer une fonction `graph_synthetique()` qui prend en paramètre un modèle de RJDemetra et qui fait deux graphiques :\n\n- à gauche les séries brutes, désaisonnalisée et tendance sur les 10 dernières années ;\n\n- à droite les SI-Ratio.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nPour récupérer les 10 dernières années on pourra récupérer la dernière date connue avec la fonction `time()` et utiliser la fonction `ggplot2::coord_cartesian()` (à préférer à la fonction `ggplot2::xlim()` qui supprime des données et refait donc une désaisonnalisation sur une autre période).\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_synthetique <- function (x, titre = NULL) {\n\ty <- raw(x)\n\tlast_date <- time(y)[length(y)]\n\tp_sa <- init_ggplot(x) +\n\t\tgeom_line(color = \"#F0B400\") +\n\t\tgeom_sa(component = \"sa\", color = \"#155692\") +\n\t\tgeom_sa(component = \"t\", color = \"#1E6C0B\") +\n\t\tcoord_cartesian(xlim = c(last_date - 10, NA)) +\n\t\t# On change l'affichage de l'axe des abscisses\n\t\tscale_x_continuous(labels = zoo::as.yearmon)\n\tp_siratio <- ggsiratioplot(x,\n\t\t\t\t\t\t\t   # supprime le titre\n\t\t\t\t\t\t\t   main = NULL, \n\t\t\t\t\t\t\t   start = last_date - 10) \n\t((p_sa + p_siratio) &\n\t\t# on applique la fonction theme_bw à tous les graphiques\n\t\t\ttheme_bw()) +\n\t\t# On ajoute un titre global\n\t\tplot_annotation(\n\t\t\ttitle = titre\n\t\t)\n}\ngraph_synthetique(mod)\n```\n\n::: {.cell-output-display}\n![Exemple de tableau de bord grâce à `ggdemetra`.](R_5_JD_in_production_files/figure-html/fig-graph-synth-1.png){#fig-graph-synth width=672}\n:::\n:::\n\n\nCi-dessous un exemple de comparaison entre `ggplot2::xlim()` et `ggplot2::coord_cartesian()` :\n\n::: {.cell}\n\n```{.r .cell-code}\np_cc <- init_ggplot(mod) +\n\tgeom_sa(component = \"sa\", color = \"#155692\") +\n\tgeom_sa(component = \"t\", color = \"#1E6C0B\") +\n\tcoord_cartesian(xlim = c(2010, NA), ylim = c(95, 120)) \np_xlim <- init_ggplot(mod) +\n\tgeom_sa(component = \"sa\", color = \"#155692\") +\n\tgeom_sa(component = \"t\", color = \"#1E6C0B\") +\n\txlim(c(2010, NA)) +\n\tcoord_cartesian(ylim = c(95, 120)) \np_cc / p_xlim\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 240 rows containing non-finite values (`stat_sa()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFrequency used: 12\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 240 rows containing non-finite values (`stat_sa()`).\n```\n:::\n\n::: {.cell-output-display}\n![Comparaison des fonctions `ggplot2::xlim()` et `ggplot2::coord_cartesian()`.](R_5_JD_in_production_files/figure-html/fig-cc-xlim-1.png){#fig-cc-xlim width=672}\n:::\n:::\n\nUn message et deux warnings sont générés : c'est parce que les données avant 2010 sont supprimées avec la fonction `xlim()` et qu'une nouvelle désaisonnalisation est alors effectuée (avec une spécification par défaut qui peut être différente de celle utilisée pour créer le modèle).\nCela explique les différences entre les deux graphiques\n:::\n\nÀ partir de la fonction précédente, on peut par exemple faire une fonction qui va lire un workspace et faire un cahier pdf le graphique précédent pour tous les modèles de chaque multiprocessing :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Construisons d'abord un workspace exemple :\ny <- ipi_c_eu[, \"FR\"]\njws <- new_workspace()\nnew_multiprocessing(jws, \"X-13\")\nnew_multiprocessing(jws, \"TRAMO-SEATS\")\nfor (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n\tadd_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n}\nfor (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n\tadd_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n}\ndir <- tempdir()\nsave_workspace(jws, file.path(dir, \"workspace.xml\"))\n\n\njws <- load_workspace(file.path(dir, \"workspace.xml\"))\ncompute(jws)\nall_m <- get_model(jws, progress_bar = FALSE)\nall_m <- lapply(all_m, function(x){\n  # On enlève les espaces à la fin des noms,\n  # cela arrive souvent avec les fichiers Excel\n  names(x) <- gsub(\" *$\", \"\", names(x))\n  x\n})\n# Booléen pour supprimer les fichiers existants\nreplace_existing_file <- TRUE\n# dossier contenant tous les graphiques\ndir_exp <- \"graph\"\nif (!dir.exists(dir_exp))\n  dir.create(dir_exp)\nfor (sap in names(all_m)) {\n  if (!dir.exists(file.path(dir_exp, sap)))\n    dir.create(file.path(dir_exp, sap))\n  for(series in names(all_m[[sap]])) {\n    # Si le fichier existe déjà on ne fait pas l'export\n  \tfile <- file.path(\n  \t\tdir_exp, sap, paste0(\n \t# on ne prend que les 20 premiers caractères pour les noms des fichiers\n  \t# (vite trop long si on part de fichiers Excel)\n  \t\t\tsubstr(series, 1, 20), \n  \t\t\t\".pdf\"))\n\n    if (!replace_existing_file && file.exists(file))\n      next;\n    print(sprintf(\"%s : %s\", sap, series))\n    p_dashboard <- graph_synthetique(x = all_m[[sap]][[series]],\n    \t\t\t\t\t\t\t\t titre = series)\n    ggsave(filename = file, plot = p_dashboard,\n    \t   # format A4 paysage\n           width = 29.7, height = 21, units = \"cm\")\n  }\n}\n\n# Ensuite on va créer un cahier avec tous les pdfs\nfor (sap in names(all_m)) {\n  qpdf::pdf_combine(input = sprintf(\"%s/%s/%s.pdf\", dir_exp, sap,\n  \t\t\t\t\t\t\t\t  substr(names(all_m[[sap]]), 1, 20)),\n                    output = sprintf(\"%s/%s.pdf\", dir_exp, sap))\n}\n```\n:::\n\n\n## rjdqa\n\n[rjdqa](https://github.com/AQLT/rjdqa) permet de reproduire deux tableaux de bord différents (mais avec base R plutôt que ggplot2 pour des raisons de performance) :\n\n- `sc_dashboard()` qui reproduit le tableau de bord de Statistique Canada : voir notamment chapitre 22 du Handbook sur la désaisonnalisation <https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/-/KS-GQ-18-001> ;\n\n- `simple_dashboard()` qui reproduit un tableau de bord simplifié.\n\nSi vous avez d'autres idées n'hésitez pas à contribuer au package ou à faire une issue sur github !\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rjdqa)\nmod <- tramoseats(window(ipi_c_eu[,\"FR\"], end = 2019))\nplot(sc_dashboard(mod))\nplot(simple_dashboard(mod))\n```\n\n::: {.cell-output-display}\n![Tableau de bord de Statistique Canada avec `sc_dashboard()`.](R_5_JD_in_production_files/figure-html/fig-rjdqa-1.png){#fig-rjdqa-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Tableau de bord de simplifié avec `simple_dashboard()`.](R_5_JD_in_production_files/figure-html/fig-rjdqa-2.png){#fig-rjdqa-2 width=672}\n:::\n:::\n\n\n\n\n## rjdmarkdown\n\n[rjdmarkdown](https://github.com/AQLT/rjdmarkdown) fournit différentes fonctions pour améliorer le rendu des modèles avec rmarkdown.\nVoir :\n\n- <https://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-pdf.pdf> pour le rendu en PDF ;\n\n- <https://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-html.html> pour le rendu HTML.\n\nUn document peut également être généré de manière automatique à partir d'un workspace.\nPar exemple :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# # On peut reprendre le workspace précédent\n# y <- ipi_c_eu[, \"FR\"]\n# jws <- new_workspace()\n# new_multiprocessing(jws, \"X-13\")\n# new_multiprocessing(jws, \"TRAMO-SEATS\")\n# for (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n# \tadd_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n# }\n# for (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n# \tadd_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n# }\n# dir <- tempdir()\n# save_workspace(jws, file.path(dir, \"workspace.xml\"))\n\nlibrary(rjdmarkdown)\noutput_file <- tempfile(fileext = \".Rmd\")\ncreate_rmd(jws, output_file, \n\t\t   output_format = c(\"html_document\", \"pdf_document\"),\n\t\t   output_options = list(toc = TRUE,\n\t\t   \t\t\t\t\t  number_sections = TRUE))\nbrowseURL(sub(\".Rmd\",\".pdf\", output_file, fixed = TRUE))\nbrowseURL(sub(\".Rmd\",\".html\", output_file, fixed = TRUE))\n```\n:::\n\n\nEn réutilisant la fonction `graph_synthetique()` précédente :\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput_file <- tempfile(fileext = \".Rmd\")\nout <- create_rmd(jws, output_file, \n           output_format = c(\"pdf_document\"),\n\t\t   preprocessing_fun = NULL,\n\t\t   decomposition_fun = graph_synthetique,\n\t\t   diagnostics_fun = NULL,\n           output_options = list(toc = TRUE,\n                                 number_sections = TRUE),\n\t\t   knitr_chunk_opts = list(fig.pos = \"h\", echo = FALSE,\n\t\t   \t\t\t\t\t\tfig.cap = \"Tableau de bord\"))\nbrowseURL(out)\n```\n:::\n\n\n",
    "supporting": [
      "R_5_JD_in_production_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}